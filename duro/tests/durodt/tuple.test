#!/bin/sh
# Execute tclsh from the user's PATH \
exec tclsh "$0" ${1+"$@"}

# $Id$
#
# Test tuple definitions and operations
#

package require tcltest 2.2
eval ::tcltest::configure $argv
namespace import ::tcltest::*

set testdir [::tcltest::configure -testdir]

test tuplevar {tuple variables} -body {
    exec $testdir/../../dli/durodt << {
        var t1 init tuple {i 5, s 'foo'};
        PRINTLN(CAST_AS_STRING(t1.i) || ' ' || t1.s);
        PRINTLN(t1.i);
        PRINTLN(s FROM t1);

		var t2 init tuple{};
		var t3 init tuple{i 555};
		PRINTLN(t3.i);

        var t4 same_type_as(t1);
        t4 := tup {i 2, s 'bar'};
        PRINTLN(CAST_AS_STRING(t4.i) || ' ' || t4.s);
        PRINTLN(t4 {s});
    }
} -result {5 foo
5
foo
555
2 bar
TUPLE { s 'bar'}
}

test tupleupdexpr {tuple update expression} -body {
    exec $testdir/../../dli/durodt << {
        var t1 init tuple {i 5, s 'bar'};
        PRINTLN((update t1 {i := i + 2, s := s || 'r'}).i);
        PRINTLN(s from (update t1 {i := i + 2, s := s || 'r'}));        
    }
} -result {7
barr
}

test tupleupdstmt {tuple update statement} -body {
    exec $testdir/../../dli/durodt << {
        var t1 init tuple {i 5, s 'bar'};
        update t1 {i := i + 2, s := s || 'r'};
        PRINTLN(t1.i);
        PRINTLN(s from t1);        
    }
} -result {7
barr
}

test union {tuple UNION} -body {
    exec $testdir/../../dli/durodt << {
        var t1 init tuple {i 5, j 6} union tup {j 6, x 2};
        PRINTLN(t1.i);
        PRINTLN(t1.j);
        PRINTLN(t1.x);

        PRINTLN((tuple{} union tuple {s 'yo'}).s);
    }
} -result {5
6
2
yo
}
