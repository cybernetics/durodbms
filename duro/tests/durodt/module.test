#!/bin/sh
# Execute tclsh from the user's PATH \
exec tclsh "$0" ${1+"$@"}

# $Id$
#
# Test database tables and relational operators
#

package require tcltest 2.2
eval ::tcltest::configure $argv
namespace import ::tcltest::*

set testdir [::tcltest::configure -testdir]

set ::SETUP {
    removeDirectory dbenv
    makeDirectory dbenv
    cd $::tcltest::temporaryDirectory
    exec $testdir/../../dli/durodt << {
        create_env('dbenv');
        create_db('D');
    }
}

set ::CLEANUP {
    removeDirectory dbenv
}

test module {Modules} \
        -setup $SETUP -cleanup $CLEANUP -body {
    puts -nonewline [exec $testdir/../../dli/durodt << {
        connect('dbenv');
        current_db := 'D';

        begin tx;

        module m;
        
            operator mul2(n int) returns int;
                return n * 2;
            end operator;
 
            operator puts(s string) updates {};
                put_line(s);
            end operator;

            module modmod_mod;
                operator dec(n int) returns int;
                    return n - 1;
                end operator;

                operator mul2upd(n int) updates {n};
                    n := n * 2;
                end operator;
            end module;

            type t1 possrep { comp int } init(m.t1(0));

            type t2 possrep pr { comp1 int, comp2 string, comp3 float }
                    init(m.pr(0, '-', 0.0));

            var p public relation { n int, s string } key { n };

        end module;

        var r real rel { n int, s string } key { n };

        implement module m;
        
            implement type t1;
            end implement;

            implement type t2;
            end implement;
 
            map p r;

        end implement;

        commit;

        put(m.mul2(5));
        put_line('');
 
        m.puts('Yip');

        put(m.modmod_mod.dec(17));
        put_line('');

        var m int init 7;
        call m.modmod_mod.mul2upd(m);
        put(m);
        put_line('');
    }]
    exec $testdir/../../dli/durodt << {
        connect('dbenv');
        current_db := 'D';

        put(m.mul2(53));
        put_line('');
 
        m.puts('/&;');

        put(m.modmod_mod.dec(10));
        put_line('');

        var mv int init 22;
        call m.modmod_mod.mul2upd(mv);
        put(mv);
        put_line('');
        
        try
            put('Yo'.dec(4));
            put_line('syntax error expected from read-only op invocation');
        catch err syntax_error;
            ;
        end try;

        try
            7.puts('yo');
            put_line('syntax error expected from update op invocation');
        catch err syntax_error;
            ;
        end try;

        var t1v m.t1;
        
        put(the_comp(t1v)); put_line('');
        
        the_comp(t1v) := 4;

        put(the_comp(t1v)); put_line('');

        t1v := m.t1(7);

        put(the_comp(t1v)); put_line('');

        drop var t1v;


        var t2v m.t2;

        put(the_comp1(t2v)); put(' ');
        put(the_comp2(t2v)); put(' ');
        put(the_comp3(t2v)); put_line('');

        the_comp1(t2v) := 4;
        the_comp2(t2v) := 'foo';
        the_comp3(t2v) := 4.2;

        put(the_comp1(t2v)); put(' ');
        put(the_comp2(t2v)); put(' ');
        put(the_comp3(t2v)); put_line('');

        t2v := m.pr(5, 'bar', 2.04);

        put(the_comp1(t2v)); put(' ');
        put(the_comp2(t2v)); put(' ');
        put(the_comp3(t2v)); put_line('');

        drop var t2v;


        -- Test public table
        put_line('');
        begin tx;

        insert m.p tup { n 1, s 'blah' };
        insert m.p tup { n 2, s 'blooo' };

        put_line((tuple from (m.p where n = 1)).s);

        update m.p where n = 2 { s := 'bl o' };

        put_line((tuple from (m.p where n = 2)).s);

        delete m.p where n = 2;

        put_line((tuple from m.p).s);

        m.p := rel { tup { n 10, s 'abc def' }, tup { n 50, s 'Xy !' } };

        var tp tup same_heading_as(m.p);
        for tp in m.p order(n asc);
            put(tp.n);
            put(' ');
            put_line(tp.s);
        end for;

        commit;
    }
} -output {10
Yip
16
14
} -result {106
/&;
9
44
0
4
7
0 - 0.0
4 foo 4.2
5 bar 2.04

blah
bl o
blah
10 abc def
50 Xy !
}

cleanupTests
