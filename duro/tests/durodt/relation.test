#!/bin/sh
# Execute tclsh from the user's PATH \
exec tclsh "$0" ${1+"$@"}

# $Id$
#
# Test scalar definitions and operations
#

package require tcltest 2.2
eval ::tcltest::configure $argv
namespace import ::tcltest::*

set testdir [::tcltest::configure -testdir]

set ::SETUP {
    removeDirectory dbenv
    makeDirectory dbenv
    cd $::tcltest::temporaryDirectory
    exec $testdir/../../dli/durodt << {
        create_env('dbenv');
        create_db('D');
    }
}

test insert {creating table and inserting tuples} -setup $SETUP -body {
    exec $testdir/../../dli/durodt << {
        connect('dbenv');
        current_db := 'D';

        begin transaction;
        var r real relation {i integer, d float, c string} key {i};
        insert r relation {};

        var a init 1;
        insert r relation {tuple {i a, d 1.0, c 'X'}, tuple {i 2, d 1.1, c 'Y'}};

        var s real init r key {i};

        var t init tuple {i 2 + 1, d 1.0, c 'Z'};
        insert r update t {i := i + 1};

        println(string(count(r)));
        println(string(count(s)));
        println((tuple from r where i=2).c);
        commit;
    }
} -result {3
2
Y
}

test invalid_type {invalid (scalar) type for table} -setup $SETUP -match glob -body {
    exec $testdir/../../dli/durodt << {
	    connect('dbenv');
    	current_db := 'D';

	    begin transaction;
    	var ir real integer key {};
    }
}  -returnCodes {1} -result {*TYPE_MISMATCH_ERROR*}

test private {creating private table and inserting tuples} -setup $SETUP -body {
    exec $testdir/../../dli/durodt << {
        connect('dbenv');
        current_db := 'D';

        var r private relation {i integer, d float, c string} key {i};
        insert r relation {};

        var s private relation {i integer} init relation { tuple {i 1}, tuple {i 2} } key {i};

        var a init 1;
        insert r relation {tuple {i a, d 1.0, c 'X'}, tuple {i 2, d 1.1, c 'Y'}};

        insert r tuple {i 2 + 1, d 1.0, c 'Z'}; 

        update r where i=3 { c:= 'ZZ' };

        delete r where i<>2;

        println(count(r));
        println((tuple from r where i=2).c);
        println(sum(s, i));
        drop var r;
    }
} -result {1
Y
3
}

test ra {relational algebra} -setup $SETUP -body {
    exec $testdir/../../dli/durodt << {
        connect('dbenv');
        current_db := 'D';

        begin transaction;

        var t1 real relation {a integer, b string}
        		init relation { tuple {a 1, b 'x'}, tuple {a 2, b 'y'} } key {a};
        var t2 real relation {a integer} key {a};

        insert t2 relation { tuple {a 2}, tuple {a 3} };

        println(with t1 {a} as p, p intersect t2 as is: (tuple from is).a);

        commit;
    }
} -result {2
}

test updop {user defined update operators} -setup $SETUP -body {
    exec $testdir/../../dli/durodt << {
        connect('dbenv');
        current_db := 'D';

        begin transaction;

        operator defop() updates {};
	        begin transaction;
	        
            var tp init tuple {a 0, b "duro"};
            var r real relation same_heading_as(tp) key {a};

            var v virtual (extend r add (b || 'x' as bx));

            commit;
        end operator;

        operator insop(t relation {b string, a integer}) updates {t};
            insert t tuple {a 0, b "duro"};
        end operator;

        defop();
        insop(r);
        println((tuple from v).bx);
        commit;
    }
} -result {durox
}

cleanupTests
