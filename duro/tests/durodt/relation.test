#!/bin/sh
# Execute tclsh from the user's PATH \
exec tclsh "$0" ${1+"$@"}

# $Id$
#
# Test database relvars and relational operators
#

package require tcltest 2.2
eval ::tcltest::configure $argv
namespace import ::tcltest::*

set testdir [::tcltest::configure -testdir]

set ::SETUP {
    removeDirectory dbenv
    makeDirectory dbenv
    cd $::tcltest::temporaryDirectory
    exec $testdir/../../dli/durodt << {
        CREATE_ENV('dbenv');
        CREATE_DB('D');
    }
}

test insert {creating table and inserting tuples} -setup $SETUP -body {
    exec $testdir/../../dli/durodt << {
        connect('dbenv');
        current_db := 'D';

        begin transaction;
        var r real relation {i int, d float, c string} key {i};
        insert r relation {} {};

        var a init 1;
        insert r rel {tuple {i a, d 1.0, c 'X'}, tup {i 2, d 1.1, c 'Y'}};

        var s real init r key {i};

        var t init tuple {i 2 + 1, d 1.0, c 'Z'};
        insert r update t : {i := i + 1};

        put_line(cast_as_string(count(r)));
        put_line(cast_as_string(count(s)));
        put_line((tuple from r where i=2).c);
        
        -- Test table with 2 keys

        var r2 real relation {no int, id string, str string} key {no} key {id};
        insert r2 tup{no 1, id '1', str 'xxx'};

        -- Test key #1
        try
            insert r2 tup {no 1, id '2', str 'yyy'};
        catch err key_violation_error;
            put_line('key violation caught (1)');
        end try;

        -- Test key #2
        try
            insert r2 tup {no 1, id '2', str 'zzz'};
        catch err key_violation_error;
            put_line('key violation caught (2)');
        end try;

        insert r2 tup{no 2, id '2', str 'xxx'};

        -- Table without KEY (implicit all-key)
        var r3 real rel {n int, s string};
        insert r3 tup {n 1, s 'a'};
        insert r3 tup {n 1, s 'b'};
        insert r3 tup {n 2, s 'a'};
        try
            insert r3 tup {n 1, s 'a'};
        catch err element_exists_error;
            put_line('element_exists_error');
        end try;
        put(count(r3)); put_line(' tuples');

        commit;
    }
} -result {3
2
Y
key violation caught (1)
key violation caught (2)
element_exists_error
3 tuples
}

test foreach_drop {DROP in FOREACH} -setup $SETUP -body {
    exec $testdir/../../dli/durodt << {
        connect('dbenv');
        current_db := 'D';

        begin transaction;
        var r real relation {no int, name string} key {no};
        insert r rel{tup{no 1, name 'one'}, tup{no 2, name 'two'}};

        var t tup{no int};
        try
            foreach t in r {no} order();
                drop var r;
            end foreach;
        catch err in_use_error;
            put_line('in_use caught');
        end try;
        commit;
    }
} -result {in_use caught
}

test invalid_type {invalid (scalar) type for table} -setup $SETUP -match glob -body {
    exec $testdir/../../dli/durodt << {
	    connect('dbenv');
    	current_db := 'D';

	    begin transaction;
    	var ir real int key {};
    }
}  -returnCodes {1} -result {*type_mismatch_error*}

test ra {relational algebra} -setup $SETUP -body {
    exec $testdir/../../dli/durodt << {
        connect('dbenv');
        current_db := 'D';

        begin transaction;

        var t1 real relation {a int, b string}
        		init relation { tuple {a 1, b 'x'}, tuple {a 2, b 'y'} } key {a};
        var t2 real relation {a int} key {a};

        var v2 virtual t2 where a<=2;  

        insert t2 relation { tuple {a 2}, tuple {a 3} };

        put(with (p := t1 {a}, is := p intersect t2): (tuple from is).a); put_line('');

        var va init 1;
        put_line((tuple from (t1 where a = va)).b);

        put(is_empty(v2 where a>2)); put_line('');
        put(is_empty(v2 intersect rel{tup{a 2}})); put_line('');

        -- Test nested virtual table
        var vv2 virtual v2 where a>=2;
        put((tuple from vv2).a); put_line('');        

        var tpa tup{a int};
        foreach tpa in t1 {a} order (a asc);
            put(tpa.a); put_line('');
        end foreach;

        var tpb tup{b string};
        foreach tpb in t1 {all but a} order (b asc);
            put_line(tpb.b);
        end foreach;

        var tp tup same_heading_as(t1);
        foreach tp in t1 order (b asc);
            put_line(tp.b);
        end foreach;

        commit;
    }
} -result {2
x
TRUE
FALSE
2
1
2
x
y
x
y
}

test virtual_assign {assignment to virtual tables} -setup $SETUP -body {
    exec $testdir/../../dli/durodt -e dbenv -d D << {
        begin tx;
        var emp real rel{emp_id int, dept_id int, name string} key {emp_id};
        commit;
    }
    exec $testdir/../../dli/durodt -e dbenv -d D << {
        begin tx;
        var empd1 virtual emp where dept_id = 1;
        insert empd1 tup {emp_id 1, dept_id 1, name 'Smith'};
        commit;
    }
    exec $testdir/../../dli/durodt -e dbenv -d D << {
        begin tx;

        insert empd1 tup {emp_id 2, dept_id 1, name 'Jones'};

        try
            -- Must fail because of dept_id=2
            insert empd1 tup {emp_id 3, dept_id 2, name 'Miller'};
        catch err predicate_violation_error;
            put_line('predicate violation caught');
        end try;

        var emptp tup same_heading_as(empd1);
        foreach emptp in empd1 order (emp_id asc);
            put_line(emptp.name);
        end foreach;

        commit;
    }
} -result {predicate violation caught
Smith
Jones
}

test tupleattr {tuple-valued attributes} -setup $SETUP -body {
    exec $testdir/../../dli/durodt << {
        connect('dbenv');
        current_db := 'D';

        begin tx;
        var tr real rel{no int, tp tup{n int, s string}} key{no};
        insert tr tup{no 1, tp tup{n 10, s 'one'}};

        commit;
    }
    # Test with new interpreter instance
    exec $testdir/../../dli/durodt << {
        connect('dbenv');
        current_db := 'D';

        begin tx;

        -- test tuple comparison in WHERE
        var t tup same_heading_as(tr);
        t := tuple from tr where no = 1 and tp = tup{n 10, s 'one'};
        put(t.no); put_line('');
        put(t.tp.n); put_line('');
        put(t.tp.s); put_line('');
        commit;
    }
} -result {1
10
one
}

test updop {user defined update operators} -setup $SETUP -body {
    exec $testdir/../../dli/durodt << {
        connect('dbenv');
        current_db := 'D';

        begin transaction;

        operator defop() updates {};
	        begin transaction;
	        
            var tp init tuple {a 0, b "duro"};
            var r real relation same_heading_as(tp) key {a};

            var v virtual (extend r : {bx := b || 'x'});

            commit;
        end operator;

        operator insop(t relation {b string, a int}) updates {t};
            insert t tuple {a 0, b "duro"};
        end operator;

        defop();
        insop(r);
        put((tuple from v).bx); put_line('');
        commit;
    }
} -result {durox
}

test roop {user defined read-only operators} -setup $SETUP -body {
    exec $testdir/../../dli/durodt << {
        connect('dbenv');
        current_db := 'D';

        begin transaction;

        operator int_to_rel(n int) returns rel{no int};
            var i int;
            var r private rel{no int} key {no};
            for i := 1 to n;
                insert r tup{no i};
            end for;
            return r;
        end operator;

        put(is_empty(int_to_rel(0))); put_line('');
        put(count(int_to_rel(3))); put_line('');
    }
} -result {TRUE
3
} 

test zero_attrs {Tables with zero attributes} -setup $SETUP -body {
    exec $testdir/../../dli/durodt << {        
        connect('dbenv');
        current_db := 'D';

        begin transaction;
        var ev virtual relation {i int} {};
        commit;

        disconnect();

        -- Connect again and read virtual table
        connect('dbenv');
        current_db:='D';
        begin tx;
        put(ev); put_line('');
        commit;
    }
} -result {RELATION {}
}

test logic {Logic operators} -setup $SETUP -body {
    exec $testdir/../../dli/durodt << {
        connect('dbenv');
        current_db := 'D';

        begin transaction;

        var t real relation {a int, b int} key {a, b};

        insert t relation { tuple {a 1, b 1}, tuple {a 1, b 2},
                tuple {a 2, b 1}, tuple {a 2, b 2} };

        var va virtual t where a=1 or b=1;
        var vo virtual t where a=1 and b=1;
        var vx virtual t where a=1 xor b=1;

        var arr array tuple {a int, b int};

        try
            load arr from vo order(i asc, b asc);
        catch err;
            put_line('invalid order clause');
        end try;

        -- Virtual table as variable
        load arr from va order(a asc, b asc);

        var i int;
        for i:= 0 to length(arr)-1;
			put(arr[i].a);
			put(' ');
			put(arr[i].b); put_line('');			
		end for;

		put_line('');

        -- Virtual table as expression
        load arr from t where a=1 or b=1 order(a asc, b asc);

        for i:= 0 to length(arr)-1;
			put(arr[i].a);
			put(' ');
			put(arr[i].b); put_line('');			
		end for;

		put_line('');

        load arr from vo order(a asc, b asc);
        
        for i:= 0 to length(arr)-1;
			put(arr[i].a);
			put(' ');
			put(arr[i].b); put_line('');			
		end for;

		put_line('');

        load arr from t where a=1 and b=1 order(a asc, b asc);
        
        for i:= 0 to length(arr)-1;
			put(arr[i].a);
			put(' ');
			put(arr[i].b); put_line('');			
		end for;

		put_line('');

        load arr from vx order(a asc, b asc);
        for i:= 0 to length(arr)-1;
			put(arr[i].a);
			put(' ');
			put(arr[i].b); put_line('');			
		end for;

		put_line('');

        load arr from t where a=1 xor b=1 order(a asc, b asc);
        for i:= 0 to length(arr)-1;
			put(arr[i].a);
			put(' ');
			put(arr[i].b); put_line('');			
		end for;

        commit;
    }
} -result {invalid order clause
1 1
1 2
2 1

1 1
1 2
2 1

1 1

1 1

1 2
2 1

1 2
2 1
}

test aggregate {Aggregate operators} -setup $SETUP -body {
    exec $testdir/../../dli/durodt << {
        connect('dbenv');
        current_db := 'D';

        begin transaction;

        var t real relation {b BOOLEAN} key {b};

		insert t tup {b true};
		insert t tup {b false};

		put(all(t, b)); put_line('');
		put(and(t, b)); put_line('');
		put(any(t, b)); put_line('');
		put(or(t, b)); put_line('');

        commit;
    }
} -result {FALSE
FALSE
TRUE
TRUE
}

test summarize {SUMMARIZE} -setup $SETUP -body {
    exec $testdir/../../dli/durodt << {
        connect('dbenv');
        current_db := 'D';

        begin transaction;

        var t real relation {a int, b int} key {a, b};

		insert t tup {a 1, b 0};
		insert t tup {a 1, b 1};
		insert t tup {a 2, b 1};
		insert t tup {a 2, b 2};

		var v virtual SUMMARIZE t PER t {a} ADD (
				SUM(b) AS A_SUM,
		        ALL(b > 0) AS A_ALL,
		        AND(b > 0) AS A_AND,
		        ANY(b > 0) AS A_ANY,
		        OR(b > 0) AS A_OR);

        var arr array tuple same_heading_as (v);

        load arr from v order(a asc);

        var i int;
        for i:= 0 to length(arr)-1;
			put(arr[i].A_SUM);
			put(' ');
			put(arr[i].A_ALL);
			put(' ');
			put(arr[i].A_AND);
			put(' ');
			put(arr[i].A_ANY);
			put(' ');
			put(arr[i].A_OR); put_line('');
		end for;

        commit;
    }
} -result {1 FALSE FALSE TRUE TRUE
3 TRUE TRUE TRUE TRUE
}

test relrel {table with relation attribute} -setup $SETUP -body {
    exec $testdir/../../dli/durodt << {
        connect('dbenv');
        current_db := 'D';

        begin transaction;

        var t real relation {x int, a string, r relation{s string, i int}} key {x};

		insert t tuple{x 1, a 'hm', r rel{tup{i 5, s 'yo'}}};

		var tp init tuple from (tuple from t).r;

        put(tp.i); put_line('');
        put_line(tp.s);
        commit;
    }
} -result {5
yo
}

test index {creating index} -setup $SETUP -body {
    exec $testdir/../../dli/durodt << {
        connect('dbenv');
        current_db := 'D';

        begin tx;
        var r real relation {i int, d float, c string} key {i};
        commit;

        begin tx;
        index r_c r (c);
        commit;

        begin tx;
        drop index r_c;
        commit;
    }
}

test real_default {public real table with default values} -setup $SETUP -body {
    exec $testdir/../../dli/durodt << {
        connect('dbenv');
        current_db := 'D';

        begin tx;
        var r1 real relation {i int, r float, c string} key {i}
                default {r 1.2, c 'xyz'};
        insert r1 tup {i 5};
        var t1 init tuple from r1;

        var r2 real relation {i int, r float, c string}
                init rel {tup {i 0, r 1.0, c 'Zz'}}
                key {i} key {c}
                default {r 1.2, c 'xyz'};
        insert r2 tup {i 5};
        var t2 init tuple from (r2 where i=5);

        var r3 real relation {i int, r float, c string}
                init r2 default {r 1.2, c 'xyz'};
        insert r3 tup {i 6, c 'xyy'};
        var t3 init tuple from (r3 where i=6);

        -- Invalid keys
        try
        	var r4 real rel {no int, r float, name string}
            	    key {no} key {no, name} default {name 'John Doe'};
        catch err invalid_argument_error;
            put_line('r4: invalid_argument_error caught');
        end try;

        commit;

        put(t1.i); put(' ');
        put(cast_as_integer(t1.r * 100.0)); put(' ');
        put(t1.c); put_line('');

        put(t2.i); put(' ');
        put(cast_as_integer(t2.r * 100.0)); put(' ');
        put(t2.c); put_line('');

        put(t3.i); put(' ');
        put(cast_as_integer(t3.r * 100.0)); put(' ');
        put(t3.c); put_line('');
    }
} -result {r4: invalid_argument_error caught
5 120 xyz
5 120 xyz
6 120 xyy
}

test dbconstraint {db/table constraints 1} -setup $SETUP -body {
    exec $testdir/../../dli/durodt -e dbenv << {
        current_db := 'D';
        begin transaction;

        operator create_constraint() updates {};
            constraint cr count(r) <= 1;
        end operator;

        operator drop_constraint() updates {};
            drop constraint cr;
        end operator;

        var r real relation {no integer, name string}
                init relation {tuple {no 1, name 'one'}}
                key {no};

        create_constraint();

        try
            insert r tuple {no 2, name 'two'};
        catch err predicate_violation_error;
            put_line('caught predicate violation: ' || THE_MSG(err));
        end try;

        try
            drop var r;
        catch err in_use_error;
            put_line('caught in_use_error');
        end try;

        drop_constraint();
    }
} -result {caught predicate violation: cr
caught in_use_error
}

test dbconstraint2 {db/table constraints 2} -setup $SETUP -body {
    exec $testdir/../../dli/durodt -e dbenv << {
        current_db := 'D';
        begin transaction;
        var r2 real rel {no int} key {no};
        
        constraint cr2 count(r2) <= 1;

        commit;
    }
    # Check for bug which caused the constraint to be still in memory
    # after DROP CONSTRAINT when constraints_read was false
    exec $testdir/../../dli/durodt -e dbenv -d D << {
        drop constraint cr2;
        
        begin tx;
        drop var r2;
        commit;
    }
}

# Test referential constraint, including optimization and EXPLAIN <assignment>
test refconstraint {referential constraint} -setup $SETUP -body {
    puts -nonewline [exec $testdir/../../dli/durodt -e dbenv -d D << {
        begin tx;
        var customers real rel {cust_id int, name string} key {cust_id};
        var orders real rel {order_id int, cust_id int, info string}
                key {order_id} default {info ''};
        constraint o_c orders {cust_id} subset_of customers {cust_id};

        insert customers rel{tup{cust_id 1, name 'James'}, tup{cust_id 2, name 'Joan'}};

        insert orders tup{order_id 1, cust_id 1};

        try
            insert orders tup{order_id 2, cust_id 3};
        catch err predicate_violation_error;
            put_line('insert into orders caught');
        end try;

        try
            delete customers where cust_id=1;
        catch err predicate_violation_error;
            put_line('delete from customers caught');
        end try;

        -- Must succeed
        delete customers where cust_id=2;

        commit;
    }]

    #
    # Check optimization
    #
    set checks [exec $testdir/../../dli/durodt -e dbenv -d D << {
        begin tx;
        explain insert orders tup{order_id 2, cust_id 2};
        commit;
    }]
    if {[string match {*orders*} $checks]} {
        puts "insert check #1 refers to orders: $checks"
    }

    set checks [exec $testdir/../../dli/durodt -e dbenv -d D << {
        begin tx;
        explain insert customers tup{cust_id 2, name 'John'};
        commit;
    }]
    if {[string match {*orders*} $checks]
            || [string match {*customers*} $checks]} {
        puts "insert check #2 refers to orders or customers: $checks"
    }    

    set checks [exec $testdir/../../dli/durodt -e dbenv -d D << {
        begin tx;
        explain delete orders where order_id=1;
        commit;
    }]
    if {[string match {*orders*} $checks]
            || [string match {*customers*} $checks]} {
        puts "delete check #1 refers to orders or customers: $checks"
    }    

    set checks [exec $testdir/../../dli/durodt -e dbenv -d D << {
        begin tx;
        explain delete customers where cust_id=1;
        commit;
    }]
    if {![string match {*INDEX customers$0*} $checks]} {
        puts "delete check #2 does not use primary index of customers"
    }

    set checks [exec $testdir/../../dli/durodt -e dbenv -d D << {
        begin tx;
        explain update orders where order_id=1 {info := 'yo'};
        commit;
    }]
    if {[string match {*orders*} $checks]
            || [string match {*customers*} $checks]} {
        puts "update check #1 refers to orders or customers: $checks"
    }    

    set checks [exec $testdir/../../dli/durodt -e dbenv -d D << {
        begin tx;
        explain update customers where cust_id=1 {name := 'Karlheiz'};
        commit;
    }]
    if {[string match {*orders*} $checks]
            || [string match {*customers*} $checks]} {
        puts "update check #2 refers to orders or customers: $checks"
    }    

} -output {insert into orders caught
delete from customers caught
}

test utypetable {table with attribute of user-defined type} -body {
    exec $testdir/../../dli/durodt -e dbenv << {
        current_db := 'D';
        begin transaction;

        type utype
            possrep { s string };

        implement type utype;
        end implement;

        var utr real rel{id int, uv utype} key {id};
        insert utr rel{tup{id 1, uv utype('a')},
                       tup{id 2, uv utype('b')}};

        try
            put_line(the_s(utr));
        catch err type_mismatch_error;
            put_line('type mismatch caught');
        end try;

        put_line(the_s((tuple from utr where id=1).uv));

        commit;

        begin tx;

        try
            drop type utype;
        catch err in_use_error;
            put_line('caught in_use_error');
        end try;

        drop var utr;
        drop type utype;

        commit;
    }
} -result {type mismatch caught
a
caught in_use_error
}

cleanupTests
