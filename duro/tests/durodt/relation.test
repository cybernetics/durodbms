#!/bin/sh
# Execute tclsh from the user's PATH \
exec tclsh "$0" ${1+"$@"}

# $Id$
#
# Test scalar definitions and operations
#

package require tcltest 2.2
eval ::tcltest::configure $argv
namespace import ::tcltest::*

set testdir [::tcltest::configure -testdir]

set ::SETUP {
    removeDirectory dbenv
    makeDirectory dbenv
    cd $::tcltest::temporaryDirectory
    exec $testdir/../../dli/durodt << {
        CREATE_ENV('dbenv');
        CREATE_DB('D');
    }
}

test insert {creating table and inserting tuples} -setup $SETUP -body {
    exec $testdir/../../dli/durodt << {
        CONNECT('dbenv');
        CURRENT_DB := 'D';

        begin transaction;
        var r real relation {i INTEGER, d FLOAT, c STRING} key {i};
        insert r relation {} {};

        var a init 1;
        insert r rel {tuple {i a, d 1.0, c 'X'}, tup {i 2, d 1.1, c 'Y'}};

        var s real init r key {i};

        var t init tuple {i 2 + 1, d 1.0, c 'Z'};
        insert r update t {i := i + 1};

        PRINTLN(CAST_AS_STRING(count(r)));
        PRINTLN(CAST_AS_STRING(count(s)));
        PRINTLN((tuple from r where i=2).c);
        commit;
    }
} -result {3
2
Y
}

test invalid_type {invalid (scalar) type for table} -setup $SETUP -match glob -body {
    exec $testdir/../../dli/durodt << {
	    CONNECT('dbenv');
    	CURRENT_DB := 'D';

	    begin transaction;
    	var ir real INTEGER key {};
    }
}  -returnCodes {1} -result {*TYPE_MISMATCH_ERROR*}

test private {creating private table and inserting tuples} -setup $SETUP -body {
    exec $testdir/../../dli/durodt << {
        CONNECT('dbenv');
        CURRENT_DB := 'D';

        var r private relation {i INTEGER, d FLOAT, c STRING} key {i};
        insert r relation {} {};

        var s private relation {i INTEGER} init relation { tuple {i 1}, tuple {i 2} } key {i};

        var a init 1;
        insert r relation {tuple {i a, d 1.0, c 'X'}, tuple {i 2, d 1.1, c 'Y'}};

        insert r tuple {i 2 + 1, d 1.0, c 'Z'}; 

        update r where i=3 { c:= 'ZZ' };

        delete r where i<>2;

        PRINTLN(count(r));
        PRINTLN((tuple from r where i=2).c);
        PRINTLN(sum(s, i));
        drop var r;
        
        -- test invalid relation selector
        try
            var r init relation {a INTEGER} {tuple {a 'x'}};
        catch err TYPE_MISMATCH_ERROR;
            PRINTLN("type mismatch");
        end try;
        
        PRINTLN((tuple from relation {a INTEGER} {tuple {a 7}}).a);
    }
} -result {1
Y
3
type mismatch
7
}

test ra {relational algebra} -setup $SETUP -body {
    exec $testdir/../../dli/durodt << {
        CONNECT('dbenv');
        CURRENT_DB := 'D';

        begin transaction;

        var t1 real relation {a INTEGER, b STRING}
        		init relation { tuple {a 1, b 'x'}, tuple {a 2, b 'y'} } key {a};
        var t2 real relation {a INTEGER} key {a};

        insert t2 relation { tuple {a 2}, tuple {a 3} };

        PRINTLN(with (is := p intersect t2, p := t1 {a}): (tuple from is).a);

		PRINTLN((tuple from relation{tuple{i 1}} join table_dee).i);

        var a array tuple{i INTEGER};
        load a from rel{tup{i 1}} union rel{tup{i 2}} order (i asc);
        PRINTLN(a[0].i);
        PRINTLN(a[1].i);

        commit;
    }
} -result {2
1
1
2
}

test updop {user defined update operators} -setup $SETUP -body {
    exec $testdir/../../dli/durodt << {
        CONNECT('dbenv');
        CURRENT_DB := 'D';

        begin transaction;

        operator defop() updates {};
	        begin transaction;
	        
            var tp init tuple {a 0, b "duro"};
            var r real relation same_heading_as(tp) key {a};

            var v virtual (extend r : {bx := b || 'x'});

            commit;
        end operator;

        operator insop(t relation {b STRING, a INTEGER}) updates {t};
            insert t tuple {a 0, b "duro"};
        end operator;

        defop();
        insop(r);
        PRINTLN((tuple from v).bx);
        commit;
    }
} -result {durox
}

test deedum {TABLE_DEE and TABLE_DUM} -setup $SETUP -body {
    exec $testdir/../../dli/durodt << {
        PRINTLN(tup from TABLE_DEE);
        PRINTLN(tup from DEE);

        PRINTLN(TABLE_DUM);
        PRINTLN(DUM);

        PRINTLN(tuple from (rel{} {} union table_dee));
        
        CONNECT('dbenv');
        CURRENT_DB := 'D';

        begin transaction;
        var ev virtual relation {i INTEGER} {};
        commit;

        DISCONNECT();

        -- Connect again and read virtual table
        CONNECT('dbenv');
        CURRENT_DB:='D';
        begin tx;
        PRINTLN(ev);
        commit;
    }
} -result {TUPLE { }
TUPLE { }
RELATION { }
RELATION { }
TUPLE { }
RELATION { }
}

test logic {Logic operators} -setup $SETUP -body {
    exec $testdir/../../dli/durodt << {
        CONNECT('dbenv');
        CURRENT_DB := 'D';

        begin transaction;

        var t real relation {i INTEGER, j INTEGER} key {i, j};

        insert t relation { tuple {i 1, j 1}, tuple {i 1, j 2},
                tuple {i 2, j 1}, tuple {i 2, j 2} };

        var va virtual t where i=1 or j=1;
        var vo virtual t where i=1 and j=1;
        var vx virtual t where i=1 xor j=1;
        
        var a array tuple {i INTEGER, j INTEGER};

        load a from va order(i asc, j asc);
        
        var i INTEGER;
        for i:= 0 to LENGTH(a)-1;
			PRINT(a[i].i);
			PRINT(' ');
			PRINTLN(a[i].j);			
		end for;

		PRINTLN("");

        load a from vo order(i asc, j asc);
        
        for i:= 0 to LENGTH(a)-1;
			PRINT(a[i].i);
			PRINT(' ');
			PRINTLN(a[i].j);			
		end for;

		PRINTLN("");

        load a from vx order(i asc, j asc);

        for i:= 0 to LENGTH(a)-1;
			PRINT(a[i].i);
			PRINT(' ');
			PRINTLN(a[i].j);			
		end for;

        commit;
    }
} -result {1 1
1 2
2 1

1 1

1 2
2 1
}

test aggregate {Aggregate operators} -setup $SETUP -body {
    exec $testdir/../../dli/durodt << {
        CONNECT('dbenv');
        CURRENT_DB := 'D';

        begin transaction;

        var t real relation {b BOOLEAN} key {b};

		insert t tup {b true};
		insert t tup {b false};

		PRINTLN(all(t, b));
		PRINTLN(and(t, b));
		PRINTLN(any(t, b));
		PRINTLN(or(t, b));

        commit;
    }
} -result {FALSE
FALSE
TRUE
TRUE
}

test summarize {SUMMARIZE} -setup $SETUP -body {
    exec $testdir/../../dli/durodt << {
        CONNECT('dbenv');
        CURRENT_DB := 'D';

        begin transaction;

        var t real relation {i INTEGER, j INTEGER} key {i, j};

		insert t tup {i 1, j 0};
		insert t tup {i 1, j 1};
		insert t tup {i 2, j 1};
		insert t tup {i 2, j 2};

		var v virtual SUMMARIZE t PER t {i} ADD (
				SUM(j) AS A_SUM,
		        ALL(j > 0) AS A_ALL,
		        AND(j > 0) AS A_AND,
		        ANY(j > 0) AS A_ANY,
		        OR(j > 0) AS A_OR);

        var arr array tuple same_heading_as (v);

        load arr from v order(i asc);

        var i INTEGER;
        for i:= 0 to LENGTH(arr)-1;
			PRINT(arr[i].A_SUM);			
			PRINT(' ');
			PRINT(arr[i].A_ALL);			
			PRINT(' ');
			PRINT(arr[i].A_AND);
			PRINT(' ');
			PRINT(arr[i].A_ANY);
			PRINT(' ');
			PRINTLN(arr[i].A_OR);
		end for;

        commit;
    }
} -result {1 FALSE FALSE TRUE TRUE
3 TRUE TRUE TRUE TRUE
}

test relrel {table with relation attribute} -setup $SETUP -body {
    exec $testdir/../../dli/durodt << {
        CONNECT('dbenv');
        CURRENT_DB := 'D';

        begin transaction;

        var t real relation {x INTEGER, a STRING, r relation{s STRING, i INTEGER}} key {x};

		insert t tuple{x 1, a 'hm', r rel{tup{i 5, s 'yo'}}};

		var tp init tuple from (tuple from t).r;

        PRINTLN(tp.i);
        PRINTLN(tp.s);
        commit;
    }
} -result {5
yo
}

test group {GROUP} -body {
    exec $testdir/../../dli/durodt << {
		var gt init rel{tup{i 1, j 1}, tup{i 2, j 2}} group {i, j} as ij;
		PRINTLN((tuple from gt).ij = rel{tup{i 1, j 1}, tup{i 2, j 2}});
    }
} -result {TRUE
}

test ungroup {UNGROUP} -body {
    exec $testdir/../../dli/durodt << {
		var ugt init rel{
		        tup {st rel{tup{s 'a', t 'b'}, tup{s 'c', t 'd'}}},
		        tup {st rel{tup{s 'e', t 'f'}}}} ungroup st;
		var arr array tuple{s STRING, t STRING};
		load arr from ugt order(s asc);
		PRINTLN(LENGTH(arr));
		PRINTLN(arr[0].s);
		PRINTLN(arr[0].t);
		PRINTLN(arr[1].s);
		PRINTLN(arr[1].t);
		PRINTLN(arr[2].s);
		PRINTLN(arr[2].t);
    }
} -result {3
a
b
c
d
e
f
}

test sdivide {small DIVIDE} -body {
    exec $testdir/../../dli/durodt << {
        var pizzas private init rel{tup{pizza# 1}, tup{pizza# 2}};
        var condiments private init rel{tup{cond 'salami'},tup{cond 'mushrooms'}};

        try
            var p_c private init rel{tup{pizza# 1, cond 'salami'},
                    tup{pizza 2, cond 'salami'}, tup{pizza 2, cond 'mushrooms'}};
        catch err;
            PRINTLN('error caught');
        end try;

        var p_c private init rel{tup{pizza# 1, cond 'salami'},
                tup{pizza# 2, cond 'salami'}, tup{pizza# 2, cond 'mushrooms'}};
                
        -- Get # of pizza with all condiments
        PRINTLN((tuple from (pizzas divideby condiments per (p_c))).pizza#);
    }
} -result {error caught
2
}

cleanupTests
