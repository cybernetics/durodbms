#!/bin/sh
# Execute tclsh from the user's PATH \
exec tclsh "$0" ${1+"$@"}

# $Id$
#
# Test public tables
#

package require tcltest 2.2
eval ::tcltest::configure $argv
namespace import ::tcltest::*

set testdir [::tcltest::configure -testdir]

set ::SETUP {
    removeDirectory dbenv
    makeDirectory dbenv
    cd $::tcltest::temporaryDirectory
    exec $testdir/../../dli/durodt << {
        CREATE_ENV('dbenv');
        CREATE_DB('D');
    }
}

set ::CLEANUP {
    removeDirectory dbenv
}

test create {creating and populating public table} -setup $SETUP -cleanup $CLEANUP -body {
    exec $testdir/../../dli/durodt << {
        connect('dbenv');
        current_db := 'D';

        begin transaction;
        var r1 real relation {no int, c string} key {no};
        var r2 real relation {no int, c float} key {no};
        var r3 real relation {no int, c string};
        commit;

        begin tx;
        
        var p public relation {no int, c string} key {no};

        -- not mapped
        try
            var i init count(p);
        catch err name_error;
            put_line('name error caught');
        end try;

        map p r1;

        -- type mismatch
        try
            map p r2;
        catch err type_mismatch_error;
            put_line('type mismatch caught');
        end try;

        -- keys do not match
        try
            map p r3;
        catch err invalid_argument_error;
            put_line('invalid arguments caught');
        end try;

        insert p tup{no 1, c 'one'};
        insert r1 tup{no 2, c 'two'};

        var tp tuple same_heading_as(p);
        for tp in p order(no asc);
            put(tp.no);
            put(' ');
            put_line(tp.c);
        end for;

        put(count(p)); put_line('');
        commit;

        put_line('');

        begin tx;

        -- remap to new table
        var r4 real relation {no int, c string} init rel{tup{no 10, c 'ten'}} key {no};

        map p r4;

        insert p tup{no 11, c 'eleven'};

        for tp in p order(no asc);
            put(tp.no);
            put(' ');
            put_line(tp.c);
        end for;        

        drop var p;

        try
            var cnt init count(p);
        catch err name_error;
            put_line('name error caught');
        end try;

        put(count(r1)); put_line('');
        commit;
    }
} -result {name error caught
type mismatch caught
invalid arguments caught
1 one
2 two
2

10 ten
11 eleven
name error caught
2
}

test union {UNION and D_UNION} -body {
    exec $testdir/../../dli/durodt << {
        var p private init rel{tup{n 1, s 'alpha'}};
        var v int;

        try
            v := count(p union rel{tup{n 2, m 3, s 'beta'}});
        catch err type_mismatch_error;
            put_line('type mismatch (1)');
        end try;

        try
            v := count(p d_union rel{tup{n 2, m 3, s 'beta'}});
        catch err type_mismatch_error;
            put_line('type mismatch (2)');
        end try;

        put_line((tuple from p union rel{tup{n 1, s 'alpha'}}).s);
        
        try
        put_line((tuple from p d_union rel{tup{n 1, s 'alpha'}}).s);
        catch err element_exists_error;
            put_line('element_exists_error caught');
        end try;

        var tp tuple same_heading_as(p);
        for tp in p d_union rel{tup{n 1, s 'alfa'}} order (s asc);
            put_line(tp.s);
        end for;

        put_line('');

        for tp in rel{tup{n 1, s 'alfa'}, tup{n 2, s 'beta'}} d_union p
                order (s asc);
            put_line(tp.s);
        end for;

        if (tup{n 1, s 'alfa'} in (p d_union rel{tup{n 1, s 'alfa'}})) then
            put_line('ok');
        end if;
    }
} -result {type mismatch (1)
type mismatch (2)
alpha
element_exists_error caught
alfa
alpha

alfa
alpha
beta
ok
}

test create_allkey {creating public table that is implicitly all-key} -setup $SETUP -cleanup $CLEANUP -body {
    exec $testdir/../../dli/durodt << {
        connect('dbenv');
        current_db := 'D';

        begin transaction;
        var r1 real relation {no int, c string} key {no, c};
        var p public relation {no int, c string};
        map p r1;
        commit;

        begin tx;
        drop var p;
        commit;
    }
}

test rollback {rollback after accessing public} -setup $SETUP -cleanup $CLEANUP -body {
    exec $testdir/../../dli/durodt << {
        connect('dbenv');
        current_db := 'D';

        begin transaction;
        var r real relation {no int, name string, data string}
                key {no} key {name};

        var p public relation {no int, name string, data string}
                key {no} key {name};

        map p r;
        commit;

        begin tx;
        var cnt init count(p);
        rollback;
    }
}
