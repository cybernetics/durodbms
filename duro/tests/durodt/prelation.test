#!/bin/sh
# Execute tclsh from the user's PATH \
exec tclsh "$0" ${1+"$@"}

# $Id$
#
# Test public tables
#

package require tcltest 2.2
eval ::tcltest::configure $argv
namespace import ::tcltest::*

set testdir [::tcltest::configure -testdir]

set ::SETUP {
    removeDirectory dbenv
    makeDirectory dbenv
    cd $::tcltest::temporaryDirectory
    exec $testdir/../../dli/durodt << {
        CREATE_ENV('dbenv');
        CREATE_DB('D');
    }
}

set ::CLEANUP {
    removeDirectory dbenv
}

test create {creating and populating public table} -setup $SETUP -cleanup $CLEANUP -body {
    exec $testdir/../../dli/durodt << {
        connect('dbenv');
        current_db := 'D';

        begin transaction;
        var r1 real relation {no int, c string} key {no};
        var r2 real relation {no int, c float} key {no};
        var r3 real relation {no int, c string};
        commit;

        begin tx;
        
        var p public relation {no int, c string} key {no};

        -- not mapped
        try
            var i init count(p);
        catch err name_error;
            put_line('name error caught');
        end try;

        map p r1;

        -- type mismatch
        try
            map p r2;
        catch err type_mismatch_error;
            put_line('type mismatch caught');
        end try;

        -- keys do not match
        try
            map p r3;
        catch err invalid_argument_error;
            put_line('invalid arguments caught');
        end try;

        insert p tup{no 1, c 'one'};
        insert r1 tup{no 2, c 'two'};

        var tp tuple same_heading_as(p);
        for tp in p order(no asc);
            put(tp.no);
            put(' ');
            put_line(tp.c);
        end for;

        put(count(p)); put_line('');
        commit;

        put_line('');

        begin tx;

        -- remap to new table
        var r4 real relation {no int, c string} init rel{tup{no 10, c 'ten'}} key {no};

        map p r4;

        insert p tup{no 11, c 'eleven'};

        for tp in p order(no asc);
            put(tp.no);
            put(' ');
            put_line(tp.c);
        end for;        

        -- Rename
        rename var p as p2;
        put_line((tuple from p2 where no = 11).c);

        drop var p2;

        try
            var cnt init count(p);
        catch err name_error;
            put_line('name error caught');
        end try;

        put(count(r1)); put_line('');
        commit;
    }
} -result {name error caught
type mismatch caught
invalid arguments caught
1 one
2 two
2

10 ten
11 eleven
eleven
name error caught
2
}

test create_allkey {creating public table that is implicitly all-key} -setup $SETUP -cleanup $CLEANUP -body {
    exec $testdir/../../dli/durodt << {
        connect('dbenv');
        current_db := 'D';

        begin transaction;
        var r1 real relation {no int, c string} key {no, c};
        var p public relation {no int, c string};
        map p r1;
        commit;

        begin tx;
        drop var p;
        commit;
    }
}

test rollback {rollback after accessing public} -setup $SETUP -cleanup $CLEANUP -body {
    exec $testdir/../../dli/durodt << {
        connect('dbenv');
        current_db := 'D';

        begin transaction;
        var r real relation {no int, name string, data string}
                key {no} key {name};

        var p public relation {no int, name string, data string}
                key {no} key {name};

        map p r;
        commit;

        begin tx;
        var cnt init count(p);
        rollback;
    }
}
