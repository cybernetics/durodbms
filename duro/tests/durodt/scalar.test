#!/bin/sh
# Execute tclsh from the user's PATH \
exec tclsh "$0" ${1+"$@"}

# $Id$
#
# Test scalar definitions and operations
#

package require tcltest 2.2
eval ::tcltest::configure $argv
namespace import ::tcltest::*

set testdir [::tcltest::configure -testdir]

makeDirectory dbenv

set ::DBSETUP {
    removeDirectory dbenv
    makeDirectory dbenv
    cd $::tcltest::temporaryDirectory
    exec $testdir/../../dli/durodt << {
        create_env('dbenv');
        create_db('D');
    }
}

test scalar_builtin {built-in scalar definitions and operators} -body {
    exec $testdir/../../dli/durodt $testdir/scalar.td
} -result {2
3
XX
FALSE
}

test deftype {user-defined types} -setup $DBSETUP -body {
    exec $testdir/../../dli/durodt << {
        connect('dbenv');
        type T
            possrep { a integer, b integer };

        implement type T;

        current_db := 'D';
        begin transaction;
        var V T;
        println(the_a(V));
        println(the_b(V));
        
        V := T(1, 2);
        println(the_a(V));
        println(the_b(V));

        commit;

        -- Dropping T must fail because V still exists
        try
            drop type T;
		catch ex IN_USE_ERROR;
		    println('caught IN_USE');
		end try;

        drop var V;
        drop type T;
    }
} -result {0
0
1
2
caught IN_USE
}

test defroop {read-only user-defined operators} -setup $DBSETUP -body {
    exec $testdir/../../dli/durodt -e dbenv << {
        operator testop() returns string;
            var a integer;
            var b integer init 1;
            var c integer;

            if a <> 0 then
                return "error: a <> 0";
            end if;

            if a = 0 then
            begin;
                a := a + 1;
            end;
            else
                return "error: (a = 0) is false";
            end if;

            var i init 0;
            drop var c;
            var c init 1;
            while i < 3;
                var one init 1;
                i := i + one;
                c := c * 2;
            end while;

            var d init 1;
            for i:= 1 to 3;
                d := d * 2 + 1;
            end for;

            return "a = " || cast_as_string(a) || ", b = " || cast_as_string(b)
                     || ", c = " || cast_as_string(c) || ", d = " || cast_as_string(d);
        end operator;

        /*
         * Reverse string.
         */
        operator reverse(s string) returns string;
            var res string;	-- automatically initialized to ''
            var len init length(s);

            var i integer init len - 1;
            while i >= 0;
                res := res || substring(s, i, 1);
                i := i - 1;
            end while;
            return res;
        end operator;

        operator fib(n integer) returns integer;
            return if n < 2 then n else fib(n - 1) + fib(n - 2);
        end operator;

        operator sgn(n integer) returns integer;
            case
                when n < 0 then return -1;
                when n > 0 then return 1;
                else return 0;
            end case;
        end operator;

        current_db := 'D';
        begin tx;

        println(testop());

        println(reverse("Madam, I'm Adam."));

        println(fib(6));

        println(sgn(5));
        println(sgn(0));

        commit;

        drop operator testop;
    }
} -result {a = 1, b = 1, c = 8, d = 15
.madA m'I ,madaM
8
1
0
}

test defupdop {user-defined update operators} -setup $DBSETUP -body {
    exec $testdir/../../dli/durodt -e dbenv << {
        current_db := 'D';
        begin transaction;

        operator op(s string, i integer) updates {s};
            i := i + 1;

            type length_t possrep { m float } constraint (m >= 0.0);

            drop type length_t;

            operator op1(s string) returns string;
                return s || 'y';
            end operator;

            operator op2(s string) updates { s };
                s := s || 'z';
            end operator;

            s := op1(s);
            op2(s);

            drop operator op1;
            drop operator op2;

            return;
        end operator;

        var a string init 'x';
        var b integer init 1;
        op(a, b);
        println("a = " || a || ", b = " || cast_as_string(b));

        drop var a;

        commit;
    }
} -result {a = xyz, b = 1
}

test tconstraint {db/table constraints} -setup $DBSETUP -body {
    exec $testdir/../../dli/durodt -e dbenv << {
        current_db := 'D';
        begin transaction;

        operator create_constraint() updates {};
            constraint cr count(r) <= 1;
        end operator;

        operator drop_constraint() updates {};
            drop constraint cr;
        end operator;

        var r real relation {no integer, name string}
                init relation {tuple {no 1, name 'one'}}
                key {no};

        create_constraint();

        try
            insert r tuple {no 2, name 'two'};
        catch err predicate_violation_error;
            println('caught predicate violation: ' || the_msg(err));
        end try;

        drop_constraint();

        commit;
    }
} -result {caught predicate violation: CR
}

test trycatch {TRY .. CATCH} -setup $DBSETUP -body {
    exec $testdir/../../dli/durodt -e dbenv << {
        current_db := 'D';
        begin transaction;

        operator test() updates {};
            var s string;
            try
                s := substring('x', 1, 1);
            catch err name_error;
                println('caught name_error');
            catch err;
                println('caught');
            end try;
        end operator;

        test();

        commit;
    }
} -result {caught
}

test getenv {GETENV operator} -setup $DBSETUP -body {
    set ::env(TEST) DUROTEST

    exec $testdir/../../dli/durodt -e dbenv << {
        println(getenv('TEST'));
    }
} -result {DUROTEST
}

cleanupTests
