#!/bin/sh
# Execute tclsh from the user's PATH \
exec tclsh "$0" ${1+"$@"}

# $Id$
#
# Test scalar definitions and operations
#

package require tcltest 2.2
eval ::tcltest::configure $argv
namespace import ::tcltest::*

set testdir [::tcltest::configure -testdir]

makeDirectory dbenv

set ::SETUP {
    removeDirectory dbenv
    makeDirectory dbenv
    cd $::tcltest::temporaryDirectory
    exec $testdir/../../dli/durodt << {
        create_env('dbenv');
        create_db('D');
    }
}

test scalar_builtin {built-in scalar definitions and operators} -body {
    exec $testdir/../../dli/durodt $testdir/scalar.td
} -result {2
3
XX
FALSE
error caught
}

test casts {cast operators} -body {
    exec $testdir/../../dli/durodt << {
	    put(cast_as_integer('11')); put_line('');
	    put(cast_as_int('-7')); put_line('');
	    put(cast_as_integer(-3.0)); put_line('');
	    put(cast_as_int(5.1)); put_line('');
	
	    put(cast_as_float('1.1')); put_line('');
	    put(cast_as_rational('-5.3')); put_line('');
	    put(cast_as_rat('4.0')); put_line('');
	    put(cast_as_float(1)); put_line('');
	    put(cast_as_rational(2)); put_line('');
	    put(cast_as_rat(0)); put_line('');

	    put_line(cast_as_string(500));
	    put_line(cast_as_char(-13));
	    put_line(cast_as_string(-34.5551));
	    put_line(cast_as_char(0.0));
    }
} -result {11
-7
-3
5
1.1
-5.3
4.0
1.0
2.0
0.0
500
-13
-34.5551
0.0
}

test deftype {user-defined types} -setup $SETUP -body {
    exec $testdir/../../dli/durodt << {
        connect('dbenv');
        current_db := 'D';
        type t
            possrep { a integer, b integer };

        implement type t;
        end implement;

        CURRENT_DB := 'D';
        begin transaction;
        var V t;
        put(THE_a(V)); put_line('');
        put(THE_b(V)); put_line('');
        
        V := t(1, 2);
        put(THE_a(V)); put_line('');
        put(THE_b(V)); put_line('');

        THE_a(V) := 5;
        put(THE_a(V)); put_line('');

        commit;

        -- Dropping t must fail because V still exists
        try
            drop type t;
		catch ex in_use_error;
		    put_line('caught in_use_error');
		end try;

        drop var V;
        drop type t;

        try
            type string5 possrep {value string} constraint length(val) <= 5;
		catch ex name_error;
		    put_line('caught name_error');
		end try;        

        type string5 possrep {value string} constraint length(value) <= 5;
        implement type string5;
        end implement;

        begin tx;

        var s string5;
        
        s := string5('OK');

        try
        	s := string5('Too long');
        catch err type_constraint_violation_error;
            put_line('type constraint violation caught');
        end try;
        commit;
    }
} -result {0
0
1
2
5
caught in_use_error
caught name_error
type constraint violation caught
}

test defroop {read-only user-defined operators} -setup $SETUP -body {
    exec $testdir/../../dli/durodt -e dbenv -d D << {
        operator testop() returns string;
            var a integer;
            var b integer init 1;
            var c integer;

            if a <> 0 then
                return "error: a <> 0";
            end if;

            if a = 0 then
            begin;
                a := a + 1;
            end;
            else
                return "error: (a = 0) is false";
            end if;

            var i init 0;
            drop var c;
            var c init 1;
            while i < 3;
                var one init 1;
                i := i + one;
                c := c * 2;
            end while;

            var d init 1;
            for i:= 1 to 3;
                d := d * 2 + 1;
            end for;

            return "a = " || cast_as_string(a) || ", b = " || cast_as_string(b)
                     || ", c = " || cast_as_string(c) || ", d = " || cast_as_string(d);
        end operator;

        /*
         * Reverse string.
         */
        operator reverse(s string) returns string;
            var res string;	-- automatically initialized to ''
            var len init LENGTH(s);

            var i integer init len - 1;
            while i >= 0;
                res := res || substr(s, i, 1);
                i := i - 1;
            end while;
            return res;
        end operator;

        operator fib(n integer) returns integer;
            return if n < 2 then n else fib(n - 1) + fib(n - 2);
        end operator;

        operator sgn(n integer) returns integer;
            case
                when n < 0 then return -1;
                when n > 0 then return 1;
                else return 0;
            end case;
        end operator;

        CURRENT_DB := 'D';
        begin tx;

        put_line(testop());

        put_line(reverse("Madam, I'm Adam."));

        put(fib(6)); put_line('');

        put(sgn(5)); put_line('');
        put(sgn(0)); put_line('');

        commit;

        drop operator testop;
    }
} -result {a = 1, b = 1, c = 8, d = 15
.madA m'I ,madaM
8
1
0
}

test defupdop {user-defined update operators} -setup $SETUP -body {
    exec $testdir/../../dli/durodt -e dbenv << {
        CURRENT_DB := 'D';
        begin transaction;

        operator op(s string, i integer) updates {s};
            i := i + 1;

            type LENGTH_T possrep { m FLOAT } constraint (m >= 0.0);

            drop type LENGTH_T;

            operator op1(s string) returns string;
                return s || 'y';
            end operator;

            operator op2(s string) updates { s };
                s := s || 'z';
            end operator;

            s := op1(s);
            op2(s);

            drop operator op1;
            drop operator op2;

            return;
        end operator;

        var a string init 'x';
        var b integer init 1;
        op(a, b);
        put_line("a = " || a || ", b = " || cast_as_string(b));

        op(a, b);

        drop var a;

        commit;
    }
} -result {a = xyz, b = 1
}

test trycatch {TRY .. CATCH} -setup $SETUP -body {
    exec $testdir/../../dli/durodt -e dbenv << {
        CURRENT_DB := 'D';
        begin transaction;

        operator test() updates {};
            var s string;
            try
                s := substr('x', 1, 1);
            catch err NAME_ERROR;
                put_line('caught NAME_ERROR');
            catch err;
                put_line('caught');
            end try;
        end operator;

        test();

        commit;
    }
} -result {caught
}

test getenv {GETENV operator} -setup $SETUP -body {
    set ::env(TEST) DUROTEST

    exec $testdir/../../dli/durodt -e dbenv << {
        put_line(GETENV('TEST'));
    }
} -result {DUROTEST
}

test with {WITH expression} -body {
    exec $testdir/../../dli/durodt -e dbenv << {
        put(WITH (C := 100): WITH (A := 7, B := C): A+B); put_line('');
        
        -- empty WITH
        put(WITH (): 7); put_line('');
    }
} -result {107
7
}

cleanupTests
