#!/bin/sh
# Execute tclsh from the user's PATH \
exec tclsh "$0" ${1+"$@"}

# $Id$
#
# Test scalar definitions and operations
#

package require tcltest 2.2
eval ::tcltest::configure $argv
namespace import ::tcltest::*

set testdir [::tcltest::configure -testdir]

makeDirectory dbenv

set ::DBSETUP {
    removeDirectory dbenv
    makeDirectory dbenv
    cd $::tcltest::temporaryDirectory
    exec $testdir/../../dli/durodt << {
        CREATE_ENV('dbenv');
        CREATE_DB('D');
    }
}

test scalar_builtin {built-in scalar definitions and operators} -body {
    exec $testdir/../../dli/durodt $testdir/scalar.td
} -result {2
3
XX
FALSE
error caught
}

test deftype {user-defined types} -setup $DBSETUP -body {
    exec $testdir/../../dli/durodt << {
        CONNECT('dbenv');
        type T
            possrep { a INTEGER, b INTEGER };

        implement type T;

        CURRENT_DB := 'D';
        begin transaction;
        var V T;
        put(THE_a(V)); put_line('');
        put(THE_b(V)); put_line('');
        
        V := T(1, 2);
        put(THE_a(V)); put_line('');
        put(THE_b(V)); put_line('');

        THE_a(V) := 5;
        put(THE_a(V)); put_line('');

        commit;

        -- Dropping T must fail because V still exists
        try
            drop type T;
		catch ex IN_USE_ERROR;
		    put_line('caught IN_USE');
		end try;

        drop var V;
        drop type T;

        type STRING5 possrep {value STRING} constraint LENGTH(THE_value(STRING5)) <= 5;
        implement type STRING5;

        begin tx;

        var s STRING5;
        
        s := STRING5('OK');
        
        try
        	s := STRING5('Too long');
        catch err TYPE_CONSTRAINT_VIOLATION_ERROR;
            put_line('caught TYPE_CONSTRAINT_VIOLATION');
        end try;
        commit;
    }
} -result {0
0
1
2
5
caught IN_USE
caught TYPE_CONSTRAINT_VIOLATION
}

test defroop {read-only user-defined operators} -setup $DBSETUP -body {
    exec $testdir/../../dli/durodt -e dbenv << {
        operator testop() returns STRING;
            var a INTEGER;
            var b INTEGER init 1;
            var c INTEGER;

            if a <> 0 then
                return "error: a <> 0";
            end if;

            if a = 0 then
            begin;
                a := a + 1;
            end;
            else
                return "error: (a = 0) is false";
            end if;

            var i init 0;
            drop var c;
            var c init 1;
            while i < 3;
                var one init 1;
                i := i + one;
                c := c * 2;
            end while;

            var d init 1;
            for i:= 1 to 3;
                d := d * 2 + 1;
            end for;

            return "a = " || CAST_AS_STRING(a) || ", b = " || CAST_AS_STRING(b)
                     || ", c = " || CAST_AS_STRING(c) || ", d = " || CAST_AS_STRING(d);
        end operator;

        /*
         * Reverse STRING.
         */
        operator reverse(s STRING) returns STRING;
            var res STRING;	-- automatically initialized to ''
            var len init LENGTH(s);

            var i INTEGER init len - 1;
            while i >= 0;
                res := res || SUBSTRING(s, i, 1);
                i := i - 1;
            end while;
            return res;
        end operator;

        operator fib(n INTEGER) returns INTEGER;
            return if n < 2 then n else fib(n - 1) + fib(n - 2);
        end operator;

        operator sgn(n INTEGER) returns INTEGER;
            case
                when n < 0 then return -1;
                when n > 0 then return 1;
                else return 0;
            end case;
        end operator;

        CURRENT_DB := 'D';
        begin tx;

        put_line(testop());

        put_line(reverse("Madam, I'm Adam."));

        put(fib(6)); put_line('');

        put(sgn(5)); put_line('');
        put(sgn(0)); put_line('');

        commit;

        drop operator testop;
    }
} -result {a = 1, b = 1, c = 8, d = 15
.madA m'I ,madaM
8
1
0
}

test defupdop {user-defined update operators} -setup $DBSETUP -body {
    exec $testdir/../../dli/durodt -e dbenv << {
        CURRENT_DB := 'D';
        begin transaction;

        operator op(s STRING, i INTEGER) updates {s};
            i := i + 1;

            type LENGTH_T possrep { m FLOAT } constraint (m >= 0.0);

            drop type LENGTH_T;

            operator op1(s STRING) returns STRING;
                return s || 'y';
            end operator;

            operator op2(s STRING) updates { s };
                s := s || 'z';
            end operator;

            s := op1(s);
            op2(s);

            drop operator op1;
            drop operator op2;

            return;
        end operator;

        var a STRING init 'x';
        var b INTEGER init 1;
        op(a, b);
        put_line("a = " || a || ", b = " || CAST_AS_STRING(b));

        op(a, b);

        drop var a;

        commit;
    }
} -result {a = xyz, b = 1
}

test dbconstraint {db/table constraints} -setup $DBSETUP -body {
    exec $testdir/../../dli/durodt -e dbenv << {
        CURRENT_DB := 'D';
        begin transaction;

        operator create_constraint() updates {};
            constraint CR count(r) <= 1;
        end operator;

        operator drop_constraint() updates {};
            drop constraint CR;
        end operator;

        var r real relation {no INTEGER, name STRING}
                init relation {tuple {no 1, name 'one'}}
                key {no};

        create_constraint();

        try
            insert r tuple {no 2, name 'two'};
        catch err PREDICATE_VIOLATION_ERROR;
            put_line('caught predicate violation: ' || THE_MSG(err));
        end try;

        drop_constraint();

        commit;
    }
} -result {caught predicate violation: cr
}

test trycatch {TRY .. CATCH} -setup $DBSETUP -body {
    exec $testdir/../../dli/durodt -e dbenv << {
        CURRENT_DB := 'D';
        begin transaction;

        operator test() updates {};
            var s STRING;
            try
                s := SUBSTRING('x', 1, 1);
            catch err NAME_ERROR;
                put_line('caught NAME_ERROR');
            catch err;
                put_line('caught');
            end try;
        end operator;

        test();

        commit;
    }
} -result {caught
}

test getenv {GETENV operator} -setup $DBSETUP -body {
    set ::env(TEST) DUROTEST

    exec $testdir/../../dli/durodt -e dbenv << {
        put_line(GETENV('TEST'));
    }
} -result {DUROTEST
}

test with {WITH expression} -body {
    exec $testdir/../../dli/durodt -e dbenv << {
        put(WITH (C := 100): WITH (A := 7, B := C): A+B); put_line('');
        
        -- empty WITH
        put(WITH (): 7); put_line('');
    }
} -result {107
7
}

cleanupTests
