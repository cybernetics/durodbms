#!/bin/sh
# Execute tclsh from the user's PATH \
exec tclsh "$0" ${1+"$@"}

# $Id$
#
# Test scalar definitions and operations
#

package require tcltest 2.2
eval ::tcltest::configure $argv
namespace import ::tcltest::*

set testdir [::tcltest::configure -testdir]

makeDirectory dbenv

set ::SETUP {
    removeDirectory dbenv
    makeDirectory dbenv
    cd $::tcltest::temporaryDirectory
    exec $testdir/../../dli/durodt << {
        create_env('dbenv');
        create_db('D');
    }
}

set ::CLEANUP {
    removeDirectory dbenv
}

test scalar_builtin {built-in scalar definitions and operators} -body {
    exec $testdir/../../dli/durodt $testdir/scalar.td
} -result {2
3
AB%&/
XX
FALSE
Aj
 %
error caught
}

test scalar_builtin_types_pr {built-in scalar types with possreps} -body {
    exec $testdir/../../dli/durodt << {

        var inv_arg_err invalid_argument_error;
        io.put_line(the_msg(inv_arg_err));

        var nrt_err no_running_transaction_error;

        var type_mismatch_err type_mismatch_error;

        var not_found_err not_found_error;

        var op_not_found_err operator_not_found_error;

        var name_err name_error;

        var element_exists_err element_exists_error;

        var type_constraint_violation_err type_constraint_violation_error;

        var key_violation_err key_violation_error;

        var predicate_violation_err predicate_violation_error;

        var aggregate_undefined_err aggregate_undefined_error;

        var version_mismatch_err version_mismatch_error;

        var not_supported_err not_supported_error;

        var syntax_err syntax_error;

        var in_user_err in_use_error;

        var no_mem_err no_memory_error;

        var sys_err system_error;

        var lock_not_granted_err lock_not_granted_error;

        var deadlock_err deadlock_error;

        var res_not_found_err resource_not_found_error;

        var internal_err internal_error;

        var fatal_err fatal_error;

        var id identifier;
    }
} -result {
}

test casts {cast operators} -body {
    exec $testdir/../../dli/durodt << {
	    io.put(cast_as_integer('11')); io.put_line('');
	    io.put(cast_as_int('-7')); io.put_line('');
	    io.put(cast_as_integer(-3.0)); io.put_line('');
	    io.put(cast_as_int(5.1)); io.put_line('');
	
	    io.put(cast_as_float('1.1')); io.put_line('');
	    io.put(cast_as_rational('-5.3')); io.put_line('');
	    io.put(cast_as_rat('4.0')); io.put_line('');
	    io.put(cast_as_float(1)); io.put_line('');
	    io.put(cast_as_rational(2)); io.put_line('');
	    io.put(cast_as_rat(0)); io.put_line('');

	    io.put_line(cast_as_string(500));
	    io.put_line(cast_as_char(-13));
	    io.put_line(cast_as_string(-34.5551));
	    io.put_line(cast_as_char(0.0));
	    
	    io.put_line(cast_as_string(X'446f'));
    }
} -result {11
-7
-3
5
1.1
-5.3
4.0
1.0
2.0
0.0
500
-13
-34.5551
0.0
Do
}

test deftype {user-defined types} -setup $SETUP -cleanup $CLEANUP -body {
    exec $testdir/../../dli/durodt << {
        connect('dbenv');
        current_db := 'D';
        begin tx;
        type t
            possrep { a integer, b integer }
            init t(0, 0);
        commit;
    }
    exec $testdir/../../dli/durodt -e dbenv -d D << {
        begin tx;
        -- Test declaration w/ incomplete types
        try
            var vt t;
        catch err;
            io.put_line('error #1 caused by incomplete type caught');
        end try;

        implement type t;
        end implement;
        commit;

        -- Check selector access w/o tx
        var v init t(0, 0);
        
        io.put(the_a(v)); io.put_line('');
        io.put(the_b(v)); io.put_line('');

        v := t(1, 2);
        io.put(the_a(v)); io.put_line('');
        io.put(the_b(v)); io.put_line('');

        the_a(v) := 5;
        io.put(the_a(v)); io.put_line('');

        begin tx;
        var v2 t;
        commit;
        drop var v2;

        -- Check multiple assignment
        the_a(v) := 9; the_b(v) := -7;
        io.put(the_a(v)); io.put_line('');
        io.put(the_b(v)); io.put_line('');

        var i int;
        the_a(v) := 15; i := 4;
        io.put(the_a(v)); io.put_line('');
        io.put(the_b(v)); io.put_line('');
        io.put(i); io.put_line('');

        -- Conflicting assignment
        try
            the_a(v) := 24, the_a(v) := 42;
		catch ex syntax_error;
		    io.put_line('invalid assignment caught');
		end try;     

        -- Dropping t must fail because v still exists
        begin tx;
        try
            drop type t;
		catch ex in_use_error;
		    io.put_line('caught in_use_error');
		end try;

        drop var v;

        var r real rel { t t };
        
        insert r tup { t t(1, 1) };
 
        var a array tup same_heading_as(r);
        load a from r order();

        try
            load a from r order(t asc);
            io.put_line('usage of non-ordered type t in order clause succeeded');
        catch err invalid_argument_error;
            ;
        end try;

        var tp tup same_heading_as(r);

        try
            for tp in r order(t asc);
                ;
            end for;
            io.put_line('usage of non-ordered type t in order clause succeeded');
        catch err invalid_argument_error;
            ;
        end try;

        drop var r;

        try
            -- Must fail because a depends on the type
            drop type t;
            io.put_line('dropping type succeeded despite variable a depending on it');
        catch ex in_use_error;
            ;
        end try;
            
        drop var a;

        try
            -- Must fail because tp depends on the type
            drop type t;
            io.put_line('dropping type succeeded despite variable tp depending on it');
        catch ex in_use_error;
            ;
        end try;

        drop var tp;

        drop type t;

        try
            type string5 possrep {value string} constraint strlen(val) <= 5
                    init string5('');
		catch ex name_error;
		    io.put_line('caught name_error');
		end try;        

        type string5 possrep {value string} constraint strlen(value) <= 5
                init string5('');

        -- Test table declaration w/ incomplete type
        try
            var pr private rel {id int, s5 string5} key {id};
        catch err;
            io.put_line('error #2 caused by incomplete type caught');
        end try;

        implement type string5;
        end implement;

        var s string5;
        
        s := string5('OK');

        try
        	s := string5('Too long');
        catch err type_constraint_violation_error;
            io.put_line('type constraint violation caught');
        end try;
        commit;        
    }
} -result {error #1 caused by incomplete type caught
0
0
1
2
5
9
-7
15
-7
4
invalid assignment caught
caught in_use_error
caught name_error
error #2 caused by incomplete type caught
type constraint violation caught
}

test deftypemr {user-defined type with multiple possreps} -setup $SETUP -cleanup $CLEANUP -body {
    exec $testdir/../../dli/durodt << {
        connect('dbenv');
        current_db := 'D';
        begin tx;
		type fixed2
		    possrep fixed2r { r rational }
		    possrep fixed2i { i integer }
		    init fixed2i(0);

		implement type fixed2 as integer;
		
			operator fixed2r(r rational) returns fixed2;
				return cast_as_integer(r*100.0);
			end operator;
	
			operator fixed2i(i integer) returns fixed2;
				return i;
			end operator;
	
			operator get_r(f2 fixed2) returns rational;
				return cast_as_rational(f2) / 100.0;
			end operator;
	
			operator set_r(f2 fixed2, r rational) updates {f2};
				f2 := cast_as_integer(r*100.0);
			end operator;
	
			operator get_i(f2 fixed2) returns integer;
				return f2;
			end operator;
	
			operator set_i(f2 fixed2, i integer) updates {f2};
				f2 := i;
			end operator;

		end implement;
		commit;

        var f1 fixed2;
        var f2 init fixed2r(1.00);
        var f3 init fixed2i(100);
    }
    exec $testdir/../../dli/durodt -e dbenv -d D << {
        var f1 fixed2;
        var f2 init fixed2r(1.23);
        var f3 init fixed2i(321);

        io.put(the_i(f1)); io.put_line('');
        io.put(the_r(f1)); io.put_line('');
        io.put(the_i(f2)); io.put_line('');
        io.put(the_r(f2)); io.put_line('');
        io.put(the_i(f3)); io.put_line('');
        io.put(the_r(f3)); io.put_line('');

        the_i(f1) := 20;
        io.put(the_i(f1)); io.put_line('');
        io.put(the_r(f1)); io.put_line('');

        var p private relation {id int, amount fixed2} key {id};
        
        insert p rel { tuple { id 1, amount fixed2r(3.5) },
                       tuple { id 2, amount fixed2i(1420) } };

        var tp tuple same_heading_as(p);

        for tp in p order(id asc);
             io.put(the_i(tp.amount)); io.put_line('');
             io.put(the_r(tp.amount)); io.put_line('');
        end for;

        var p2 private relation {id int, amount fixed2}
                init rel { tuple { id 1, amount fixed2r(500.11) },
                       tuple { id 2, amount fixed2i(20012) } };

        for tp in p2 order(id asc);
             io.put(the_i(tp.amount)); io.put_line('');
             io.put(the_r(tp.amount)); io.put_line('');
        end for;
    }
} -result {0
0.0
123
1.23
321
3.21
20
0.2
350
3.5
1420
14.2
50011
500.11
20012
200.12
}

test deftypemri {user-defined type with multiple possreps and incomplete implementation} -setup $SETUP -cleanup $CLEANUP -body {
    exec $testdir/../../dli/durodt << {
        connect('dbenv');
        current_db := 'D';
        begin tx;
		type fixed2
		    possrep fixed2r { r rational }
		    possrep fixed2i { i integer }
		    init fixed2i(0);

        try
			implement type fixed2 as integer;
			
				operator fixed2r(r rational) returns fixed2;
					return cast_as_integer(r*100.0);
				end operator;
		
				operator fixed2i(i integer) returns fixed2;
					return i;
				end operator;
		
				operator get_r(f2 fixed2) returns rational;
					return cast_as_rational(f2) / 100.0;
				end operator;
		
				operator set_r(f2 fixed2, r rational) updates {f2};
					f2 := cast_as_integer(r*100.0);
				end operator;
		
				operator get_i(f2 fixed2) returns integer;
					return f2;
				end operator;
	
			end implement;
        catch err operator_not_found_error;
            io.put_line('operator_not_found_error');
        end try;
        commit;

        try
            var f1 fixed2;
        catch err;
            io.put_line('declaration with unimplemented type caught');
        end try;
    }
} -result {operator_not_found_error
declaration with unimplemented type caught
}

test deftypecmp {user-defined type with comparison operator} -setup $SETUP -cleanup $CLEANUP -body {
    exec $testdir/../../dli/durodt << {
        connect('dbenv');
        current_db := 'D';
        var cmp_invoked init false;
        begin tx;

		type physical_length ordered possrep meters { m float } init meters(0.0);

		operator physical_length_cmp(l1 physical_length, l2 physical_length) returns int;
		    cmp_invoked := true;
		    case
		        when the_m(l1) < the_m(l2) then return -1;
		        when the_m(l2) > the_m(l2) then return 1;
		        else return 0;
		    end case;
		end operator;

		implement type physical_length;
		end implement;

		io.put(meters(0.0) < meters(1.0));
		io.put_line('');

		io.put(meters(1.0) < meters(1.0));
		io.put_line('');
		
		io.put(meters(0.0) <= meters(1.0));
		io.put_line('');

		io.put(meters(1.0) <= meters(1.0));
		io.put_line('');
		
		io.put(meters(0.0) > meters(1.0));
		io.put_line('');

		io.put(meters(1.0) > meters(1.0));
		io.put_line('');
		
		io.put(meters(0.0) >= meters(1.0));
		io.put_line('');

		io.put(meters(1.0) >= meters(1.0));
		io.put_line('');
		
		commit;

		begin tx;
		drop operator physical_length_cmp;
		drop type physical_length;
		commit;
		
		if not cmp_invoked then
		    io.put_line('compare operator not invoked');
		end if;

		begin tx;
		
		type pname ordered
		    possrep full_name { full_name string }
		    possrep given_family { given_name string, family_name string }
		init given_family('','');
		
		try
		
			implement type pname as tuple { gname string, fname string };
			
			  operator full_name(name string) returns pname;
			    var pos int init index_of(name, ' ');
			    var len int init strlen(name);
			    return tuple { gname substr(name, pos + 1, len - pos - 1), fname substr(name, 0, pos) };
			  end operator;
			
			  operator get_full_name(n pname) returns string;
			    return n.fname || ' ' || n.fname;
			  end operator;
			
			  operator set_full_name(pn pname, name string) updates {pn};
			    var pos int init index_of(name, ' ');
			    var len int init strlen(name);
			    update pn { gname := substr(name, pos + 1, len - pos - 1), fname := substr(name, 0, pos) };
			  end operator;
			
			  operator given_family(gname string, fname string) returns pname;
			    return tuple { gname gname, fname fname };
			  end operator;
			
			  operator get_given_name(pn pname) returns string;
			    return pn.gname;
			  end operator;
			
			  operator set_given_name(pn pname, gn string) updates { pn };
			    update pn { gname := gn };
			  end operator;
			
			  operator get_family_name(pn pname) returns string;
			    return pn.fname;
			  end operator;
			
			  operator set_family_name(pn pname, fn string) updates { pn };
			    update pn { fname := fn };
			  end operator;
			
			end implement;
	
		    io.put_line('implement type succeeded despite missing comparison op');

		catch err operator_not_found_error;
		    ;
		end try;

		operator pname_cmp(pn1 pname, pn2 pname) returns int;
		   case
		       when the_family_name(pn1) < the_family_name(pn2) then return -1;
		       when the_family_name(pn1) > the_family_name(pn2) then return 1;
		       else case
		           when the_given_name(pn1) < the_given_name(pn2) then return -1;
		           when the_given_name(pn1) > the_given_name(pn2) then return 1;
		           else return 0;
		       end case;
		   end case;
		end operator;           
		
		implement type pname as tuple { gname string, fname string };
		
		  operator full_name(name string) returns pname;
		    var pos int init index_of(name, ' ');
		    var len int init strlen(name);
		    return tuple { gname substr(name, pos + 1, len - pos - 1), fname substr(name, 0, pos) };
		  end operator;
		
		  operator get_full_name(n pname) returns string;
		    return n.gname || ' ' || n.fname;
		  end operator;
		
		  operator set_full_name(pn pname, name string) updates {pn};
		    var pos int init index_of(name, ' ');
		    var len int init strlen(name);
		    update pn { gname := substr(name, pos + 1, len - pos - 1), fname := substr(name, 0, pos) };
		  end operator;
		
		  operator given_family(gname string, fname string) returns pname;
		    return tuple { gname gname, fname fname };
		  end operator;
		
		  operator get_given_name(pn pname) returns string;
		    return pn.gname;
		  end operator;
		
		  operator set_given_name(pn pname, gn string) updates { pn };
		    update pn { gname := gn };
		  end operator;
		
		  operator get_family_name(pn pname) returns string;
		    return pn.fname;
		  end operator;
		
		  operator set_family_name(pn pname, fn string) updates { pn };
		    update pn { fname := fn };
		  end operator;

		end implement;

		var name pname;
		name := given_family('Ronnie', 'Relational');
		io.put_line(the_full_name(name));

		commit;
	}
} -result {TRUE
FALSE
TRUE
TRUE
FALSE
FALSE
FALSE
TRUE
Ronnie Relational
}

test defroop {read-only user-defined operators} -setup $SETUP -cleanup $CLEANUP -body {
    exec $testdir/../../dli/durodt -e dbenv -d D << {
        operator testop() returns string;
            var a integer;
            var b integer init 1;
            var c integer;

            if a <> 0 then
                return "error: a <> 0";
            end if;

            if a = 0 then
            begin;
                a := a + 1;
            end;
            else
                return "error: (a = 0) is false";
            end if;

            var i init 0;
            drop var c;
            var c init 1;
            while i < 3;
                var one init 1;
                i := i + one;
                c := c * 2;
            end while;

            var d init 1;
            for i:= 1 to 3;
                d := d * 2 + 1;
            end for;

            return "a = " || cast_as_string(a) || ", b = " || cast_as_string(b)
                     || ", c = " || cast_as_string(c) || ", d = " || cast_as_string(d);
        end operator;

        /*
         * Reverse string
         */
        operator reverse(s string) returns string;
            var res string;	-- automatically initialized to ''

            var i integer init strlen(s) - 1;
            while i >= 0;
                res := res || substr(s, i, 1);
                i := i - 1;
            end while;
            return res;
        end operator;

        operator fib(n integer) returns integer;
            return if n < 2 then n else fib(n - 1) + fib(n - 2);
        end operator;

        operator sgn(n integer) returns integer;
            case
                when n < 0 then return -1;
                when n > 0 then return 1;
                else return 0;
            end case;
        end operator;

        current_db := 'D';
        begin tx;

        io.put_line(testop());

        io.put_line(reverse("Madam, I'm Adam."));

        commit;

        -- Test without tx

        io.put(fib(6)); io.put_line('');

        io.put(sgn(5)); io.put_line('');
        io.put(sgn(0)); io.put_line('');

        drop operator testop;

        operator test4params(a int, b string, c int, d boolean) returns string;
            return cast_as_string(a) || b || cast_as_string(c)
                    || (if d then 'y' else 'n');
        end operator;
        
        io.put_line(test4params(1, 'x', 5, true));
    }
} -result {a = 1, b = 1, c = 8, d = 15
.madA m'I ,madaM
8
1
0
1x5y
}

test defupdop {user-defined update operators} -setup $SETUP -cleanup $CLEANUP -body {
    exec $testdir/../../dli/durodt -e dbenv << {
        current_db := 'D';
        begin transaction;

        operator op(s string, i integer) updates {s};
            type length_t possrep { m FLOAT } constraint (m >= 0.0)
                    init length_t(0.0);

            operator op1(s string) returns string;
                return s || 'y';
            end operator;

            operator op2(s string) updates { s };
                s := s || 'z';
            end operator;

            s := op1(cast_as_string(i));
            op2(s);

            return;
        end operator;

        var a string init 'x';
        var b integer init 1;
        op(a, b);
        io.put_line("a = " || a);

        drop operator op1;
        drop operator op2;

        drop type length_t;

        op(a, b);

        drop operator op1;
        drop operator op2;

        drop type length_t;

        drop var a;

        try
            operator op2(i int, j int) updates { k };
            ;
            end operator;
        catch err invalid_argument_error;
            io.put_line('invalid updates caught');
        end try;

        operator test5paramsu(a int, b string, c int, d boolean, e string)
                updates { e };
            e := cast_as_string(a) || b || cast_as_string(c)
                    || (if d then 'y' else 'n');
        end operator;

        var e string;
        test5paramsu(1, 'x', 5, true, e);
        io.put_line(e);

        commit;
    }
} -result {a = 1yz
invalid updates caught
1x5y
}

test typeinf {type inference} -setup $SETUP -cleanup $CLEANUP -body {
    exec $testdir/../../dli/durodt -e dbenv << {
        current_db := 'D';
        operator zero() returns int;
            return 0;
        end operator;
    }
    exec $testdir/../../dli/durodt -e dbenv << {
        current_db := 'D';
        var i same_type_as(zero());
        var j init zero();
        io.put(i); io.put(' '); io.put(j); io.put_line('');
    }
} -result {0 0
}

test trycatch {TRY .. CATCH} -setup $SETUP -cleanup $CLEANUP -body {
    exec $testdir/../../dli/durodt -e dbenv << {
        current_db := 'D';
        begin transaction;

        operator test() updates {};
            var s string;
            try
                s := substr('x', 1, 1);
            catch err NAME_ERROR;
                io.put_line('caught NAME_ERROR');
            catch err;
                io.put_line('caught');
            end try;
        end operator;

        test();

        commit;
    }
} -result {caught
}

test getenv {GETENV operator} -setup $SETUP -cleanup $CLEANUP -body {
    set ::env(TEST) DUROTEST

    exec $testdir/../../dli/durodt -e dbenv << {
        io.put_line(os.getenv('TEST'));
    }
} -result {DUROTEST
}

test with {WITH expression} -body {
    exec $testdir/../../dli/durodt << {
        io.put(WITH (C := 100): WITH (A := 7, B := C): A+B); io.put_line('');
        
        -- empty WITH
        io.put(WITH (): 7); io.put_line('');
    }
} -result {107
7
}

test like {LIKE operator} -body {
    exec $testdir/../../dli/durodt << {
        io.put_line(if 'abc' like '?bc' then 'true' else 'false');
        io.put_line(if 'aabc' like '?bc' then 'true' else 'false');
        io.put_line(if 'abc' like 'a*c' then 'true' else 'false');
        io.put_line(if 'ac' like 'a*c' then 'true' else 'false');
        io.put_line(if 'aca' like 'a*c' then 'true' else 'false');
        io.put_line(if '\x' like '\?' then 'true' else 'false');
        io.put_line(if 'a/b' like 'a?b' then 'true' else 'false');
        io.put_line(if 'ab/cd/eF' like 'a*F' then 'true' else 'false');
        io.put_line(if 'ab/cd/eF' like 'a\/*F' then 'true' else 'false');
    }
} -result {true
false
true
true
false
true
true
true
false
}

test www {Web operators} -body {
    exec $testdir/../../dli/durodt << {
	    var tp init tup {aa 'x', b 'x', n 1, f 2.0}; 

	    www.form_to_tuple(tp, 'aa=Y%2Bx+z&f=1.2&n=2'); 

	    io.put_line(tp.aa);
	    io.put_line(tp.b);
	    io.put(tp.n); io.put_line('');
        io.put(tp.f); io.put_line('');

        -- Check that invalid input does not crash the decoder 

	    www.form_to_tuple(tp, 'aa=%fg&b=%5');
	    www.form_to_tuple(tp, 'n=$&aa=%5');
	}
} -result {Y+x z
x
2
1.2
}

test parser {Parser} -match glob -body {
    catch {
        exec $testdir/../../dli/durodt << {
            -- Invalid character
            io.put ($);
        }
    } res
    puts $res
} -output {*syntax_error*}

cleanupTests
