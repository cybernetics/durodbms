#!/bin/sh
# Execute tclsh from the user's PATH \
exec tclsh "$0" ${1+"$@"}

# $Id$
#
# Test tuple definitions and operations
#

package require tcltest 2.2
eval ::tcltest::configure $argv
namespace import ::tcltest::*

set testdir [::tcltest::configure -testdir]

set ::DBSETUP {
    removeDirectory dbenv
    makeDirectory dbenv
    cd $::tcltest::temporaryDirectory
    exec $testdir/../../dli/durodt << {
        CREATE_ENV('dbenv');
        CREATE_DB('D');
    }
}

test arraysel {array selectors} -body {
    exec $testdir/../../dli/durodt << {
	    -- without type 
	    var a1 init array(2, 4);
	    PRINTLN(LENGTH(a1));
	    PRINTLN(a1[0]);
	    PRINTLN(a1[1]);

	    -- with type
	    var a2 init array STRING ('relational');
	    PRINTLN(LENGTH(a2));
	    PRINTLN(a2[0]);

	    -- with type and without arguments
	    a1 := array INTEGER();
	    PRINTLN(LENGTH(a1));
	    
	    -- array of tuple without type
	    var at1 init array(tup{i 200});
	    PRINTLN(LENGTH(at1));
	    PRINTLN(at1[0].i);

	    -- array of tuple with type
	    var at2 init array tup{s STRING} (tup{s 'A'}, tup{s 'Ilsebill'});
	    PRINTLN(LENGTH(at2));
	    PRINTLN(at2[0].s);
	    PRINTLN(at2[1].s);
	    
	    -- type mismatch
	    try
	        var ae init array INTEGER ('S');
	    catch type_mismatch_error;
	        PRINTLN('type mismatch 1');
	    end try;
	    try
	        var ae init array tup{i INTEGER} (tup{i 1}, tup{i 1, j 2});
	    catch type_mismatch_error;
	        PRINTLN('type mismatch 2');
	    end try;
	}
} -result {2
2
4
1
relational
0
1
200
2
A
Ilsebill
type mismatch 1
type mismatch 2
}    

test ptarray {array from private table} -body {
    exec $testdir/../../dli/durodt << {
        var r private init relation { tuple {i 1, c 'foo'}, tuple {i 2, c 'foo'},
        		tuple {i 3, c 'bar'} } key {i};
        var a array tuple same_heading_as(r);

        load a from r where c = 'foo' order();
        PRINTLN(a[0].c);

        load a from r order(c asc, i desc);
        PRINTLN(a[0].i);
        PRINTLN(a[1].i);
        PRINTLN(a[2].i);

        load a from r order(c desc, i asc);

        drop var r;

        PRINTLN(a[0].i);
        PRINTLN(a[1].i);
        PRINTLN(a[2].i);

        PRINTLN(LENGTH(a));
        
        var i same_type_as(LENGTH(a));
        
        drop var a;
    }
} -result {foo
3
2
1
1
2
3
3
}

test ops {operators with array arguments} -setup $DBSETUP -body {
    exec $testdir/../../dli/durodt << {
        CONNECT('dbenv');
        CURRENT_DB := 'D';

        begin transaction;

        operator first(a array tuple{i INTEGER}) returns tuple{i INTEGER};
	        return a[0];
        end operator;

        operator acopy(dst array tuple{i INTEGER}, src array tuple{i INTEGER}) updates {dst};
	        dst := src;
        end operator;

        var r private init relation { tuple {i 1}, tuple {i 2},
        		tuple {i 3} } key {i};
        var a array tuple {i INTEGER};

        load a from r order (i asc);
        var t tuple {i INTEGER};
        t := first(a);

        PRINTLN(t.i);

        var b array tuple {i INTEGER};
        acopy(b, a);

        PRINTLN(b[2].i);

        drop var a;
        drop var b;

        commit;
    }
} -result {1
3
}

test retops {operator returning array} -setup $DBSETUP -body {
    exec $testdir/../../dli/durodt << {
        CONNECT('dbenv');
        CURRENT_DB := 'D';

        begin transaction;

        operator rest(a array INTEGER) returns array INTEGER;
            var result array INTEGER;
            LENGTH(result) := LENGTH(a) - 1;

            var i INTEGER;
            for i := 0 to LENGTH(result) - 1;
                result[i] := a[i + 1];
            end for;

            return result;
        end operator;

        var a array INTEGER init array(1, 3, 5);
        var b array INTEGER;
        b := rest(a);
        var i INTEGER;
        for i := 0 to LENGTH(b) - 1;
            PRINTLN(b[i]);
        end for;
        
        commit;
    }
} -result {3
5
}

test array_utype {type with array-valued component} -setup $DBSETUP -body {
    exec $testdir/../../dli/durodt << {
        CONNECT('dbenv');
        CURRENT_DB := 'D';

        begin transaction;
        
        type path possrep { components array STRING };
        
        commit;
    }
}

