#!/bin/sh
# Execute tclsh from the user's PATH \
exec tclsh "$0" ${1+"$@"}

# $Id$
#
# Test tuple definitions and operations
#

package require tcltest 2.2
eval ::tcltest::configure $argv
namespace import ::tcltest::*

set testdir [::tcltest::configure -testdir]

set ::DBSETUP {
    removeDirectory dbenv
    makeDirectory dbenv
    cd $::tcltest::temporaryDirectory
    exec $testdir/../../dli/durodt << {
        create_env('dbenv');
        create_db('D');
    }
}

test arraysel {array selectors} -body {
    exec $testdir/../../dli/durodt << {
	    -- without type 
	    var a1 init array(2, 4);
	    println(length(a1));
	    println(a1[0]);
	    println(a1[1]);

	    -- with type
	    var a2 init array string ('relational');
	    println(length(a2));
	    println(a2[0]);

	    -- with type and without arguments
	    a1 := array integer();
	    -- println(length(a1));
	    
	    -- array of tuple without type
	    var at1 init array(tup{i 200});
	    println(length(at1));
	    println(at1[0].i);

	    -- array of tuple with type
	    var at2 init array tup{s string} (tup{s 'A'}, tup{s 'Ilsebill'});
	    println(length(at2));
	    println(at2[0].s);
	    println(at2[1].s);
	    
	    -- type mismatch
	    try
	        var ae init array integer ('S');
	    catch type_mismatch_error;
	        println('type mismatch 1');
	    end try;
	    try
	        var ae init array tup{i integer} (tup{i 1}, tup{i 1, j 2});
	    catch type_mismatch_error;
	        println('type mismatch 2');
	    end try;
	}
} -result {2
2
4
1
relational
1
200
2
A
Ilsebill
type mismatch 1
type mismatch 2
}    

test ptarray {array from private table} -body {
    exec $testdir/../../dli/durodt << {
        var r private init relation { tuple {i 1, c 'foo'}, tuple {i 2, c 'foo'},
        		tuple {i 3, c 'bar'} } key {i};
        var a array tuple same_heading_as(r);

        load a from r where c = 'foo' order();
        println(a[0].c);

        load a from r order(c asc, i desc);
        println(a[0].i);
        println(a[1].i);
        println(a[2].i);

        load a from r order(c desc, i asc);

        drop var r;

        println(a[0].i);
        println(a[1].i);
        println(a[2].i);

        println(length(a));
        
        var i same_type_as(length(a));
        
        drop var a;
    }
} -result {foo
3
2
1
1
2
3
3
}

test ops {operators with array arguments} -setup $DBSETUP -body {
    exec $testdir/../../dli/durodt << {
        connect('dbenv');
        current_db := 'D';

        begin transaction;

        operator first(a array tuple{i integer}) returns tuple{i integer};
	        return a[0];
        end operator;

        operator acopy(dst array tuple{i integer}, src array tuple{i integer}) updates {dst};
	        dst := src;
        end operator;

        var r private init relation { tuple {i 1}, tuple {i 2},
        		tuple {i 3} } key {i};
        var a array tuple {i integer};

        load a from r order (i asc);
        var t tuple {i integer};
        t := first(a);

        println(t.i);

        var b array tuple {i integer};
        acopy(b, a);

        println(b[2].i);

        drop var a;
        drop var b;

        commit;
    }
} -result {1
3
}

test retops {operator returning array} -setup $DBSETUP -body {
    exec $testdir/../../dli/durodt << {
        connect('dbenv');
        current_db := 'D';

        begin transaction;

        operator rest(a array integer) returns array integer;
            var result array integer;
            length(result) := length(a) - 1;

            var i integer;
            for i := 0 to length(result) - 1;
                result[i] := a[i + 1];
            end for;

            return result;
        end operator;

        var a array integer init array(1, 3, 5);
        var b array integer;
        b := rest(a);
        var i integer;
        for i := 0 to length(b) - 1;
            println(b[i]);
        end for;
        
        commit;
    }
} -result {3
5
}

test array_utype {type with array-valued component} -setup $DBSETUP -body {
    exec $testdir/../../dli/durodt << {
        connect('dbenv');
        current_db := 'D';

        begin transaction;
        
        type path possrep { components array string };
        
        commit;
    }
}

