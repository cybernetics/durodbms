<html>
<title>Duro D/T Tutorial</title>
<link rel="stylesheet" href="../style.css">
<body>
<p><a href="../index.html">Documentation home</a>
<h1>Duro D/T Tutorial</h1>

<h2>Table of contents</h2>

<ul>
<li><a href="#invoke">Invoking the interpreter</a>
<li><a href="#declare">Declaring variables</a>
<li><a href="#assign">Assignment</a>
<li><a href="#types">Built-in types</a>
<li><a href="#comments">Comments</a>
<li><a href="#control">Control statements</a>
<li><a href="#tuples">Tuples</a>
<li><a href="#dbs">Databases and database environments</a>
<li><a href="#tables">Tables</a>
<li><a href="#dbconstraints">Database constraints</a>
<li><a href="#arrays">Arrays</a>
<li><a href="#foreach">FOREACH</a>
<li><a href="#io">I/O</a>
<li><a href="#user-ops">User-defined operators</a>
<li><a href="#user-types">User-defined types</a>
<li><a href="#exception">Exception handling</a>
<li><a href="#performance">Performance</a>
</ul>

<h2 id="invoke">Invoking the interpreter</h2>

<p>To invoke the interpreter, type <samp>durodt</samp>:

<pre>
durodt
Duro D/T library version 0.17
no db>
</pre>

<p>Duro D/T displays a prompt with the database currently
in use. Since no database is selected in the example shown above,
the prompt is "no db".

<p>To exit the interpreter, type the end-of-file character
(Control-Z on Windows, Control-D on POSIX systems) or type "exit();".
(Do not forget the parentheses and the semicolon)

<p>For more information about invoking Duro D/T see <a href="../utils.html#durodt">DuroDBMS utilities</a>.

<h2 id="declare">Declaring variables</h2>

<p>In Duro D/T, variables are typed, as required by TTM.
They must be declared before they can be used.

<p>Example:

<pre>
no db> var i integer;
no db>
</pre>

<p>This creates a variable named i. Note that Duro D/T is case
insensitive, so there is no diffence between "var i integer;"
and "VAR I INTEGER;". More precisely, keywords are case insensitive
whereas identifiers are automatically converted to lowercase.
This tutorial shows example code in lowercase.

<p>When declaring a variable, an initial value can be specified:

<pre>
no db> var j integer init 2;
no db>
</pre>

<p>If an initial value is provided, the type can be omitted.
So the above can also be written as follows:

<pre>
no db> var j init 2;
no db>
</pre>

<p>If an initial value is not specified, the variable is
automatically initialized to a default value, which is
zero for numeric types, the empty string for the type string
and FALSE for boolean.

<p>A variable can also be declared to have the same type
as some other variable. Example:

<pre>
no db> var k same_type_as(i);
no db>
</pre>

<p>Variables can be explicity destroyed. This is usually not necessary for transient variables,
but is supported for all user-declared variables:

<pre>
no db> drop var i;
no db>
</pre>

<h2 id="assign">Assignment</h2>

<p>Once a variable has been declared, a value can be assigned
to it. For example:

<pre>
no db> i := 5;
1 element affected.
no db>
</pre>

<p>Duro D/T supports <strong>multiple assignment</strong>,
i.e. more than one assignment in one statement.
A multiple assignment behaves as if the individual assignments
were executed in parallel.

<p>For example, to exchange the values of two variables,
one can write:

<pre>
no db> i := j, j := i;
2 elements affected.
no db>
</pre>

<h2 id="types">Built-in types</h2>

<p>DuroDBMS supports the following built-in scalar types:

<ul>
<li><code>boolean</code> (synonym <code>bool</code>)</li>
<li><code>integer</code> (synonym <code>int</code>)</li>
<li><code>float</code> (synonyms <code>rational</code>, <code>rat</code>)</li>
<li><code>string</code> (synonym <code>char</code>)</li>
<li><code>binary</code></li>
</ul>

<p>Examples:

<pre>
no db> var b bool init true;
no db> var i int init 1;
no db> var f float init 1.0;
no db> var s string init 'Foo';
no db> var b binary init X'466f6f';
</pre>

<p>For non-scalar types, see the chapters on tuples, tables, and arrays,
respectively.

<p>DuroDBMS supports the usual arithmetical operators. Example:

<pre>
no db> put_line(cast_as_string(2 + 3 * 4));
14
no db> 
</pre>

<p>For details on the built-in operator <code>put_line</code>, see the chapter on I/O below.

<h2 id="comments">Comments</h2>

<p>Duro D/T supports line comments and multi-line comments.

<pre>
-- This is a single-line comment.

/* This is a
multi-line
comment. */
</pre>

<p>Multi-line comments which actually span several lines are not supported in interactive mode.

<p>Lines starting with #! are ignored to allow for Unix interpreter files.</p>

<h2 id="control">Control statements</h2>

<h3>IF</h3>

<p>Example:

<pre>
no db> var s string;
no db> put_line('Please enter a number:'); get_line(s);
Please enter a number:
2
no db> var n init cast_as_integer(s);
no db> if n &lt; 0 then
no db>     put_line('Negative');
no db> else
no db>     put_line('Positive');
no db> end if;
Positive
no db>
</pre>

<p>In Duro D/T, BEGIN .. END is not required since there can be several statements after THEN.
But the following form, which more strictly adheres to <cite>TTM</cite>, is supported too:</P>

<pre>
no db> var s string;
no db> put_line('Please enter a number:'); get_line(s);
Please enter a number:
-2
no db> var n init cast_as_integer(s);
no db> if n &lt; 0 then
no db>     begin;
no db>         put_line('Negative');
no db>     end;
no db> else
no db>     begin;
no db>         put_line('Positive');
no db>     end;
no db> end if;
Negative
no db>
</pre>

<h3>FOR</h3>

<p>Example:</p>

<pre>
var i integer;
for i := 1 to 5;
    put(i);
    put_line('');
end for;
1
2
3
4
5
no db>
</pre>

<p>DO may be used instead of FOR.

<h3>WHILE</h3>

<p>Example:

<pre>
var s string;
var n integer;

get_line(s);
n := cast_as_integer(s);
while n < 0;
    put_line('This number is not positive. Please enter again:');
    get_line(s);
    n := cast_as_integer(s);
end while;
</pre>

<p>This code reads one line of input until you enter a positive number.
(Or a string which is not a number which will result in an <code>invalid_argument_error</code>)

<p>It is possible to exit a loop using the LEAVE statement. Example:

<pre>
no db> var s string;
no db> while true;
no db> put('type "exit" to exit: ');
no db> get_line(s);
no db> if s = 'exit' then
no db> leave;
no db> end if;
no db> end while;
type "exit" to exit: x
type "exit" to exit: exit
no db> 
</pre>

<p>LEAVE with a statement name is also supported.
See <cite>TTM</cite>, chapter 5 for details.

<h3>CASE</h3>

<p>Example:

<pre>
no db> var s string;
no db> var n integer;
no db> put_line('Please enter a number:'); get_line(s);
Please enter a number:
0
no db> n := cast_as_integer(s);
no db> case
no db>     when n > 0 then
no db>         put_line('Positive');
no db>     when n < 0 then
no db>         put_line('Negative');
no db>     else
no db>         put_line('Zero');
no db> end case;
Zero
no db>
</pre>

<h2 id="tuples">Tuples</h2>

<p>Tuple variables can be declared as follows:</p>

<pre>
no db> var t tuple {i integer, s string};
no db>
</pre>

<p>TUP can be used as a synonym for TUPLE.
Like scalar variables, tuple variables can be explicitly initialized
when they are declared:</p>

<pre>
no db> var t tup {i integer, s string} init tup {i 1, s 'One'};
no db>
</pre>

Or shorter:

<pre>
no db> var t init tup {i 1, s 'One'};
no db>
</pre>

Note that as required by TTM proscription 1 there is no attribute
ordering in Duro D/T, so the statement above is perfectly equivalent
to the following:

<pre>
no db> var t init tup {s 'One', i 1};
no db>
</pre>

<p>Tuples variables can be assigned and updated:</p>

<pre>
no db> t := tup {i 2, s 'Two'};
1 element affected.
no db> update t {i := 3};
1 element affected.
no db> update t {i := 4, s := 'Four'};
1 element affected.
</pre>

<p>Accessing tuple attributes:

<pre>
no db> put_line(t.s);
Four
no db>
</pre>

<p>Alternative form:

<pre>
no db> put_line(s from t);
Four
no db>
</pre>

<h2 id="dbs">Databases and database environments</h2>

<p>Database environments are the places where databases and tables are physically stored.
Therefore a database environment must exist before a database can be created.
In Duro D/T, a database environment can be created using the built-in
update operator create_env():</p>

<pre>
no db> create_env('dbenv');
no db>
</pre>

<p>The built-in update operator connect() can be used to connect
to an existing database environment. connect() takes one argument
of type <code>string</code> which specifies the database environment:</p>

<pre>
no db> connect('dbenv');
no db>
</pre>

<p>After a database environment was created or connected to, a
database can be created using the built-in
update operator create_db().</p>

<pre>
no db> create_db('D');
no db>
</pre>

<p>The variable <code>current_db</code> contains the database currently in use.
A database can be selected by assigning the variable:</p>

<pre>
no db> current_db := 'D';
1 element affected.
D>
</pre>

<p>After <code>current_db</code> has been set, the prompt shows the name
of the database selected and a transaction can be started
using BEGIN TRANSACTION. Instead of BEGIN TRANSACTION, BEGIN TX
can be used:</p>

<pre>
D> begin tx;
Transaction started.
D>
</pre>

<p>Transaction commit:

<pre>
D> commit;
Transaction committed.
D>
</pre>

<p>Transaction rollback:

<pre>
D> begin tx;
Transaction started.
D> rollback;
Transaction rolled back.
D>
</pre>

<h2 id="tables">Tables</h2>

<p>As required by <em>TTM</em>, tables are variables in DuroDBMS,
thus a table is created by declarating a variable. 

<p>A table is persistent if and only if it belongs to a database.
A running transaction is required to create or access database tables.

<p>Creating a real database table:

<pre>
D> begin tx;
Transaction started.
D> var r real rel{no int, name string} key {no};
Table r created.
D>
</pre>

<p>REL can be used as a synonym for RELATION.

<p>It is possible to specify default values when creating a table. Example:

<pre>
D> var r2 real rel{no int, name string} key {no} default {name 'unknown'};
Table r2 created.
D> insert r2 tup{no 1};
1 element affected.
</pre>

<p>Private tables are transient, they do not belong to any database
and do not require a transaction to create or access them.

<p>Creating a private table:

<pre>
D> var p private rel{no int, name string} key {no};
Local table p created.
D>
</pre>

<p>Creating a virtual table:

<pre>
D> var v virtual r {no};
Table v created.
D>
</pre>

<p>This creates a projection over attribute <code>no</code>.

<p>Inserting a single tuple:</p>

<pre>
D> insert r tup {no 1, name 'one'};
1 element affected.
D>
</pre>

<p>Inserting several tuples:</p>

<pre>
D> insert r rel {tup {no 2, name 'two'}, tup {no 3, name 'three'}};
2 elements affected.
D>
</pre>

<p>Updating a table:</p>

<pre>
D> update r where no = 3 { no := 4, name := 'four' };
1 element affected.
D>
</pre>

<p>Deleting tuples from a table:</p>

<pre>
D> delete r where no = 4;
1 element affected.
D>
</pre>

<p>Tables can be destroyed just as other variables using DROP VAR:

<pre>
D> drop var v;
Table v dropped.
D> drop var r;
Table r dropped.
D> commit;
Transaction committed.
D> 
</pre>

<h2 id="dbconstraints">Database constraints</h2>

<p>Imagine there is one table for customers and one for orders:</p>

<pre>
D> begin tx;
Transaction started.
D> var customers real rel{customer_id int, name string} key {customer_id};
Table customers created.
D> var orders real rel{order_id int, customer_id int} key {order_id};
Table orders created.
D> 
</pre>

<p>If we only want to allow orders with a corresponding customer, this can
be achieved using a database constraint as follows:

<pre>
D> constraint orders_customers orders {customer_id} subset_of customers {customer_id};
Constraint orders_customers created.
D> commit;
Transaction committed.
D> 
</pre>

<p>If we now want to insert an order, DuroDBMS will check if there
is a corresponding entry in the customer table: 

<pre>
D> begin tx;
Transaction started.
D> insert orders tup{order_id 1, customer_id 1};
predicate_violation_error: orders_customers
D> insert customers tup{customer_id 1, name 'John Smith'};
1 element affected.
D> insert orders tup{order_id 1, customer_id 1};
1 element affected.
D> 
</pre>

<p>DuroDBMS performs constraint checking before a statement is executed.
To achieve this, DuroDBMS generates an expression which will return TRUE
if the statement will not violate the expression and FALSE if it will.
Duro tries to optimize this expression before evaluating.

<p>An EXPLAIN statement can be used to obtain the expression which is evaluated
in order to check a constraint. Example:

<pre>
D> explain insert orders tup{order_id 1, customer_id 1};
check orders_customers: is_empty((RELATION {} union ((RELATION {TUPLE {customer_id 1, order_id 1}}
{ customer_id }) minus (customers INDEX customers$0 { customer_id }))) {  })
D> 
</pre>

<p>The expression is a little complicated, but one can see that the reference to table <var>orders</var>
has been eliminated. The expression simply checks if the customer_id of the tuple to be inserted
already appears in <var>customers</var>.

<p>A constraint can be deleted using DROP CONSTRAINT:

<pre>
D> drop constraint orders_customers;
Constraint orders_customers dropped.
D>
</pre>

<h2 id="arrays">Arrays</h2>

<p>Example: Printing all tuples of table r in an unspecified order:

<pre>
D> var a array tup same_heading_as(r);
D> load a from r order();
D> var i integer;
D> for i:= 0 to length(a)-1;
D>   put(a[i]); put_line('');
D> end for;
</pre>

<h2 id="foreach">FOREACH</h2>

<p>Duro D/T supports a FOREACH statement.
The example below prints all tuples of table r in an unspecified order
using FOREACH instead of using LOAD: 

<pre>
D> var t tup same_heading_as(r);
D> foreach t in r order();
D>   put(t); put_line('');
D> end foreach;
</pre>

<h2 id="io">I/O</h2>

<p>Duro D/T provides a number of operators for I/O.

<h3>put_line</h3>

<p><code>put_line</code> takes one argument of type <code>string</code>
and prints it on standard output, followed by a newline.

<pre>
no db> put_line('hello');
hello
no db>
</pre>

<p>Note that in Duro D/T, the keyword CALL in update operator invocations
is optional. The following is also valid:

<pre>
no db> call put_line('hello');
hello
no db>
</pre>

<h3>put</h3>

<p><code>put</code> works like <code>put_line</code>, except that its output is not
followed by a newline. Unlike <code>put_line</code>, it is defined
for all built-in scalar types and also for tuple and relation arguments:

<pre>
no db> put('2 + 2 = '); put(2 + 2); put_line('');
2 + 2 = 4
no db> put(true); put_line('');
TRUE
no db> put(tup {a 1, b 'bee'}); put_line('');
TUPLE { a 1, b 'bee' }
no db> put(rel {tup {I 1, C 'foo'}, tup {I 2, C 'bar'}}); put_line('');
RELATION { TUPLE { i 1, c 'foo' }, TUPLE { i 2, c 'bar' }}
no db>
</pre>

<h3>get_line</h3>

<p><code>get_line</code> is defined as follows:</p>

<p>OPERATOR get_line(line string) UPDATES {line};</p>

<p><code>get_line</code> reads one line from standard input and stores
it in <code>line</code>, without the trailing newline.</p>

<p>File I/O is also supported. See the <a href="../api/html/io-ops.html">list of I/O operators</a>.

<h2 id="user-ops">User-defined operators</h2>

<p>Defining a read-only operator:

<pre>
D> operator incr(i integer) returns integer;
D> return i + 1;
D> end operator;
Read-only operator incr created.
D>
</pre>

<p>Defining an update operator:

<pre>
D> operator inc(i integer) updates {i};
D> i := i + 1;
D> end operator;
Operator inc created.
D>
</pre>

<p>Dropping an operator:

<pre>
D> drop operator incr;
Operator incr dropped.
D>
</pre>

<h2 id="user-types">User-defined types</h2>

<p>Example for defining a type:</p>

<pre>
D> type len possrep {n float} constraint n >= 0.0 init len(0.0);
Type len defined.
</pre>

<p>Before the type can be used, it must first be implemented.
This can be done using IMPLEMENT TYPE:</p>

<pre>
D> implement type len; end implement;
Type len implemented.
</pre>

<p>This works only for types with exactly one possible representation.
If a user-defined type has more than one possible representation,
an actual representation must be specified together with
selector, getter, and setter operators which provide
the mapping between the possible representations and the actual representation.
These operators are accessing the actual representation.

<p>The example code below shows how the type POINT from <em>TTM</em>, chapter 3,
can be implemented using Duro D/T.

<pre>
type point
    possrep cartesian { x float, y float }
    possrep polar { r float, theta float }
    init cartesian(0.0, 0.0);

implement type point as tuple { x float, y float };

    operator cartesian(x float, y float) returns point;
        return tuple { x x, y y };
    end operator;

    operator get_x(p point) returns float;
        return p.x;
    end operator;

    operator get_y(p point) returns float;
        return p.y;
    end operator;

    operator set_x(p point, x_ float) updates { p };
        update p { x := x_ };
    end operator;

    operator set_y(p point, y_ float) updates { p };
        update p { y := y_ };
    end operator;

    operator polar(r float, theta float) returns point;
        return tuple { x r * cos(theta), y r * sin(theta) };
    end operator;

    operator get_r(p point) returns float;
        return sqrt(p.x * p.x + p.y * p.y);
    end operator;

    operator set_r(p point, r float) updates {p};
        var theta init atan2(p.y, p.x);

        update p { x := cos(theta) * r, y := sin(theta) * r };
    end operator;

    operator set_theta(p point, theta float) updates {r};
        var r init sqrt(p.x * p.x + p.y * p.y);

        update p { x := cos(theta) * r, y := sin(theta) * r };
    end operator;

    operator get_theta(p point) returns float;
        return atan2(p.y, p.x);
    end operator;

end implement;
</pre>

<p>After a type has been defined and implemented,
it can be used to declare and assign variables, like so:

<pre>
D> var l len;
D> l := len(1.0);
1 element affected.
D>
</pre>

<pre>
D> var p point;
D> p := cartesian(1.0, 1.0);
1 element affected.
D>
</pre>

<h2 id="exception">Exception handling</h2>

<p>By default, if an error occurs, execution is stopped.

<p>In Duro D/T, it is possible to handle errors and to continue execution.
It is also possible to generate errors from user code.

<h3>RAISE</h3>

<p>The RAISE statement generates an error. It can take any argument and will use it as an error
value:

<pre>
D> raise 2;
integer
D>
</pre>

<p>If an error is not handled, execution is stopped and the error type
is printed to standard output. This is why we see "integer" appear.

<p>Raising a system-provided error:

<pre>
D> raise name_error('test');
name_error: test
D>
</pre>

<p>If the error type has a <var>msg</var> property, its value is printed together with the type.
See the <a href="../api/html/builtin-types.html">built-in types</a>
for a list of system-provided error types.

<h3>TRY .. CATCH</h3>

<p>TRY .. CATCH can be used to catch errors that may be raised during execution.
A TRY block must contain one or more CATCH statements.

<p>The following code illustrates catching errors using TRY .. CATCH:

<pre>
try

/* Perform operations that could throw errors */

...

catch err invalid_argument_error;

  /* Handle invalid_argument_error */

...

catch err;

  /* Handle remaining errors */

...

end try;
</pre>

<h2 id="performance">Performance</h2>

<p>Duro D/T features an EXPLAIN statement which displays how a relational expression is executed.

<p>Example:

<pre>
D> begin tx;
Transaction started.
D> var r real relation{n int, s string} key {n};
Table r created.
D> var i int;
D> for i := 1 to 10; insert r tup{n i, s cast_as_string(i)}; end for;
1 element affected.
1 element affected.
1 element affected.
1 element affected.
1 element affected.
1 element affected.
1 element affected.
1 element affected.
1 element affected.
1 element affected.
D> explain r where n=1 order();
(r INDEX r$0) where (n = 1)
D> commit;
Transaction committed.
</pre>

<p>(This EXPLAIN statement is not to be confused with the EXPLAIN which displays the constraint checking performed for a statement)

<p>The output of EXPLAIN shows that Duro D/T uses the index r$0 to evaluate the expression.
This is the index which was created to ensure that n is a key attribute of r.

Now let's try other WHERE expressions:

<pre>
D> begin tx;
Transaction started.
D> explain r where n>1 order();
(r) where (n > 1)
D> explain r where s='one' order();
(r) where (s = 'one')
</pre>

<p>For neither of these an index can be used. Not for the first,
because the system-generated index on <var>n</var> is a hash index which supports only equality,
and not for the second because there is no index on attribute <var>s</var>.
This means that DuroDBMS will scan the entire table to evaluate the expression
which is quite inefficient for large tables.

<p>We can create an index on s using the INDEX statement:  

<pre>
D> index r_s r (s);
Index r_s created.
</pre>

Now we can use the index:

<pre>
D> explain r where s='one' order();
(r INDEX r_s) where (s = 'one')
</pre>

As we can see in the output of the EXPLAIN statement,
DuroDBMS now uses the index r_s to evaluate the expression.

An index can be destroyed using DROP INDEX:

<pre>
D> drop index r_s;
Index r_s dropped.
</pre>

<p>INDEX is supported for physically stored tables.
Currently real tables are physically stored and virtual tables are not,
but this may change in future versions of DuroDBMS.

<p>Note that INDEX and DROP INDEX are low-level operators;
access to them may be restricted in future versions of DuroDBMS.

</html>
