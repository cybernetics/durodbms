<html>
<title>Duro D/T Tutorial</title>
<link rel="stylesheet" href="../style.css">
<body>
<p><a href="../index.html">Documentation home</a>
<h1>A Brief Duro D/T Tutorial</h1>

<h2>Invoking the interpreter</h2>

<p>To invoke the interpreter, type:

<pre>
durodt
no db>
</pre>

<p>Duro D/T displays a prompt with the database currently
in use. Since no database is selected in the example shown above,
the prompt is "no db".

<p>To exit the interpreter, type an end-of-file character
(Control-D on Unix, Control-Z on Windows) or type "exit();".
(Do not forget the parentheses and the semicolon)

<p>For more information about invoking Duro D/T see <a href="../utils.html#durodt">Duro utilities</a>.

<h2>Declaring variables</h2>

<p>In Duro D/T, variables are typed, as required by TTM.
They must be declared before they can be used.

<p>Example:

<pre>
no db> var i integer;
no db>
</pre>

<p>This creates a variable named I. Note that Duro D/T is case
insensitive, so there is no diffence between "var i integer;"
and "VAR I INTEGER;". This tutorial shows example code in lowercase.

<p>When declaring a variable, an initial value can be specified:

<pre>
no db> var j integer init 2;
no db>
</pre>

<p>If an initial value is provided, the type can be omitted.
So the above can also be written as follows:

<pre>
no db> var j init 2;
no db>
</pre>

<p>If an initial value is not specified, the variable is
automatically initialized to a default value, which is
zero for numeric types, the empty string for STRING
and FALSE for BOOLEAN.

<p>A variable can also be declared to have the same type
as some other variable. Example:

<pre>
no db> var k same_type_as(i);
no db>
</pre>

<p>Variables can be explicity destroyed. This is usally not necessary for transient variables,
but is supported for all user-declared variables:

<pre>
no db> drop var i;
no db>
</pre>

<h2>Assignment</h2>

<p>Once a variable has been declared, a value can be assigned
to it. For example:

<pre>
no db> i := 5;
1 element affected.
no db>
</pre>

<p>Duro D/T supports <strong>multiple assignment</strong>,
i.e. more than one assignment in one statement.
A multiple assignment behaves as if the individual assignments
were executed in parallel.

<p>For example, to exchange the values of two variables,
one can write:

<pre>
no db> i := j, j := i;
2 elements affected.
no db>
</pre>

<h2>Types</h2>

<p>Duro supports the following built-in scalar types:

<ul>
<li><code>boolean</code> (synonym <code>bool</code>)</li>
<li><code>integer</code> (synonym <code>int</code>)</li>
<li><code>float</code> (synonyms <code>rational</code>, <code>rat</code>)</li>
<li><code>string</code> (synonym <code>char</code>)</li>
<li><code>binary</code></li>
</ul>

<p>Examples:

<pre>
no db> var b bool init true;
no db> var i int init 1;
no db> var f float init 1.0;
no db> var s string init 'Foo';
</pre>

<p>For non-scalar types, see the chapters on tuples, tables, and arrays,
respectively.

<p>Duro supports the usual arithmetical operators. Example:

<pre>
no db> put_line(cast_as_string(2 + 3 * 4));
14
no db> 
</pre>

<p>For details on the built-in operator <code>put_line</code>, see the chapter on I/O.

<h2>Comments</h2>

<p>Duro D/T supports line comments and multi-line comments.

<pre>
-- This is a single-line comment.

/* This is a
multi-line
comment. */
</pre>

<p>Lines starting with #! are ignored to allow for Unix interpreter files.</p>

<h2>Control statements</h2>

<h3>IF</h3>

<pre>
no db> var s string;
no db> put_line('Please enter a number:'); get_line(s);
Please enter a number:
2
no db> var n init CAST_AS_INTEGER(s);
no db> if n < 0 then
no db>     put_line('Negative');
no db> else
no db>     put_line('Positive');
no db> end if;
Positive
no db>
</pre>

<p>In Duro D/T, BEGIN .. END is not required since there can be several statements after THEN.
But the following form, which more strictly adheres to TTM, is supported too:</P>

<pre>
no db> var s string;
no db> put_line('Please enter a number:'); READLN(s);
Please enter a number:
-2
no db> var n init CAST_AS_INTEGER(s);
no db> if n < 0 then
no db>     begin;
no db>         put_line('Negative');
no db>     end;
no db> else
no db>     begin;
no db>         put_line('Positive');
no db>     end;
no db> end if;
Negative
no db>
</pre>

<h3>FOR</h3>

<p>Example:</p>

<pre>
var i INTEGER;
for i := 1 to 10;
    put(i);
    put_line('');
end for;
</pre>

<p>DO may be used instead of FOR.

<h3>WHILE</h3>

<p>Example:

<pre>
put_line('Please enter a positive number:');
var s string;
READLN(s);
var n init CAST_AS_INTEGER(s);
while n < 0;
    put_line('This number is not positive. Please enter again:');
    READLN(s);
    n := CAST_AS_INTEGER(s);
end while;
</pre>

<h3>CASE</h3>

<p>Example:

<pre>
no db> var s string;
no db> put_line('Please enter a number:'); READLN(s);
Please enter a number:
0
no db> var n init CAST_AS_INTEGER(s);
no db> case
no db>     when n > 0 then
no db>         put_line('Positive');
no db>     when n < 0 then
no db>         put_line('Negative');
no db>     else
no db>         put_line('Zero');
no db> end case;
Zero
no db>
</pre>

<h2>Tuples</h2>

<p>Tuple variables can be declared as follows:</p>

<pre>
no db>var t tuple {i integer, s string};
no db>
</pre>

<p>TUP can be used as a synonym for TUPLE.
Like scalar variables, tuple variables can be explicitly initialized
when they are declared:</p>

<pre>
no db>var t tup {i integer, s string} init tup {i 1, s 'One'};
no db>
</pre>

Or shorter:

<pre>
no db>var t init tup {i 1, s 'One'};
no db>
</pre>

Note that as required by TTM proscription 1 there is no attribute
ordering in Duro D/T, so the statement above is perfectly equivalent
to the following:

<pre>
no db>var t init tup {s 'One', i 1};
no db>
</pre>

<p>Tuples variables can be assigned and updated:</p>

<pre>
no db>t := tup {i 2, s 'Two'};
1 element affected.
no db> update t {i := 3};
1 element affected.
no db> update t {i := 4, s := 'Four'};
2 elements affected.
</pre>

<p>Accessing tuple attributes:

<pre>
no db>put_line(t.s);
Four
no db>
</pre>

<p>Alternative form:

<pre>
no db>put_line(s from t);
Four
no db>
</pre>

<h2>Databases and database environments</h2>

<p>Database environments are the places where databases and tables are physically stored.
Therefore a database environment must exist before a database can be created.
In Duro D/T, a database environment can be created using the built-in
update operator create_env():</p>

<pre>
no db>create_env('dbenv');
no db>
</pre>

<p>The built-in update operator connect() can be used to connect
to an existing database environment. connect() takes one argument
of type <code>string</code> which specifies the database environment:</p>

<pre>
no db>connect('dbenv');
no db>
</pre>

<p>After a database environment was created or connected to, a
database can be created using the built-in
update operator create_db().</p>

<pre>
no db>create_db('D');
no db>
</pre>

<p>The variable <code>current_db</code> contains the database currently in use.
A database can be selected by assigning the variable:</p>

<pre>
no db>current_db := 'D';
1 element affected.
D>
</pre>

<p>After <code>current_db</code> has been set, the prompt shows the name
of the database selected and a transaction can be started
using BEGIN TRANSACTION. Instead of BEGIN TRANSACTION, BEGIN TX
can be used:</p>

<pre>
D> begin tx;
Transaction started.
D>
</pre>

<p>Transaction commit:

<pre>
D> commit;
Transaction committed.
D>
</pre>

<p>Transaction rollback:

<pre>
D> rollback;
Transaction rolled back.
D>
</pre>

<h2>Tables</h2>

<p>Creating a real persistent table:

<pre>
D> var R real rel{NO INTEGER, NAME STRING} key {NO};
Table R created.
D>
</pre>

<p>REL can be used as a synonym for RELATION.

<p>Creating a private (real transient) table:

<pre>
D> var p private rel{NO INTEGER, NAME STRING} key {NO};
Local table P created.
D>
</pre>

<p>Creating a virtual table:

<pre>
D> var V virtual R {NO};
Table V created.
D>
</pre>

<p>Inserting a single tuple:</p>

<pre>
D> insert r tup {NO 1, NAME 'one'};
1 element affected.
D>
</pre>

<p>Inserting several tuples:</p>

<pre>
D> insert R rel {tup {NO 2, NAME 'two'}, tup {NO 3, NAME 'three'}};
2 elements affected.
D>
</pre>

<p>Updating</p>

<pre>
D> update R where NO = 3 { NO := 4, NAME := 'four' };
1 element affected.
D>
</pre>

<p>Deleting tuples</p>

<pre>
D> delete R where NO = 4;
1 element affected.
D>
</pre>

<h2>Table and database constraints</h2>

<p>Example:</p>

<pre>
D> begin tx;
Transaction started.
D> var R real rel {NO INTEGER, NAME STRING} key {no};
Table R created.
D> constraint CR count(r) <= 1;
Constraint CR created.
D> insert R tup {NO 1, NAME 'one'};
1 element affected.
D> insert r tup {NO 2, NAME 'two'};
PREDICATE_VIOLATION_ERROR: CR
D> drop constraint CR;
Constraint CR dropped.
D>
</pre>

<h2>Arrays</h2>

<p>Example: Printing all tuples of table R in an unspecified order:

<pre>
D> var a array tup same_heading_as(R);
D> load a from R order();
D> var i INTEGER;
D> for i:= 0 to LENGTH(a)-1;
D>   put(a[i]); put_line('');
D> end for;
</pre>

<h2>I/O</h2>

<p>In its current version, Duro D/T features very limited I/O support.

<p>It provides the following update operators for I/O:

<h3>put_line</h3>

<p><code>put_line</code> takes one argument of type <code>string</code>
and prints it on standard output, followed by a newline.

<pre>
no db> call put_line('hello');
hello
no db>
</pre>

<p>Note that in Duro D/T, the keyword CALL in update operator invocations
is optional. The following is also valid:

<pre>
no db> call put_line('hello');
hello
no db>
</pre>

<h3>put</h3>

<p><code>put</code> works like <code>put_line</code>, except that its output is not
followed by a newline.  It is defined for all built-in scalar types
except <code>binary</code> and also for tuple and relation arguments:

<pre>
no db> put('2 + 2 = '); put(2 + 2); put_line('');
2 + 2 = 4
no db> put(true); put_line('');
TRUE
no db> put(tup {a 1, b 'bee'}); put_line('');
TUPLE { a 1, b 'bee' }
no db> put(rel {tup {I 1, C 'foo'}, tup {I 2, C 'bar'}}); put_line('');
RELATION { TUPLE { i 1, c 'foo' }, TUPLE { i 2, c 'bar' }}
no db>
</pre>

<h3>get_line</h3>

<p><code>get_line</code> is defined as follows:</p>

<p>OPERATOR get_line(line string) UPDATES {line};</p>

<p><code>get_line</code> reads one line from standard input and stores
it in <code>line</code>, without the trailing newline.</p>

<h2>User-defined operators</h2>

<p>Defining a read-only operator:

<pre>
D> operator INCR(i integer) returns integer;
D> return i + 1;
D> end operator;
Operator INCR created.
D>
</pre>

<p>Defining an update operator:

<pre>
D> operator INC(i integer) updates {i};
D> i := i + 1;
D> end operator;
Operator INC created.
D>
</pre>

<p>Dropping an operator:

<pre>
D> drop operator INCR;
Operator INCR dropped.
D>
</pre>

<h2>User-defined types</h2>

<p>Example for defining a type:</p>

<pre>
no db> connect('dbenv');
no db> type len possrep {N FLOAT} constraint the_n(len) >= 0.0;
Type LEN defined.
</pre>

<p>Before the type can be used, it must first be implemented.
This can be done using IMPLEMENT TYPE:</p>

<pre>
no db> implement type len;
Type len implemented.
</pre>

<p>This currently works only for types with exactly one possible representation.
Full type implementation functionality is available through the
<a href="../api/html/group__typeimpl.html">C interface</a>
or the Tcl interface
(<a href="../tcl/type.html">duro::type</a>).

<p>After a type has been defined, it can be used to declare and assign variables, like so:

<pre>
D> var l LEN;
D> l := LEN(1.0);
1 element affected.
D>
</pre>

<h2>Exception handling</h2>

<p>By default, if an error occurs, execution is stopped.

<p>In Duro D/T, it is possible to handle errors and to continue execution.
It is also possible to generate errors from user code.

<h3>RAISE</h3>

<p>The RAISE statement generates an error. It can take any argument and will use it as an error
value:

<pre>
D> raise 2;
INTEGER
D>
</pre>

<p>If an error is not handled, execution is stopped and the error type
is printed to standard output. This is why we see "INTEGER" appear.

<p>Raising a system-provided error:

<pre>
D> raise NAME_ERROR('test');
NAME_ERROR: test
D>
</pre>

<p>If the error type has a MSG property, its value is printed together with the type.
See the <a href="../api/html/builtin-types.html">built-in types</a>
for a list of system-provided error types.

<h3>TRY .. CATCH</h3>

<p>TRY .. CATCH can be used to catch errors that may be raised during execution.
A TRY block must be followed by one or more CATCH blocks.

<p>The following code illustrates catching errors using TRY .. CATCH:

<pre>
try

/* Perform operations that could throw errors */

...

catch err INVALID_ARGUMENT_ERROR;

  /* Handle INVALID_ARGUMENT_ERROR */

...

catch err;

  /* Handle remaining errors */

...

end try;
</pre>

<hr>

</html>
