<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
"http://www.w3.org/TR/html4/strict.dtd">
<html lang="en">
<head>
<title>Duro 0.12 API (Release 0.12)</title>
<body>
<h1>Duro API</h1>

<p>Release 0.12

<h2>Contents</h2>

<h3>Table functions</h3>

<ul>
<li><a href="#add_table">RDB_add_table</a>
<li><a href="#all">RDB_all</a>
<li><a href="#any">RDB_any</a>
<li><a href="#avg">RDB_avg</a>
<li><a href="#cardinality">RDB_cardinality</a>
<li><a href="#copy_table">RDB_copy_table</a>
<li><a href="#create_table">RDB_create_table</a>
<li><a href="#create_table">RDB_create_table_from_type</a>
<li><a href="#delete">RDB_delete</a>
<li><a href="#drop_table">RDB_drop_table</a>
<li><a href="#expr_to_vtable">RDB_expr_to_vtable</a>
<li><a href="#extract_tuple">RDB_extract_tuple</a>
<li><a href="#get_table">RDB_get_table</a>
<li><a href="#insert">RDB_insert</a>
<li><a href="#max">RDB_max</a>
<li><a href="#min">RDB_min</a>
<li><a href="#multi_assign">RDB_multi_assign</a>
<li><a href="#remove_table">RDB_remove_table</a>
<li><a href="#set_table_name">RDB_set_table_name</a>
<li><a href="#subset">RDB_subset</a>
<li><a href="#sum">RDB_sum</a>
<li><a href="#table_contains">RDB_table_contains</a>
<li><a href="#table_is_empty">RDB_table_is_empty</a>
<li><a href="#table_name">RDB_table_name</a>
<li><a href="#update">RDB_update</a>
</ul>

<h3>Tuple functions</h3>

<ul>
<li><a href="#extend_tuple">RDB_extend_tuple</a>
<li><a href="#join_tuples">RDB_join_tuples</a>
<li><a href="#project_tuple">RDB_project_tuple</a>
<li><a href="#rename_tuple">RDB_rename_tuple</a>
<li><a href="#tuple_attr_names">RDB_tuple_attr_names</a>
<li><a href="#tuple_get">RDB_tuple_get</a>
<li><a href="#tuple_get_bool">RDB_tuple_get_bool</a>
<li><a href="#tuple_get_int">RDB_tuple_get_int</a>
<li><a href="#tuple_get_float">RDB_tuple_get_float</a>
<li><a href="#tuple_get_double">RDB_tuple_get_double</a>
<li><a href="#tuple_get_string">RDB_tuple_get_string</a>
<li><a href="#tuple_set">RDB_tuple_set</a>
<li><a href="#tuple_set_bool">RDB_tuple_set_bool</a>
<li><a href="#tuple_set_int">RDB_tuple_set_int</a>
<li><a href="#tuple_set_float">RDB_tuple_set_float</a>
<li><a href="#tuple_set_double">RDB_tuple_set_double</a>
<li><a href="#tuple_set_string">RDB_tuple_set_string</a>
<li><a href="#tuple_size">RDB_tuple_size</a>
<li><a href="#unwrap_tuple">RDB_unwrap_tuple</a>
<li><a href="#wrap_tuple">RDB_wrap_tuple</a>
</ul>

<h3>Scalar and generic functions</h3>

<ul>
<li><a href="#append_string">RDB_append_string</a>
<li><a href="#binary_get">RDB_binary_get</a>
<li><a href="#binary_set">RDB_binary_set</a>
<li><a href="#binary_length">RDB_binary_length</a>
<li><a href="#copy_obj">RDB_copy_obj</a>
<li><a href="#destroy_obj">RDB_destroy_obj</a>
<li><a href="#init_obj">RDB_init_obj</a>
<li><a href="#obj_bool">RDB_obj_bool</a>
<li><a href="#obj_comp">RDB_obj_comp</a>
<li><a href="#obj_equals">RDB_obj_equals</a>
<li><a href="#obj_int">RDB_obj_int</a>
<li><a href="#obj_float">RDB_obj_float</a>
<li><a href="#obj_double">RDB_obj_double</a>
<li><a href="#bool_to_obj">RDB_bool_to_obj</a>
<li><a href="#int_to_obj">RDB_int_to_obj</a>
<li><a href="#float_to_obj">RDB_float_to_obj</a>
<li><a href="#double_to_obj">RDB_double_to_obj</a>
<li><a href="#string_to_obj">RDB_string_to_obj</a>
<li><a href="#obj_irep">RDB_obj_irep</a>
<li><a href="#obj_set_comp">RDB_obj_set_comp</a>
<li><a href="#obj_string">RDB_obj_string</a>
<li><a href="#obj_type">RDB_obj_type</a>
</ul>

<h3>Database functions</h3>

<ul>
<li><a href="#create_db_from_env">RDB_create_db_from_env</a>
<li><a href="#db_env">RDB_db_env</a>
<li><a href="#db_name">RDB_db_name</a>
<li><a href="#drop_db">RDB_drop_db</a>
<li><a href="#get_db_from_env">RDB_get_db_from_env</a>
</ul>

<h3>Transaction functions</h3>

<ul>
<li><a href="#begin_tx">RDB_begin_tx</a>
<li><a href="#commit">RDB_commit</a>
<li><a href="#rollback">RDB_rollback</a>
<li><a href="#tx_db">RDB_tx_db</a>
<li><a href="#tx_is_running">RDB_tx_is_running</a>
</ul>

<h3>Array functions</h3>

<ul>
<li><a href="#array_get">RDB_array_get</a>
<li><a href="#array_length">RDB_array_length</a>
<li><a href="#array_set">RDB_array_set</a>
<li><a href="#table_to_array">RDB_table_to_array</a>
<li><a href="#set_array_length">RDB_set_array_length</a>
</ul>

<h3>Expression functions</h3>

<ul>
<li><a href="#add_arg">RDB_add_arg</a>
<li><a href="#expr_is_const">RDB_expr_is_const</a>
<li><a href="#bool_to_expr">RDB_bool_to_expr</a>
<li><a href="#int_to_expr">RDB_int_to_expr</a>
<li><a href="#double_to_expr">RDB_double_to_expr</a>
<li><a href="#string_to_expr">RDB_string_to_expr</a>
<li><a href="#table_ref">RDB_table_ref</a>
<li><a href="#obj_to_expr">RDB_obj_to_expr</a>
<li><a href="#expr_var">RDB_expr_var</a>
<li><a href="#eq">RDB_eq</a>
<li><a href="#expr_any">RDB_expr_any</a>
<li><a href="#expr_all">RDB_expr_all</a>
<li><a href="#expr_avg">RDB_expr_avg</a>
<li><a href="#expr_comp">RDB_expr_comp</a>
<li><a href="#expr_max">RDB_expr_max</a>
<li><a href="#expr_min">RDB_expr_min</a>
<li><a href="#expr_sum">RDB_expr_sum</a>
<li><a href="#tuple_attr">RDB_tuple_attr</a>
<li><a href="#ro_op">RDB_ro_op</a>
<li><a href="#drop_expr">RDB_drop_expr</a>
</ul>

<h3>Type functions</h3>

<ul>
<li><a href="#define_type">RDB_define_type</a>
<li><a href="#implement_type">RDB_implement_type</a>
<li><a href="#create_array_type">RDB_create_array_type</a>
<li><a href="#create_relation_type">RDB_create_relation_type</a>
<li><a href="#create_tuple_type">RDB_create_tuple_type</a>
<li><a href="#get_type">RDB_get_type</a>
<li><a href="#drop_type">RDB_drop_type</a>
<li><a href="#type_attrs">RDB_type_attrs</a>
<li><a href="#type_name">RDB_type_name</a>
<li><a href="#type_is_scalar">RDB_type_is_scalar</a>
<li><a href="#type_is_numeric">RDB_type_is_numeric</a>
<li><a href="#type_equals">RDB_type_equals</a>
</ul>

<h3>Operator functions</h3>

<ul>
<li><a href="#create_ro_op">RDB_create_ro_op</a>
<li><a href="#create_update_op">RDB_create_update_op</a>
<li><a href="#call_ro_op">RDB_call_ro_op</a>
<li><a href="#call_update_op">RDB_call_update_op</a>
<li><a href="#drop_op">RDB_drop_op</a>
</ul>

<h3>Constraint functions</h3>

<ul>
<li><a href="#create_constraint">RDB_create_constraint</a>
<li><a href="#drop_constraint">RDB_drop_constraint</a>
</ul>

<h3>Database environment functions</h3>

<ul>
<li><a href="#open_env">RDB_open_env</a>
<li><a href="#close_env">RDB_close_env</a>
</ul>

<h3>Index functions</h3>

<ul>
<li><a href="#create_table_index">RDB_create_table_index</a>
<li><a href="#drop_table_index">RDB_drop_table_index</a>
</ul>

<h3>Execution context functions</h3>

<ul>
<li><a href="#init_exec_context">RDB_init_exec_context</a>
<li><a href="#destroy_exec_context">RDB_destroy_exec_context</a>
<li><a href="#raise_err">RDB_raise_err</a>
<li><a href="#get_err">RDB_get_err</a>
<li><a href="#clear_err">RDB_clear_err</a>
<li><a href="#raise_no_memory">RDB_raise_no_memory</a>
<li><a href="#raise_no_memory">RDB_raise_invalid_argument</a> 
<li><a href="#raise_no_memory">RDB_raise_invalid_tx</a>
<li><a href="#raise_no_memory">RDB_raise_not_found</a> 
<li><a href="#raise_no_memory">RDB_raise_type_mismatch</a> 
<li><a href="#raise_no_memory">RDB_raise_operator_not_found</a> 
<li><a href="#raise_no_memory">RDB_raise_type_constraint_violation</a> 
<li><a href="#raise_no_memory">RDB_raise_element_exists</a> 
<li><a href="#raise_no_memory">RDB_raise_not_supported</a> 
<li><a href="#raise_no_memory">RDB_raise_attribute_not_found</a> 
<li><a href="#raise_no_memory">RDB_raise_predicate_violation</a> 
<li><a href="#raise_no_memory">RDB_raise_system</a> 
<li><a href="#raise_no_memory">RDB_raise_resource_not_found</a> 
<li><a href="#raise_no_memory">RDB_raise_internal</a> 
<li><a href="#raise_no_memory">RDB_raise_lock_not_granted</a>
<li><a href="#raise_no_memory">RDB_raise_aggregate_undefined</a>
<li><a href="#raise_no_memory">RDB_raise_version_mismatch</a>
<li><a href="#raise_no_memory">RDB_raise_syntax</a> 
<li><a href="#ec_set_property">RDB_ec_set_property</a>
<li><a href="#ec_get_property">RDB_ec_get_property</a>
</ul>

<h3>Expression parsing functions</h3>

<ul>
<li><a href="#parse_expr">RDB_parse_expr</a>
<li><a href="#parse_expr">RDB_parse_table</a>
</ul>


<h3>C structures and definitions</h3>

<ul>
<li><a href="#attr">RDB_attr</a>
<li><a href="#virtual_attr">RDB_virtual_attr</a>
<li><a href="#renaming">RDB_renaming</a>
<li><a href="#wrapping">RDB_wrapping</a>
<li><a href="#possrep">RDB_possrep</a>
<li><a href="#aggregate_op">RDB_aggregate_op</a>
</ul>

<h3>Built-in types</h3>

<ul>
<li><a href="#data-types">Basic data types</a>
<li><a href="#error-types">Error types</a>
</ul>

<h3><a href="#builtin-ops">Built-in operators</a></h3>

<h4>Built-in scalar operators</h4>

<ul>
<li><a href="#op_eq">=</a>
<li><a href="#op_neq">&lt;&gt;</a>
<li><a href="#op_lt">&lt;</a>
<li><a href="#op_lte">&lt;=</a>
<li><a href="#op_gt">&gt;</a>
<li><a href="#op_gte">&gt;=</a>
<li><a href="#op_plus">+</a>
<li><a href="#op_uminus">- (unary)</a>
<li><a href="#op_bminus">- (binary)</a>
<li><a href="#op_times">*</a>
<li><a href="#op_div">/</a>
<li><a href="#op_and">AND</a>
<li><a href="#op_or">OR</a>
<li><a href="#op_not">NOT</a>
<li><a href="#op_concat">||</a>
<li><a href="#op_length">LENGTH</a>
<li><a href="#op_substring">SUBSTRING</a>
<li><a href="#op_matches">MATCHES</a>
<li><a href="#op_integer">INTEGER</a>
<li><a href="#op_float">FLOAT</a>
<li><a href="#op_double">DOUBLE</a>
<li><a href="#op_string">STRING</a>
<li><a href="#op_is_empty">IS_EMPTY</a>
<li><a href="#op_count">COUNT</a>
<li><a href="#op_in">IN</a>
<li><a href="#op_subset_of">SUBSET_OF</a>
<li><a href="#op_if">IF</a>
</ul>

<h4>Built-in relational and tuple operators</h4>

<ul>
<li><a href="#op_divide">DIVIDE</a></li>
<li><a href="#op_extend">EXTEND</a></li>
<li><a href="#op_group">GROUP</a></li>
<li><a href="#op_intersect">INTERSECT</a></li>
<li><a href="#op_join">JOIN</a></li>
<li><a href="#op_minus">MINUS</a></li>
<li><a href="#op_project">PROJECT</a></li>
<li><a href="#op_remove">REMOVE</a></li>
<li><a href="#op_rename">RENAME</a></li>
<li><a href="#op_ungroup">UNGROUP</a></li>
<li><a href="#op_union">UNION</a></li>
<li><a href="#op_unwrap">UNWRAP</a></li>
<li><a href="#op_semijoin">SEMIJOIN</a></li>
<li><a href="#op_semiminus">SEMIMINUS</a></li>
<li><a href="#op_summarize">SUMMARIZE</a></li>
<li><a href="#op_where">WHERE</a></li>
<li><a href="#op_wrap">WRAP</a></li>
</ul>

<hr>

<h2 id="add_table">RDB_add_table</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_add_table(RDB_object *tbp, RDB_exec_context *ecp, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_add_table adds the table specified by <var>tbp</var> to the
database the transaction specified by <var>txp</var> interacts with.

<p>If an error occurs, an error value is left in *<var>ecp</var>.

<p>If the table is a local (transient) table, it is made global
(persistent).

<p>The table must have a name.

<p>Currently, RDB_add_table is not supported for local real tables.

<h3>Return value</h3>

<p>RDB_OK on success, RDB_ERROR if an error occurred.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION_ERROR
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_INVALID_ARGUMENT_ERROR
<dd>The table does not have a name.
<dt>RDB_ELEMENT_EXIST_ERROR
<dd>The table is already associated with the database.
<dt>RDB_NOT_SUPPORTED_ERROR
<dd>The table is a local real table.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction may be implicitly rolled back.

<hr>

<h2 id="create_table">RDB_create_table</h2>

<pre>
#include &lt;rel/rdb.h&gt;

typedef struct {
    int strc;
    char **strv;
} RDB_string_vec;

RDB_object *
RDB_create_table(const char *name, RDB_bool global,
                 int attrc, const <a href="#attr">RDB_attr</a> attrv[],
                 int keyc, const RDB_string_vec keyv[],
                 RDB_exec_context *ecp, RDB_transaction *txp);

RDB_object *
RDB_create_table_from_type(const char *name, RDB_bool global,
                RDB_type *reltyp,
                int keyc, const RDB_string_vec keyv[],
                RDB_exec_context *ecp, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p><strong>RDB_create_table</strong> creates a table with name <var>name</var>
under the control of the transaction pointed to by <var>txp</var>
and returns a pointer to the newly created RDB_object structure.

<p>If an error occurs, an error value is left in *<var>ecp</var>.

<p>If <var>global</var> is RDB_FALSE, a local (transient) table will be created.
In this case, <var>name</var> may be NULL.

<p>If <var>global</var> is RDB_TRUE, a global (persistent) table in the database
the transaction pointed to by <var>txp</var> interacts with will be created.

<p>The table will have <var>attrc</var> attributes. The individual
attributes are specified by the elements of <var>attrv</var>.

<p>The fields of the RDB_attr structure are interpreted as follows:

<dl>
<dt>name
<dd>Specifies the name of the attribute.
<dt>typ
<dd>Specifies the type of the attribute.
<dt>defaultp
<dd>If not NULL, this field must point to a RDB_object variable that specifies
the default value for the attribute.
<dt>options
<dd>This field is currently ignored. It should be set to zero
for compatibility with future versions of Duro.
</dl>

<p>The table will have <var>keyc</var> candidate keys. The <var>keyv</var>
argument specifies the key attributes.
The strc field of the RDB_string_vec structure specifies
the number of attributes in a key, while the elements of the strv field specify
the names of the key attributes.

<p>At least one candidate key must be specified.
A candidate key may not be a subset of another.
If a single candidate key is specified, that key
may be empty (not contain any attributes).

<p>Passing a <var>keyv</var> of NULL is equivalent to specifiying a single key
which consists of all attributes, that is, the table will become all-key.

<p>To enforce the key constraints, Duro creates a unique hash index
for each key.

<p><strong>RDB_create_table_from_type</strong> acts like
<strong>RDB_create_table</strong>, except that it takes
a RDB_type argument instead of attribute arguments.
*<var>reltyp</var> must be a relation type.

<h3>Return value</h3>

<p>On success, a pointer to the newly created table is returned.
If an error occurred, NULL is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION_ERROR
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_TYPE_MISMATCH_ERROR
<dd>The type of a default value does not match the type of the corresponding
attribute.
<dt>RDB_INVALID_ARGUMENT_ERROR
<dd>One or more of the arguments are incorrect. For example, a key attribute
does not appear in <var>attrv</var>, etc.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction may be implicitly rolled back.

<hr>

<h2 id="get_table">RDB_get_table</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_object *
RDB_get_table(const char *name, RDB_exec_context *ecp, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_get_table looks up the global table with name <var>name</var>
in the environment of the database the transaction
specified by <var>txp</var> interacts with and returns a pointer to it.

<p>If an error occurs, an error value is left in *<var>ecp</var>.

<h3>Return value</h3>

<p>A pointer to the table, or NULL if an error occurred.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION_ERROR
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_NOT_FOUND_ERROR
<dd>A table with the name <var>name</var> could not be found.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction may be implicitly rolled back.

<hr>

<h2 id="drop_table">RDB_drop_table</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_drop_table(RDB_object *tbp, RDB_exec_context *ecp, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_drop_table deletes the table specified by <var>tbp</var>
and frees all resources associated with that table.
If the table is virtual, its unnamed child tables are also deleted.

<p>If an error occurs, an error value is left in *<var>ecp</var>.

<p>If the table is local, <var>txp</var> may be NULL.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, RDB_ERROR is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION_ERROR
<dd>The table is global (persistent) and <var>txp</var>
does not point to a running transaction.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction may be implicitly rolled back.

<hr>

<h2 id="table_name">RDB_table_name</h2>

<pre>
#include &lt;rel/rdb.h&gt;

char *
RDB_table_name(RDB_object *tbp)
</pre>

<h3>Description</h3>

<p>RDB_table_name returns a pointer to the name of a table.

<h3>Return value</h3>

<p>A pointer to the name of the table, or NULL if the table has no name.

<hr>

<h2 id="set_table_name">RDB_set_table_name</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_set_table_name(RDB_object *tbp, const char *name,
        RDB_exec_context *ecp, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_set_table_name sets the name of the table to <var>name</var>.

<p>If an error occurs, an error value is left in *<var>ecp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, RDB_ERROR is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION_ERROR
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_INVALID_ARGUMENT_ERROR
<dd><var>name</var> is not a valid table name.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction may be implicitly rolled back.

<hr>

<h2 id="subset">RDB_subset</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_subset(RDB_object *tb1p, RDB_object *tb2p, RDB_exec_context *ecp, RDB_transaction *txp,
        RDB_bool *resultp);
</pre>

<h3>Description</h3>

<p>RDB_subset checks if the table specified by <var>tb1p</var> is a subset
of the table specified by <var>tb2p</var> and stores the result at the
location pointed to by <var>resultp</var>.

<p>If an error occurs, an error value is left in *<var>ecp</var>.

<h3>Return value</h3>

<p>RDB_OK on success, RDB_ERROR if an error occurred.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION_ERROR
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_TYPE_MISMATCH_ERROR
<dd>The types of the two tables differ.
<dt>RDB_OPERATOR_NOT_FOUND_ERROR
<dd>The definition of one of the tables
refers to a non-existing operator.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction may be implicitly rolled back.

<hr>

<h2 id="remove_table">RDB_remove_table</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_remove_table(RDB_object *tbp, RDB_exec_context *ecp, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_remove_table removes the table specified by <var>tbp</var> from the
database the transaction specified by <var>txp</var> interacts with.

<p>If an error occurs, an error value is left in *<var>ecp</var>.

<p>If the table is a global table, it is made local.

<h3>Return value</h3>

<p>RDB_OK on success, RDB_ERROR if an error occurred.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION_ERROR
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_INVALID_ARGUMENT_ERROR
<dd>The table does not belong to the database the transaction interacts
with.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction may be implicitly rolled back.

<h3>Notes</h3>

<p><strong>This function is not implemented.</strong>

<hr>

<h2 id="table_contains">RDB_table_contains</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_table_contains(RDB_object *tbp, const RDB_object *tplp, RDB_exec_context *ecp,
        RDB_transaction *txp, RDB_bool *resultp);
</pre>

<h3>Description</h3>

<p>RDB_table_contains checks if the tuple specified by <var>tplp</var>
is an element of the table specified by <var>tbp</var>
and stores the result at the location pointed to by <var>resultp</var>.

<p>If an error occurs, an error value is left in *<var>ecp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned.
If an error occurred, RDB_ERROR is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION_ERROR
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_INVALID_ARGUMENT_ERROR
<dd>A table attribute is missing in the tuple.
<dt>RDB_TYPE_MISMATCH_ERROR
<dd>The type of a tuple attribute does not match the type of the
corresponding table attribute.
<dt>RDB_OPERATOR_NOT_FOUND_ERROR
<dd>The definition of the table specified by <var>tbp</var>
refers to a non-existing operator.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction may be implicitly rolled back.

<hr>

<h2 id="all">RDB_all</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_all(RDB_object *tbp, const char *attrname, RDB_exec_context *ecp, RDB_transaction *txp,
        RDB_bool *resultp);
</pre>

<h3>Description</h3>

<p>RDB_all computes a logical AND over the attribute
<var>attrname</var> of the table specified by <var>tbp</var>
and stores the result at the location pointed to by <var>resultp</var>.

<p>If the table has only one attribute, <var>attrname</var>
may be NULL.

<p>If an error occurs, an error value is left in *<var>ecp</var>.

<p>The attribute <var>attrname</var> must be of type BOOLEAN.

<h3>Return value</h3>

<p>RDB_OK on success, RDB_ERROR if an error occurred.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION_ERROR
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_ATTRIBUTE_NOT_FOUND_ERROR
<dd>The table does not have an attribute <var>attrname</var>.
<dt>RDB_TYPE_MISMATCH_ERROR
<dd>The type of the attribute is not BOOLEAN.
<dt>RDB_INVALID_ARGUMENT_ERROR
<dd><var>attrname</var> is NULL and the table has more than one
attribute.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction may be implicitly rolled back.

<hr>

<h2 id="any">RDB_any</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_any(RDB_object *tbp, const char *attrname, RDB_exec_context *ecp, RDB_transaction *txp,
        RDB_bool *resultp);
</pre>

<h3>Description</h3>

<p>RDB_any computes a logical OR over the attribute
<var>attrname</var> of the table specified by <var>tbp</var>
and stores the result at the location
pointed to by <var>resultp</var>.

<p>If the table has only one attribute, <var>attrname</var>
may be NULL.

<p>If an error occurs, an error value is left in *<var>ecp</var>.

<p>The attribute <var>attrname</var> must be of
type BOOLEAN.

<h3>Return value</h3>

<p>RDB_OK on success, RDB_ERROR if an error occurred.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION_ERROR
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_ATTRIBUTE_NOT_FOUND_ERROR
<dd>The table does not have an attribute <var>attrname</var>.
<dt>RDB_TYPE_MISMATCH_ERROR
<dd>The type of the attribute is not BOOLEAN.
<dt>RDB_INVALID_ARGUMENT_ERROR
<dd><var>attrname</var> is NULL and the table has more than one
attribute.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction may be implicitly rolled back.

<hr>

<h2 id="avg">RDB_avg</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_avg(RDB_object *tbp, const char *attrname, RDB_exec_context *ecp, RDB_transaction *txp,
        RDB_double *resultp);
</pre>

<h3>Description</h3>

<p>RDB_avg computes the average over the attribute
<var>attrname</var> of the table specified by <var>tbp</var>
and stores the result at the location
pointed to by <var>resultp</var>.

<p>If the table has only one attribute, <var>attrname</var>
may be NULL.

<p>If an error occurs, an error value is left in *<var>ecp</var>.

<p>The attribute <var>attrname</var> must be numeric.

<h3>Return value</h3>

<p>RDB_OK on success, RDB_ERROR if an error occurred.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION_ERROR
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_ATTRIBUTE_NOT_FOUND_ERROR
<dd>The table does not have an attribute <var>attrname</var>.
<dt>RDB_TYPE_MISMATCH_ERROR
<dd>The type of the attribute is not numeric.
<dt>RDB_INVALID_ARGUMENT_ERROR
<dd><var>attrname</var> is NULL and the table has more than one
attribute.
<dt>RDB_AGGREGATE_UNDEFINED_ERROR
<dd>The table is empty.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction may be implicitly rolled back.

<hr>

<h2 id="cardinality">RDB_cardinality</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_int
RDB_cardinality(RDB_object *tbp, RDB_exec_context *ecp, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_cardinality returns the number of tuples in
the table pointed to by <var>tbp</var>.

<p>If an error occurs, an error value is left in *<var>ecp</var>.

<h3>Return value</h3>

<p>On success, the number of tuples is returned.
On failure, (RDB_int)RDB_ERROR is returned.
(RDB_int)RDB_ERROR is guaranteed to be lower than zero.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION_ERROR
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_OPERATOR_NOT_FOUND_ERROR
<dd>The definition of the table specified by <var>tbp</var>
refers to a non-existing operator.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction may be implicitly rolled back.

<hr>

<h2 id="max">RDB_max</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_max(RDB_object *tbp, const char *attrname, RDB_exec_context *ecp, RDB_transaction *txp,
        RDB_object *resultp);
</pre>

<h3>Description</h3>

<p>RDB_max computes the maximum over the attribute
<var>attrname</var> of the table specified by <var>tbp</var>
and stores the result at the location pointed to by <var>resultp</var>.

<p>If the table has only one attribute, <var>attrname</var>
may be NULL.

<p>If an error occurs, an error value is left in *<var>ecp</var>.

<p>The attribute <var>attrname</var> must be numeric
and the result is of the same type as the attribute.

<h3>Return value</h3>

<p>RDB_OK on success, RDB_ERROR if an error occurred.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION_ERROR
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_ATTRIBUTE_NOT_FOUND_ERROR
<dd>The table does not have an attribute <var>attrname</var>.
<dt>RDB_TYPE_MISMATCH_ERROR
<dd>The type of the attribute is not numeric.
<dt>RDB_INVALID_ARGUMENT_ERROR
<dd><var>attrname</var> is NULL and the table has more than one
attribute.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction may be implicitly rolled back.

<hr>

<h2 id="min">RDB_min</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_min(RDB_object *tbp, const char *attrname, RDB_exec_context *ecp, RDB_transaction *txp,
        RDB_object *resultp);
</pre>

<h3>Description</h3>

<p>RDB_min computes the minimum over the attribute
<var>attrname</var> of the table specified by <var>tbp</var>
and stores the result at the location pointed to by <var>resultp</var>.

<p>If the table has only one attribute, <var>attrname</var>
may be NULL.

<p>If an error occurs, an error value is left in *<var>ecp</var>.

<p>The attribute <var>attrname</var> must be numeric
and the result is of the same type as the attribute.

<h3>Return value</h3>

<p>RDB_OK on success, RDB_ERROR if an error occurred.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION_ERROR
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_ATTRIBUTE_NOT_FOUND_ERROR
<dd>The table does not have an attribute <var>attrname</var>.
<dt>RDB_TYPE_MISMATCH_ERROR
<dd>The type of the attribute is not numeric.
<dt>RDB_INVALID_ARGUMENT_ERROR
<dd><var>attrname</var> is NULL and the table has more than one
attribute.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction may be implicitly rolled back.

<hr>

<h2 id="sum">RDB_sum</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_sum(RDB_object *tbp, const char *attrname, RDB_exec_context *ecp, RDB_transaction *txp,
        RDB_object *resultp);
</pre>

<h3>Description</h3>

<p>RDB_sum computes the sum over the attribute
<var>attrname</var> of the table pointed to by <var>tbp</var>
and stores the result at the location pointed to by <var>resultp</var>.

<p>If the table has only one attribute, <var>attrname</var>
may be NULL.

<p>If an error occurs, an error value is left in *<var>ecp</var>.

<p>The attribute <var>attrname</var> must be numeric
and the result is of the same type as the attribute.

<h3>Return value</h3>

<p>RDB_OK on success, RDB_ERROR if an error occurred.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION_ERROR
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_ATTRIBUTE_NOT_FOUND_ERROR
<dd>The table does not have an attribute <var>attrname</var>.
<dt>RDB_TYPE_MISMATCH_ERROR
<dd>The type of the attribute is not numeric.
<dt>RDB_INVALID_ARGUMENT_ERROR
<dd><var>attrname</var> is NULL and the table has more than one
attribute.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction may be implicitly rolled back.

<hr>

<h2 id="table_is_empty">RDB_table_is_empty</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_table_is_empty(RDB_object *tbp, RDB_exec_context *ecp, RDB_transaction *txp, RDB_bool *resultp);
</pre>

<h3>Description</h3>

<p>RDB_table_is_empty checks if the table specified by <var>tbp</var>
is empty and stores the result of
the check at the location pointed to by <var>resultp</var>.

<p>If an error occurs, an error value is left in *<var>ecp</var>.

<h3>Return value</h3>

<p>RDB_OK on success, RDB_ERROR if an error occurred.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION_ERROR
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_OPERATOR_NOT_FOUND_ERROR
<dd>The definition of the table specified by <var>tbp</var>
refers to a non-existing operator.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction may be implicitly rolled back.

<hr>

<h2 id="insert">RDB_insert</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_insert(RDB_object *tbp, const RDB_object *tplp, RDB_exec_context *ecp, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_insert inserts the tuple specified by <var>tplp</var>
into the table specified by <var>tbp</var>.

<p>If an error occurs, an error value is left in *<var>ecp</var>.

<p>Currently, RDB_insert is not supported for virtual tables which are the result
of a UNION, MINUS, SEMIMINUS, INTERSECT, SEMIJOIN, MINUS, SUMMARIZE, DIVIDEBY PER,
GROUP, or UNGROUP.
 
<h3>Return value</h3>

<p>RDB_OK on success, RDB_ERROR if an error occurred.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION_ERROR
<dd>The table given by <var>tbp</var> is global and <var>txp</var>
does not point to a running transaction.
<dt>RDB_INVALID_ARGUMENT_ERROR
<dd>A table attribute is missing in the tuple and no default value
was specified for that attribute.
<dt>RDB_ELEMENT_EXIST_ERROR
<dd>The tuple was already an element of the table.
<dt>RDB_KEY_VIOLATION_ERROR
<dd>Inserting the tuple would result in a table which contains
a key value twice.
<dt>RDB_PREDICATE_VIOLATION_ERROR
<dd>Inserting the tuple would result in a table which violates its
predicate.
<dt>RDB_TYPE_MISMATCH_ERROR
<dd>The type of a tuple attribute does not match the type of the
corresponding table attribute.
<dt>RDB_OPERATOR_NOT_FOUND_ERROR
<dd>The definition of the table specified by <var>tbp</var>
refers to a non-existing operator.
<dt>RDB_NOT_SUPPORTED_ERROR
<dd>RDB_insert is not supported for this type of table.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction may be implicitly rolled back.

<hr>

<h2 id="update">RDB_update</h2>

<pre>
#include &lt;rel/rdb.h&gt;

typedef struct {
    char *name;
    RDB_expression *exp;
} RDB_attr_update;

RDB_int
RDB_update(RDB_object *tbp, RDB_expression *exp, int updc,
        const RDB_attr_update updv[], RDB_exec_context *ecp, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_update updates all tuples from the table specified by <var>tbp</var>
for which the expression specified by <var>exp</var> evaluates to true.
If <var>exp</var> is NULL, all tuples are updated.

<p>If an error occurs, an error value is left in *<var>ecp</var>.

<p>The attributes to be updated are specified by the <var>updv</var> array.
The attribute specified by the field name is set to the value
obtained by evaluating the expression specified by the field exp.

<p>Currently, RDB_update is not supported for virtual tables except select
and project.

<h3>Return value</h3>

<p>The number of updated tuples in real tables if the call was successful.
A call which did not modify any tuple because no tuple matched the condition
is considered a successful call and returns zero.
If an error occurred, (RDB_int)RDB_ERROR is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION_ERROR
<dd><var>txp</var> does not point to a running transaction.

<dt>RDB_ATTRIBUTE_NOT_FOUND_ERROR
<dd>One of the attributes in <var>updv</var> does not exist in the table.
<dd>One of the expressions specified in <var>updv</var> refers to an attribute
which does not exist in the table.

<dt>RDB_ELEMENT_EXIST_ERROR
<dd>The update operation would update a tuple so that it would be equal
to a tuple which is already an element of the table.

<dt>RDB_KEY_VIOLATION_ERROR
<dd>The update operation would result in a table which contains
a key value twice.

<dt>RDB_PREDICATE_VIOLATION_ERROR
<dd>The update operation would result in a table which violates its
predicate.

<dt>RDB_TYPE_MISMATCH_ERROR
<dd>The type of one of the expressions in <var>updv</var> is not the same
as the type of the corresponding table attribute.

<dt>RDB_OPERATOR_NOT_FOUND_ERROR
<dd>The definition of the table specified by <var>tbp</var>
refers to a non-existing operator.
<dd>The expression specified by <var>exp</var>
refers to a non-existing operator.
<dd>One of the expressions specified in <var>updv</var>
refers to a non-existing operator.

<dt>RDB_NOT_SUPPORTED_ERROR
<dd>RDB_update is not supported for this type of table.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction may be implicitly rolled back.

<hr>

<h2 id="delete">RDB_delete</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_int
RDB_delete(RDB_object *tbp, RDB_expression *exp, RDB_exec_context *ecp, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_delete deletes all tuples from the table specified by <var>tbp</var>
for which the expression specified by <var>exp</var> evaluates to true.
If <var>exp</var> is NULL, all tuples are deleted.

<p>If an error occurs, an error value is left in *<var>ecp</var>.

<p>Currently, RDB_delete is not supported for virtual tables which are the result of
a JOIN, MINUS, SEMIMINUS, UNION, INTERSECT, SEMIJOIN, SUMMARIZE, WRAP, UNWRAP,
GROUP, UNGROUP, or DIVIDEBY PER.

<h3>Return value</h3>

<p>The number of deleted tuples, if no error occurred.
A call which did not delete any tuple because no tuple matched the condition
is considered a successful call and returns zero.
If an error occurred, (RDB_int)RDB_ERROR is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION_ERROR
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_INVALID_ARGUMENT_ERROR
<dd><var>exp</var> refers to an attribute which does not exist in the table.
<dt>RDB_PREDICATE_VIOLATION_ERROR
<dd>Deleting the tuples would result in a table which violates its
predicate.
<dt>RDB_OPERATOR_NOT_FOUND_ERROR
<dd>The definition of the table specified by <var>tbp</var>
refers to a non-existing operator.
<dd>The expression specified by <var>exp</var>
refers to a non-existing operator.
<dt>RDB_NOT_SUPPORTED_ERROR
<dd>RDB_delete is not supported for this type of table.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction may be implicitly rolled back.

<hr>

<h2 id="expr_to_vtable">RDB_expr_to_vtable</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_object *
RDB_expr_to_vtable(RDB_expression *, RDB_exec_context *ecp, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_expr_to_vtable creates a virtual table from the expression *<var>exp</var>.

<p>If an error occurs, an error value is left in *<var>ecp</var>.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION_ERROR
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_INVALID_ARGUMENT_ERROR
<dd>*<var>exp</var> does not define a valid virtual table.
<dt>RDB_ATTRIBUTE_NOT_FOUND_ERROR
<dd>*<var>exp</var> refers to an undefined attribute.
<dt>RDB_TYPE_MISMATCH_ERROR
<dd>*<var>exp</var> contains an operator invocation with an argument
of a wrong type.
<dt>RDB_OPERATOR_NOT_FOUND_ERROR
<dd>*<var>exp</var> contains an invocation of a non-existing operator.
</dl>

<h3>Return value</h3>

<p>A pointer to the newly created table, or NULL if an error occurred.

<hr>

<h2 id="extract_tuple">RDB_extract_tuple</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_extract_tuple(RDB_object *tbp, RDB_exec_context *ecp, RDB_transaction *txp, RDB_object *tplp);
</pre>

<h3>Description</h3>

<p>RDB_extract_tuple extracts a single tuple from a table which contains
only one tuple and stores its value in the variable pointed to by <var>tplp</var>.

<p>If an error occurs, the tuple value of the variable pointed to by <var>tplp</var>
is undefined and an error value is left in *<var>ecp</var>.

<h3>Return value</h3>

<p>RDB_OK on success, RDB_ERROR if an error occurred.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION_ERROR
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_NOT_FOUND_ERROR
<dd>The table is empty.
<dt>RDB_INVALID_ARGUMENT_ERROR
<dd>The table contains more than one tuple.
<dt>RDB_OPERATOR_NOT_FOUND_ERROR
<dd>The definition of the table specified by <var>tbp</var>
refers to a non-existing operator.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction may be implicitly rolled back.

<hr>

<h2 id="copy_table">RDB_copy_table</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_copy_table(RDB_object *dstp, RDB_object *srcp, RDB_exec_context *ecp, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_copy_table assigns the table specified
by <var>srcp</var> to the value of the table specified by <var>dstp</var>.
The two tables must be of the same type.

<p>Currently, virtual target tables are not supported.

<p>If an error occurs, an error value is left in *<var>ecp</var>.

<h3>Return value</h3>

<p>RDB_OK on success, RDB_ERROR if an error occurred.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION_ERROR
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_TYPE_MISMATCH_ERROR
<dd>The types of the two tables differ.
<dt>RDB_OPERATOR_NOT_FOUND_ERROR
<dd>The definition of the table specified by <var>srcp</var>
refers to a non-existing operator.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction may be implicitly rolled back.

<hr>

<h2 id="multi_assign">RDB_multi_assign</h2>

<pre>
#include &lt;rel/rdb.h&gt;

typedef struct {
    RDB_table *tbp;
    RDB_object *tplp;
} RDB_ma_insert;

typedef struct {
    RDB_table *tbp;
    RDB_expression *condp;
    int updc;
    RDB_attr_update *updv;
} RDB_ma_update;

typedef struct {
    RDB_table *tbp;
    RDB_expression *condp;
} RDB_ma_delete;

typedef struct {
    RDB_object *dstp;
    RDB_object *srcp;
} RDB_ma_copy;

RDB_int
RDB_multi_assign(int insc, const RDB_ma_insert insv[],
        int updc, const RDB_ma_update updv[],
        int delc, const RDB_ma_delete delv[],
        int copyc, const RDB_ma_copy copyv[],
        RDB_exec_context *ecp, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p><strong>RDB_multi_assign</strong> performs a number of insert, update, delete,
and copy operations in a single call.

<p>For each of the RDB_ma_insert elements given by <var>insc</var> and <var>insv</var>,
the tuple *<var>insv</var>[i]->tplp is inserted into *<var>insv</var>[i]->tbp.

<p>For each of the RDB_ma_update elements given by <var>updc</var> and <var>updv</var>,
the attributes given by <var>updv</var>[i]->updc and <var>updv</var>[i]->updv
of the tuples of *<var>updv</var>[i]->tbp for which *<var>updv</var>[i]->condp
evaluates to RDB_TRUE are updated.

<p>For each of the RDB_ma_delete elements given by <var>delc</var> and <var>delv</var>,
the tuples for which *<var>delv</var>[i]->condp evaluates to RDB_TRUE
are deleted from *<var>delv</var>[i]->tbp.

<p>For each of the RDB_ma_copy elements given by <var>copyc</var> and <var>copyv</var>,
*<var>copyv</var>[i]->scrp is copied to *<var>copyv</var>[i]->dstp.

<p>A <strong>RDB_multi_assign</strong> call is atomic with respect to
constraint checking; a constraint violation error can only occur
if the result of <em>all</em> operations violate a constraint.

<p>A table may not appear twice as a target in the arguments to
<strong>RDB_multi_assign</strong>, and it may not appear
as a source if it appears as a target in a previous assignment.

<p>This means that an assignment like the following:</p>

<code>
UPDATE S WHERE S# = S#('S2') STATUS := 15;
UPDATE S WHERE S# = S#('S3') STATUS := 25;
</code>

<p>(taken from <cite>TTM</cite>, chapter 6)
cannot be performed directly. It can, however, be converted to a
form like the following:</p>

<code>
UPDATE S WHERE (S# = S#('S2')) OR (S# = S#('S3'))
        STATUS := IF (S# = S#('S2')) THEN 15 ELSE 25;
</code>

<p>The restrictions of <a href="#insert">RDB_insert</a>, <a
href="#update">RDB_update</a>, <a href="#delete">RDB_delete</a>,
and <a href="#copy_obj">RDB_copy_obj</a>
regarding virtual target tables apply to RDB_multi_assign,
too.

<p><var>txp</var> must point to a running transaction execpt
if (1) no update or delete is specified, (2) only
inserts into local tables are specified, and (3)
there is no copy operation with an existing table as a target
which involves a global table as source or target.

<h3>Return value</h3>

<p>On success, the number of tuples inserted, deleted, and updated due to
<var>insc</var>, <var>insv</var>, <var>updc</var>, <var>updv</var>,
<var>delc</var> and <var>delv</var> arguments,
plus <var>objc</var>. If an error occurred, (RDB_int) RDB_ERROR is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION_ERROR
<dd><var>txp</var> must point to a running transaction (see above)
but does not.
<dt>RDB_INVALID_ARGUMENT_ERROR
<dd>A table appears twice as a target.
<dt>RDB_NOT_SUPPORTED_ERROR
<dd>A table is both source and target.
<dd>A virtual table appears as a target in <var>copyv</var>.
<dt>RDB_PREDICATE_VIOLATION_ERROR
<dd>A constraint has been violated.
</dl>

<p>The errors that can be raised by <a href="#insert">RDB_insert</a>,
<a href="#update">RDB_update</a>, <a href="#delete">RDB_delete</a> and <a
href="#copy_obj">RDB_copy_obj</a>  
can also be raised.

<hr>

<h2 id="join_tuples">RDB_join_tuples</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_join_tuples(const RDB_object *tpl1p, const RDB_object *tpl2p,
                RDB_exec_context *ecp, RDB_transaction *txp, RDB_object *restplp);
</pre>

<h3>Description</h3>

<p>RDB_join_tuples creates a tuple which contains the attributes
of the two tuples specified by <var>tpl1p</var> and <var>tpl2p</var>.

<p>If an error occurs, an error value is left in *<var>ecp</var>.

<h3>Return value</h3>

<p>RDB_OK on success, RDB_ERROR if an error occurred.

<h3>Errors</h3>

<dl>
<dt>RDB_TYPE_MISMATCH_ERROR
<dd>The two tuples have an attribute with the same name, but with
different types.
<dt>RDB_INVALID_ARGUMENT_ERROR
<dd>The two tuples have an attribute with the same name, but with
different values.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="project_tuple">RDB_project_tuple</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_project_tuple(const RDB_object *, int attrc, char *attrv[],
                  RDB_exec_context *ecp, RDB_object *restplp);
</pre>

<h3>Description</h3>

<p>RDB_project_tuple creates a tuple which contains only the attributes
specified by <var>attrc</var> and <var>attrv</var>.

<p>If an error occurs, an error value is left in *<var>ecp</var>.

<h3>Return value</h3>

<p>RDB_OK on success, RDB_ERROR if an error occurred.

<h3>Errors</h3>

<dl>
<dt>RDB_ATTRIBUTE_NOT_FOUND_ERROR
<dd>One of the attributes specified by <var>attrv</var> is not an attribute
of the original tuple.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="tuple_set">RDB_tuple_set</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_tuple_set(RDB_object *tplp, const char *name, const RDB_object *valp, RDB_exec_context *ecp);
</pre>

<h3>Description</h3>

<p>RDB_tuple_set sets the attribute <var>name</var> of the tuple
variable specified by <var>tplp</var> to the value specified by
<var>valp</var>.

<p>If an error occurs, an error value is left in *<var>ecp</var>.

<h3>Return value</h3>

<p>RDB_OK on success, RDB_ERROR if an error occurred.

<h3>Errors</h3>

<p>The call may fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="tuple_set_bool">RDB_tuple_set_bool</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_tuple_set_bool(RDB_object *tplp, const char *name, RDB_bool val, RDB_exec_context *ecp);
</pre>

<h3>Description</h3>

<p>RDB_tuple_set_bool sets the attribute <var>name</var> of the tuple
variable specified by <var>tplp</var> to the boolean value specified by
<var>val</var>.

<p>If an error occurs, an error value is left in *<var>ecp</var>.

<h3>Return value</h3>

<p>RDB_OK on success, RDB_ERROR if an error occurred.

<h3>Errors</h3>

<p>The call may fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="tuple_set_int">RDB_tuple_set_int</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_tuple_set_int(RDB_object *tplp, const char *name, RDB_int val, RDB_exec_context *ecp);
</pre>

<h3>Description</h3>

<p>RDB_tuple_set_int sets the attribute <var>name</var> of the tuple
variable specified by <var>tplp</var> to the integer value specified by
<var>val</var>.

<p>If an error occurs, an error value is left in *<var>ecp</var>.

<h3>Return value</h3>

<p>RDB_OK on success, RDB_ERROR if an error occurred.

<h3>Errors</h3>

<p>The call may fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="tuple_set_float">RDB_tuple_set_float</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_tuple_set_float(RDB_object *tplp, const char *name, RDB_float val, RDB_exec_context *ecp);
</pre>

<h3>Description</h3>

<p>RDB_tuple_set_int sets the attribute <var>name</var> of the tuple
variable specified by <var>tplp</var> to the value specified by
<var>val</var>.

<p>If an error occurs, an error value is left in *<var>ecp</var>.

<h3>Return value</h3>

<p>RDB_OK on success, RDB_ERROR if an error occurred.

<h3>Errors</h3>

<p>The call may fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="tuple_set_double">RDB_tuple_set_double</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_tuple_set_double(RDB_object *tplp, const char *name, RDB_double val, RDB_exec_context *ecp);
</pre>

<h3>Description</h3>

<p>RDB_tuple_set_int sets the attribute <var>name</var> of the tuple
variable specified by <var>tplp</var> to the value specified by
<var>val</var>.

<p>If an error occurs, an error value is left in *<var>ecp</var>.

<h3>Return value</h3>

<p>RDB_OK on success, RDB_ERROR if an error occurred.

<h3>Errors</h3>

<p>The call may fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="tuple_set_string">RDB_tuple_set_string</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_tuple_set_string(RDB_object *tplp, const char *name, const char *str, RDB_exec_context *ecp);
</pre>

<h3>Description</h3>

<p>RDB_tuple_set_int sets the attribute <var>name</var> of the tuple
variable specified by <var>tplp</var> to the string value specified by
<var>str</var>.

<p>If an error occurs, an error value is left in *<var>ecp</var>.

<h3>Return value</h3>

<p>RDB_OK on success, RDB_ERROR if an error occurred.

<h3>Errors</h3>

<p>The call may fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="tuple_size">RDB_tuple_size</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_int
RDB_tuple_size(const RDB_object *tplp);
</pre>

<h3>Description</h3>

<p>RDB_tuple_size determines the number of attributes of the tuple
specified by <var>tplp</var>.

<h3>Return value</h3>

<p>The number of attributes.

<hr>

<h2 id="tuple_attr_names">RDB_tuple_attr_names</h2>

<pre>
#include &lt;rel/rdb.h&gt;

void
RDB_tuple_attr_names(const RDB_object *, char **namev);
</pre>

<h3>Description</h3>

<p>RDB_tuple_attr_names fills <var>namev</var> with pointers to
the attribute names of the tuple specified by <var>tplp</var>.

<p><var>namev</var> must be large enough for all attribute names.
The pointers must not be modified by the caller and will become invalid
when the tuple is destroyed.

<h3>Return value</h3>

<p>None.

<hr>

<h2 id="tuple_get">RDB_tuple_get</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_object *
RDB_tuple_get(const RDB_object *, const char *name);
</pre>

<h3>Description</h3>

<p>RDB_tuple_get returns a pointer to a RDB_object structure
which contains the value for attribute <var>name</var>.
The value is not copied.

<h3>Return value</h3>

<p>A pointer to the value of the attribute, or NULL if no
attribute with that name exists.

<hr>

<h2 id="tuple_get_bool">RDB_tuple_get_bool</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_bool
RDB_tuple_get_bool(const RDB_object *, const char *name);
</pre>

<h3>Description</h3>

<p>RDB_tuple_get_bool returns the value of attribute <var>name</var>
as a RDB_bool. The attribute must exist and it must be of
type BOOLEAN.

<h3>Return value</h3>

<p>The attribute value.

<hr>

<h2 id="tuple_get_int">RDB_tuple_get_int</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_int
RDB_tuple_get_int(const RDB_object *, const char *name);
</pre>

<h3>Description</h3>

<p>RDB_tuple_get_int returns the value of attribute <var>name</var>
as a RDB_int. The attribute must exist and it must be of
type INTEGER.

<h3>Return value</h3>

<p>The attribute value.

<hr>

<h2 id="tuple_get_float">RDB_tuple_get_float</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_float
RDB_tuple_get_float(const RDB_object *, const char *name);
</pre>

<h3>Description</h3>

<p>RDB_tuple_get_double returns the value of attribute <var>name</var>
as a RDB_float. The attribute must exist and it must be of
type FLOAT.

<h3>Return value</h3>

<p>The attribute value.

<hr>

<h2 id="tuple_get_double">RDB_tuple_get_double</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_double
RDB_tuple_get_double(const RDB_object *, const char *name);
</pre>

<h3>Description</h3>

<p>RDB_tuple_get_double returns the value of attribute <var>name</var>
as a RDB_double. The attribute must exist and it must be of
type DOUBLE.

<h3>Return value</h3>

<p>The attribute value.

<hr>

<h2 id="tuple_get_string">RDB_tuple_get_string</h2>

<pre>
#include &lt;rel/rdb.h&gt;

char *
RDB_tuple_get_string(const RDB_object *, const char *name);
</pre>

<h3>Description</h3>

<p>RDB_tuple_get_string returns a pointer to the value of attribute
<var>name</var>. The attribute must exist and it must be of
type STRING.

<h3>Return value</h3>

<p>A pointer to the attribute value.

<hr>

<h2 id="extend_tuple">RDB_extend_tuple</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_extend_tuple(RDB_object *tplp, int attrc, const <a href="#virtual_attr">RDB_virtual_attr</a> attrv[],
                 RDB_exec_context *ecp, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_extend_tuple extends the tuple specified by <var>tplp</var>
by the attributes specified by <var>attrc</var> and <var>attrv</var>.

<p>If an error occurs, an error value is left in *<var>ecp</var>.

<h3>Return value</h3>

<p>RDB_OK on success, RDB_ERROR if an error occurred.

<h3>Errors</h3>

<dl>
<dt>RDB_ATTRIBUTE_NOT_FOUND_ERROR
<dd>One of the expressions specified in <var>updv</var> refers to an attribute
which does not exist in the tuple.
<dt>RDB_INVALID_ARGUMENT_ERROR
<dd>One of the additional attributes already exists in the original table.
<dt>RDB_OPERATOR_NOT_FOUND_ERROR
<dd>One of the expressions specified in <var>updv</var> refers to an
operator which does not exist.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="rename_tuple">RDB_rename_tuple</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_rename_tuple(const RDB_object *, int renc, const <a href="#renaming">RDB_renaming</a> renv[],
                 RDB_exec_context *ecp, RDB_object *restplp);
</pre>

<h3>Description</h3>

<p>RDB_rename_tuple creates copies the tuple specified by <var>tplp</var>
to the tuple specified by <var>restplp</var>, renaming the attributes
specified by <var>renc</var> and <var>renv</var>.

<p>If an error occurs, an error value is left in *<var>ecp</var>.

<h3>Return value</h3>

<p>RDB_OK on success, RDB_ERROR if an error occurred.

<h3>Errors</h3>

<p>The call may fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="wrap_tuple">RDB_wrap_tuple</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_wrap_tuple(const RDB_object *tplp, int wrapc, const <a href="#wrapping">RDB_wrapping</a> wrapv[],
               RDB_exec_context *ecp, RDB_object *restplp);
</pre>

<h3>Description</h3>

<p>RDB_wrap_tuple performs a tuple WRAP operator on the tuple pointed to by
<var>tplp</var> and stores the result in the variable pointed to by
<var>restplp</var>.

<p>If an error occurs, an error value is left in *<var>ecp</var>.

<h3>Return value</h3>

<p>RDB_OK on success, RDB_ERROR if an error occurred.

<h3>Errors</h3>

<dl>
<dt>RDB_ATTRIBUTE_NOT_FOUND_ERROR
<dd>One or more of the attributes specified by wrapv[i].attrv does not
exist.
</dl>

<hr>

<h2 id="unwrap_tuple">RDB_unwrap_tuple</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_unwrap_tuple(const RDB_object *tplp, int attrc, const char *attrv[],
        RDB_exec_context *ecp, RDB_object *restplp);
</pre>

<h3>Description</h3>

<p>RDB_unwrap_tuple performs a tuple UNWRAP operator on the tuple pointed to by
<var>tplp</var> and stores the result in the variable pointed to by
<var>restplp</var>.

<p>If an error occurs, an error value is left in *<var>ecp</var>.

<h3>Return value</h3>

<p>RDB_OK on success, RDB_ERROR if an error occurred.

<h3>Errors</h3>

<dl>
<dt>RDB_ATTRIBUTE_NOT_FOUND_ERROR
<dd>An attribute specified by attrv does not exist.
<dt>RDB_INVALID_ARGUMENT_ERROR
<dd>An attribute specified by attrv is not tuple-typed.
</dl>

<hr>

<h2 id="init_obj">RDB_init_obj</h2>

<pre>
#include &lt;rel/rdb.h&gt;

void
RDB_init_obj(RDB_object *valp);
</pre>

<h3>Description</h3>

<p>RDB_init_obj initializes the RDB_object structure pointed to by
<var>valp</var>. RDB_init_obj must be called before any other
operation can be performed on a RDB_object variable.

<hr>

<h2 id="destroy_obj">RDB_destroy_obj</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_destroy_obj(RDB_object *valp, RDB_exec_context *ecp);
</pre>

<h3>Description</h3>

<p>RDB_destroy_obj frees all resources associated with a RDB_object
variable.

<h3>Return value</h3>

<p>A pointer to the result table on success, or NULL if an error occurred.

<hr>

<h2 id="obj_equals">RDB_obj_equals</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_obj_equals(const RDB_object *, const RDB_object *, RDB_exec_context *ecp,
        RDB_transaction *txp, RDB_bool *resp);
</pre>

<h3>Description</h3>

<p>RDB_obj_equals checks two RDB_object variables for equality
and stores the result in the variable pointed to by <var>resp</var>.

<p>If an error occurs, an error value is left in *<var>ecp</var>.

<h3>Return value</h3>

<p>RDB_OK on success, RDB_ERROR if an error occurred.

<hr>

<h2 id="copy_obj">RDB_copy_obj</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_copy_obj(RDB_object *dstvalp, const RDB_object *srcvalp, RDB_exec_context *ecp);
</pre>

<h3>Description</h3>

<p>RDB_copy_obj copies the value of the RDB_object pointed to
by <var>srcvalp</var> to the RDB_object pointed to by <var>dstvalp</var>.

<p>The source RDB_object must either be newly initialized or of the same type
as the destination.

<p>If the target is newly initialized, then the following two cases
are handled in a special way:

<p>(1) If the source holds a named table, the target will refer to the same
table after the call.

<p>(2) If the source holds an unnamed virtual table, the virtual table
is duplicated.

<p>If both the source and the target hold a table, the tuples
are copied from the source to the target. In this case, both tables
must be local, because otherwise a transaction would be required.
<a href="#copy_table">RDB_copy_table</a> or
<a href="#multi_assign">RDB_multi_assign</a> can be used to copy
global tables.

<p>Currently, RDB_copy_obj is not supported for targets which hold
a virtual table.

<p>If an error occurs, an error value is left in *<var>ecp</var>.

<h3>Return value</h3>

<p>RDB_OK on success, RDB_ERROR if an error occurred.

<h3>Errors</h3>

<dl>
<dt>RDB_TYPE_MISMATCH_ERROR
<dd>The RDB_object specified by <var>dstvalp</var> is not newly initialized
and its type does not match the type of the RDB_object specified by
<var>srcvalp</var>.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>.

<h3>Notes</h3>

<p>If the object specified by <var>srcvalp</var> is table-valued,
the table is not copied. After RDB_obj_copy was invoked, the two
RDB_objects will share the same RDB_table.

<hr>

<h2 id="bool_to_obj">RDB_bool_to_obj</h2>

<pre>
#include &lt;rel/rdb.h&gt;

void
RDB_bool_to_obj(RDB_object *valp, RDB_bool v);
</pre>

<h3>Description</h3>

<p>RDB_bool_to_obj sets the RDB_object pointed to by <var>valp</var>
to the boolean value specified by <var>v</var>.

<p>The RDB_object must either be newly initialized or of type
BOOLEAN.

<hr>

<h2 id="int_to_obj">RDB_int_to_obj</h2>

<pre>
#include &lt;rel/rdb.h&gt;

void
RDB_int_to_obj(RDB_object *valp, RDB_int v);
</pre>

<h3>Description</h3>

<p>RDB_int_to_obj sets the RDB_object pointed to by <var>valp</var>
to the integer value specified by <var>v</var>.

<p>The RDB_object must either be newly initialized or of type
INTEGER.

<hr>

<h2 id="float_to_obj">RDB_float_to_obj</h2>

<pre>
#include &lt;rel/rdb.h&gt;

void
RDB_float_to_obj(RDB_object *valp, RDB_float v);
</pre>

<h3>Description</h3>

<p>RDB_float_to_obj sets the RDB_object pointed to by <var>valp</var>
to the RDB_float value specified by <var>v</var>.

<p>The RDB_object must either be newly initialized or of type
FLOAT.

<h2 id="double_to_obj">RDB_double_to_obj</h2>

<pre>
#include &lt;rel/rdb.h&gt;

void
RDB_double_to_obj(RDB_object *valp, RDB_double v);
</pre>

<h3>Description</h3>

<p>RDB_double_to_obj sets the RDB_object pointed to by <var>valp</var>
to the RDB_double value specified by <var>v</var>.

<p>The RDB_object must either be newly initialized or of type
DOUBLE.

<hr>

<h2 id="string_to_obj">RDB_string_to_obj</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_string_to_obj(RDB_object *valp, const char *str, RDB_exec_context *ecp);
</pre>

<h3>Description</h3>

<p>RDB_string_to_obj sets the RDB_object pointed to by <var>valp</var>
to the string value specified by <var>str</var>.

<p>The RDB_object must either be newly initialized or of type
STRING.

<h3>Return value</h3>

<p>RDB_OK on success, RDB_ERROR if an error occurred.

<hr>

<h2 id="obj_bool">RDB_obj_bool</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_bool
RDB_obj_bool(const RDB_object *valp);
</pre>

<h3>Description</h3>

<p>RDB_obj_bool returns the value of the RDB_object pointed to by
<var>valp</var> as a RDB_bool. The RDB_object must be of type
BOOLEAN.

<h3>Return value</h3>

<p>The value of the RDB_object.

<hr>

<h2 id="obj_int">RDB_obj_int</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_int
RDB_obj_int(const RDB_object *valp);
</pre>

<h3>Description</h3>

<p>RDB_obj_int returns the value of the RDB_object pointed to by
<var>valp</var> as a RDB_int. The RDB_object must be of type
INTEGER.

<h3>Return value</h3>

<p>The value of the RDB_object.

<hr>

<h2 id="obj_float">RDB_obj_float</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_float
RDB_obj_float(const RDB_object *valp);
</pre>

<h3>Description</h3>

<p>RDB_obj_float returns the value of the RDB_object pointed to by
<var>valp</var> as a RDB_float. The RDB_object must be of type
FLOAT.

<h3>Return value</h3>

<p>The value of the RDB_object.

<hr>

<h2 id="obj_double">RDB_obj_double</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_double
RDB_obj_double(const RDB_object *valp);
</pre>

<h3>Description</h3>

<p>RDB_obj_double returns the value of the RDB_object pointed to by
<var>valp</var> as a RDB_double. The RDB_object must be of type
DOUBLE.

<h3>Return value</h3>

<p>The value of the RDB_object.

<hr>

<h2 id="obj_string">RDB_obj_string</h2>

<pre>
#include &lt;rel/rdb.h&gt;

char *
RDB_obj_string(const RDB_object *valp);
</pre>

<h3>Description</h3>

<p>RDB_obj_string returns a pointer to the value of the RDB_object pointed to by
<var>valp</var> as a char *. The RDB_object must be of type STRING.

<h3>Return value</h3>

<p>The string value of the RDB_object.

<hr>

<h2 id="obj_type">RDB_obj_type</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_type *
RDB_obj_type(const RDB_object *objp)
</pre>

<h3>Description</h3>

<p>RDB_obj_type returns a pointer to the type of *<var>objp</var>.

<h3>Return value</h3>

<p>A pointer to the type of the RDB_object.

<hr>

<h2 id="obj_comp">RDB_obj_comp</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_obj_comp(const RDB_object *valp, const char *compname,
             RDB_object *comp, RDB_exec_context *ecp, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_obj_comp copies the value of component <var>compname</var>
of a possible representation of the variable pointed to by <var>valp</var>
to the variable pointed to by <var>comp</var>.

<p>If an error occurs, an error value is left in *<var>ecp</var>.

<h3>Return value</h3>

<p>RDB_OK on success, RDB_ERROR if an error occurred.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_ARGUMENT_ERROR
<dd>The type of *<var>valp</var> is not scalar, or it does not
have a possible representation with a component <var>compname</var>.
<dt>RDB_OPERATOR_NOT_FOUND_ERROR
<dd>The getter method for component <var>compname</var> has not been created.
</dl>

<p>RDB_obj_comp may also raise an error raised by a
user-provided getter function.

<p>The call may also fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="obj_set_comp">RDB_obj_set_comp</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_obj_set_comp(RDB_object *valp, const char *compname,
                 const RDB_object *comp, RDB_exec_context *ecp, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_obj_set_comp sets the the value of component <var>compname</var>
of a possible representation of the RDB_object specified to by <var>valp</var>
to the value of the variable pointed to by <var>comp</var>.

<p>The RDB_object must be of a type which has a component
<var>compname</var>.

<p>If an error occurs, an error value is left in *<var>ecp</var>.

<h3>Return value</h3>

<p>RDB_OK on success, RDB_ERROR if an error occurred.

<hr>

<h2 id="binary_set">RDB_binary_set</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_binary_set(RDB_object *, size_t pos, const void *srcp, size_t len, RDB_exec_context *ecp);
</pre>

<h3>Description</h3>

<p>RDB_binary_set copies <var>len</var> bytes from srcp to
the position <var>pos</var> in the RDB_object pointed to by <var>valp</var>.
<var>valp</var> must point either to a new initialized RDB_object
or to a RDB_object of type BINARY.

<p>If an error occurs, an error value is left in *<var>ecp</var>.

<h3>Return value</h3>

<p>RDB_OK on success, RDB_ERROR if an error occurred.

<h3>Errors</h3>

<p>The call may fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="append_string">RDB_append_string</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_append_string(RDB_object *objp, const char *str, RDB_exec_context *ecp);
</pre>

<h3>Description</h3>

<p>Appends the string <var>str</var> to *<var>objp</var>.

<p>*<var>objp</var> must be of type STRING.

<h3>Return value</h3>

<p>RDB_OK on success, RDB_ERROR if an error occurred.

<h3>Errors</h3>

<p>The call may fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="binary_get">RDB_binary_get</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_binary_get(const RDB_object *, size_t pos, RDB_exec_context *ecp,
        void **pp, size_t len, size_t *alenp);
</pre>

<h3>Description</h3>

<p>RDB_binary_get obtains a pointer to <var>len</var> bytes starting at position
<var>pos</var> of the RDB_object pointed to by <var>valp</var>
and stores this pointer at the location pointed to by <var>pp</var>.
If the sum of <var>pos</var> and <var>len</var> exceeds the length of the
object, the length of the byte block will be lower than requested.

<p>If <var>alenp</var> is not NULL, the actual length of the byte block is stored
at the location pointed to by <var>alenp</var>.

<p><var>valp</var> must point to a RDB_object of type BINARY.

<h3>Return value</h3>

<p>RDB_OK on success, RDB_ERROR if an error occurred.

<h3>Errors</h3>

<p>The call may fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="binary_length">RDB_binary_length</h2>

<pre>
#include &lt;rel/rdb.h&gt;

size_t
RDB_binary_length(const RDB_object *valp);
</pre>

<h3>Description</h3>

<p>RDB_binary_length determines the number of bytes stored in the
RDB_object pointed to by <var>valp</var>. The RDB_object
must be of type BINARY.

<h3>Return value</h3>

<p>The length of the RDB_object.

<hr>

<h2 id="obj_irep">RDB_obj_irep</h2>

<pre>
#include &lt;rel/typeimpl.h&gt;

void *
RDB_obj_irep(RDB_object *valp, size_t *lenp);
</pre>

<h3>Description</h3>

<p>RDB_obj_irep returns a pointer to the binary internal representation of
the variable specified by <var>valp</var>.
If lenp is not NULL, the size of the internal representation
is stored at the location pointed to by <var>lenp</var>.

<p>RDB_obj_irep only works types with a binary internal representation.
These are built-in types and user-defined types
which use a built-in type or a byte array as actual representation.

<h3>Return value</h3>

<p>A pointer to the internal representation.

<hr>

<h2 id="create_db_from_env">RDB_create_db_from_env</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_database *
RDB_create_db_from_env(const char *name, RDB_environment *envp, RDB_exec_context *ecp);
</pre>

<h3>Description</h3>

<p>RDB_create_db_from_env creates a database from a database environment.
If an error occurs, an error value is left in <var>ecp</var>.

<h3>Return value</h3>

<p>A pointer to the newly created database, or NULL if an error occurred.

<h3>Errors</h3>

<dl>
<dt>RDB_ELEMENT_EXIST_ERROR
<dd>A database with the name <var>name</var> already exixts.
<dt>RDB_VERSION_MISMATCH_ERROR
<dd>The version number stored in the catalog does not match
the version of the library.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="get_db_from_env">RDB_get_db_from_env</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_database *
RDB_get_db_from_env(const char *name, RDB_environment *envp, RDB_exec_context *ecp);
</pre>

<h3>Description</h3>

<p>RDB_get_db_from_env obtains a pointer to the database with name
<var>name</var> in the environment specified by <var>envp</var>.
If an error occurs, an error value is left in <var>ecp</var>.

<h3>Return value</h3>

<p>On success, a pointer to the database is returned. If an error occurred, NULL is
returned.

<h3>Errors</h3>

<dl>
<dt>RDB_NOT_FOUND_ERROR
<dd>A database with the name <var>name</var> could not be found.
<dt>RDB_VERSION_MISMATCH_ERROR
<dd>The version number stored in the catalog does not match
the version of the library.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="drop_db">RDB_drop_db</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_drop_db(RDB_database *dbp, RDB_exec_context *ecp);
</pre>

<h3>Description</h3>

<p>RDB_drop_db deletes the database specified by <var>dbp</var>.
The database must be empty.

<p>If an error occurs, an error value is left in <var>ecp</var>.

<h3>Return value</h3>

<p>RDB_OK on success, RDB_ERROR if an error occurred.

<h3>Errors</h3>

<dl>
<dt>RDB_NOT_FOUND_ERROR
<dd>The database was not found.
<dt>RDB_ELEMENT_EXISTS_ERROR
<dd>The database is not empty.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="db_name">RDB_db_name</h2>

<pre>
#include &lt;rel/rdb.h&gt;

char *
RDB_db_name(RDB_database *dbp)
</pre>

<h3>Description</h3>

<p>RDB_db_name returns a pointer to the name of the database
specified by <var>dbp</var>.

<h3>Return value</h3>

<p>The name of the database.

<hr>

<h2 id="db_env">RDB_db_env</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_environment *
RDB_db_env(RDB_database *dbp);
</pre>

<h3>Description</h3>

<p>RDB_db_env returns a pointer to the database environment of the database
specified by <var>dbp</var>.

<h3>Return value</h3>

<p>A pointer to the database environment.

<hr>

<h2 id="begin_tx">RDB_begin_tx</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_begin_tx(RDB_exec_context *ecp, RDB_transaction *txp, RDB_database *dbp,
        RDB_transaction *parentp);
</pre>

<h3>Description</h3>

<p>RDB_begin_tx starts a transaction which interacts with the
database specified by <var>dbp</var>.

<p>If <var>parentp</var> is not NULL, the new transaction is
a subtransaction of the transaction specified by <var>parentp</var>.

<p>The execution of a parent transaction is suspended while a child
transaction executes. It is an error to perform an operation under
the control of a transaction which has a running child transaction.

<h3>Return value</h3>

<p>RDB_OK on success, RDB_ERROR if an error occurred.

<p>The call may fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="commit">RDB_commit</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_commit(RDB_exec_context *ecp, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_commit commits the transaction pointed to by <var>txp</var>.

<h3>Return value</h3>

<p>RDB_OK on success, RDB_ERROR if an error occurred.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION_ERROR
<dd><var>txp</var> does not point to a running transaction.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="rollback">RDB_rollback</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_rollback(RDB_exec_context *ecp, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_rollback terminates the transaction pointed to by <var>txp</var>
and rolls back all changes made by this transaction and its subtransactions.

<h3>Return value</h3>

<p>RDB_OK on success, RDB_ERROR if an error occurred.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION_ERROR
<dd><var>txp</var> does not point to a running transaction.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="tx_db">RDB_tx_db</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_database *
RDB_tx_db(RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_tx_db determines the database the transaction pointed
to by <var>txp</var> interacts with.

<h3>Return value</h3>

<p>A pointer to the RDB_database structure that represents the database.

<hr>

<h2 id="tx_is_running">RDB_tx_is_running</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_bool
RDB_tx_is_running(RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_tx_is_running determines if <var>txp</var> points to a running
transaction.

<h3>Return value</h3>

<p>RDB_TRUE if the transaction is running, RDB_FALSE otherwise.

<hr>

<h2 id="table_to_array">RDB_table_to_array</h2>

<pre>
#include &lt;rel/rdb.h&gt;

typedef struct {
    char *attrname;
    RDB_bool asc;
} RDB_seq_item;

int
RDB_table_to_array(RDB_object *arrp, RDB_table *tbp,
                   int seqitc, const RDB_seq_item seqitv[],
                   RDB_exec_context *ecp, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_table_to_array creates an array which contains
all tuples from the table specified by <var>tbp</var>.
If <var>seqitc</var> is zero, the order of the tuples is undefined.
If <var>seqitc</var> is greater than zero, the order of the tuples
is specified by <var>seqitv</var>.


<h3>Return value</h3>

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION_ERROR
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_OPERATOR_NOT_FOUND_ERROR
<dd>The definition of the table specified by <var>tbp</var>
refers to a non-existing operator.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction may be implicitly rolled back.

<h3>Notes</h3>

<p>An array created by RDB_table_to_array becomes invalid after the
end of the transaction in which it was created.

<p>The table from which an array was created must not be dropped before
the array is destroyed.

<hr>

<h2 id="array_get">RDB_array_get</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_object *
RDB_array_get(RDB_object *, RDB_int idx, RDB_exec_context *ecp);
</pre>

<h3>Description</h3>

<p>RDB_array_get stores a pointer to the RDB_object at index <var>idx</var>
at the location pointed to by <var>tplpp</var>. This pointer may become
invalid after the next invocation of RDB_array_get.
The pointer will become invalid when the array is destroyed.

<h3>Return value</h3>

<p>RDB_OK on success, RDB_ERROR if an error occurred.

<h3>Errors</h3>

<dl>
<dt>RDB_NOT_FOUND_ERROR
<dd><var>idx</var> exceeds the array length.
<dt>RDB_OPERATOR_NOT_FOUND_ERROR
<dd>The array was created from a table which refers to a non-existing
operator.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="array_set">RDB_array_set</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_array_set(RDB_object *, RDB_int idx, const RDB_object *objp, RDB_exec_context *ecp);
</pre>

<h3>Description</h3>

<p>RDB_array_set copies the RDB_object pointed to by tplp
into the RDB_object at index <var>idx</var>.

<p>RDB_array_set is not supported for arrays which have been created
using RDB_table_to_array.

<h3>Return value</h3>

<p>RDB_OK on success, RDB_ERROR if an error occurred.

<h3>Errors</h3>

<dl>
<dt>RDB_NOT_FOUND_ERROR
<dd><var>idx</var> exceeds the array length.
<dt>RDB_NOT_SUPPORTED_ERROR
<dd>The table has been created using RDB_table_to_array.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="array_length">RDB_array_length</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_int
RDB_array_length(RDB_object *);
</pre>

<h3>Description</h3>

<p>RDB_array_length determines the length of an array.

<h3>Return value</h3>

<p>The length of the array. A return code lower than zero
indicates an error.

<h3>Errors</h3>

<dl>
<dt>RDB_OPERATOR_NOT_FOUND_ERROR
<dd>The array was created from a table which refers to a non-existing
operator.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="set_array_length">RDB_set_array_length</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_set_array_length(RDB_object *arrp, RDB_int len, RDB_exec_context *ecp);
</pre>

<h3>Description</h3>

<p>RDB_set_array_length sets the length of the array specified by
<var>arrp</var>.

<p>RDB_array_set is not supported for arrays which have been created
using RDB_table_to_array.

<h3>Return value</h3>

<p>RDB_OK on success, RDB_ERROR if an error occurred.

<h3>Errors</h3>

<dl>
<dt>RDB_NOT_SUPPORTED_ERROR
<dd>The array has been created using RDB_table_to_array.
</dl>

<hr>

<h2 id="add_arg">RDB_add_arg</h2>

<pre>
#include &lt;rel/rdb.h&gt;

void
RDB_add_arg(RDB_expression *exp, RDB_expression *argp);
</pre>

<h3>Description</h3>

<p>RDB_add_arg adds the child expression *<var>argp</var>
to the expression *<var>exp</var>.
*<var>exp</var> must represent a read-only operator invocation.
<a href="#ro_op">RDB_ro_op</a> should be used to create
such an expression.

<p>To obtain a valid expression representing a read-only
operator invocation, RDB_add_arg must be called once
for each argument of the operator.

<hr>

<h2 id="expr_is_const">RDB_expr_is_const</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_bool
RDB_expr_is_const(const RDB_expression *);
</pre>

<h3>Description</h3>

<p>RDB_expr_is_const determines if the expression is a constant expression.

<h3>Return value</h3>

<p>RDB_TRUE if the expression is a constant expression, RDB_FALSE otherwise.

<h3>Errors</h3>

<hr>

<h2 id="bool_to_expr">RDB_bool_to_expr</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_expression *
RDB_bool_to_expr(RDB_bool, RDB_exec_context *ecp);
</pre>

<h3>Description</h3>

<p>RDB_bool_to_expr creates a constant expression of type BOOLEAN.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="int_to_expr">RDB_int_to_expr</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_expression *
RDB_int_to_expr(RDB_int, RDB_exec_context *ecp);
</pre>

<h3>Description</h3>

<p>RDB_int_to_expr creates a constant expression of type INTEGER.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="float_to_expr">RDB_float_to_expr</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_expression *
RDB_float_to_expr(RDB_float, RDB_exec_context *ecp);
</pre>

<h3>Description</h3>

<p>RDB_float_to_expr creates a constant expression of type FLOAT.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="double_to_expr">RDB_double_to_expr</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_expression *
RDB_double_to_expr(RDB_double, RDB_exec_context *ecp);
</pre>

<h3>Description</h3>

<p>RDB_double_to_expr creates a constant expression of type DOUBLE.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="string_to_expr">RDB_string_to_expr</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_expression *
RDB_string_to_expr(const char *, RDB_exec_context *ecp);
</pre>

<h3>Description</h3>

<p>RDB_string_to_expr creates a constant expression of type STRING.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="table_ref">RDB_table_ref</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_expression *
RDB_table_ref(RDB_object *tbp, RDB_exec_context *);
</pre>

<h3>Description</h3>

<p>RDB_table_ref creates an expression which refers to a table.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="obj_to_expr">RDB_obj_to_expr</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_expression *
RDB_obj_to_expr(const RDB_object *valp, RDB_exec_context *ecp);
</pre>

<h3>Description</h3>

<p>RDB_obj_to_expr creates a constant expression from a RDB_object.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="expr_var">RDB_expr_var</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_expression *
RDB_expr_var(const char *attrname, RDB_exec_context *ecp);
</pre>

<h3>Description</h3>

<p>RDB_expr_var creates an expression that refers to a variable.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="eq">RDB_eq</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_expression *
RDB_eq(RDB_expression *, RDB_expression *, RDB_exec_context *ecp);
</pre>

<h3>Description</h3>

<p>RDB_eq creates an expression that represents an "is equal" operator.
If one of the arguments is NULL, NULL is returned.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="table_to_expr">RDB_table_to_expr</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_expression *
RDB_table_to_expr(RDB_table *, RDB_exec_context *ecp);
</pre>

<h3>Description</h3>

<p>RDB_table_to_expr creates an expression that represents a table.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="tuple_attr">RDB_tuple_attr</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_expression *
RDB_tuple_attr(RDB_expression *, const char *attrname, RDB_exec_context *ecp);
</pre>

<h3>Description</h3>

<p>RDB_tuple_attr creates an expression that represents a tuple attribute
extraction.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="expr_any">RDB_expr_any</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_expression *
RDB_expr_any(RDB_expression *, const char *attrname, RDB_exec_context *ecp);
</pre>

<h3>Description</h3>

<p>RDB_expr_any creates an expression which represents the <a
href="#any">RDB_any</a> operator.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="expr_all">RDB_expr_all</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_expression *
RDB_expr_all(RDB_expression *, const char *attrname, RDB_exec_context *ecp);
</pre>

<h3>Description</h3>

<p>RDB_expr_all creates an expression which represents the <a
href="#all">RDB_all</a> operator.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="expr_avg">RDB_expr_avg</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_expression *
RDB_expr_avg(RDB_expression *, const char *attrname, RDB_exec_context *ecp);
</pre>

<h3>Description</h3>

<p>RDB_expr_avg creates an expression which represents the <a
href="#avg">RDB_avg</a> operator.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="expr_max">RDB_expr_max</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_expression *
RDB_expr_max(RDB_expression *, const char *attrname, RDB_exec_context *ecp);
</pre>

<h3>Description</h3>

<p>RDB_expr_max creates an expression which represents the <a
href="#max">RDB_max</a> operator.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="expr_min">RDB_expr_min</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_expression *
RDB_expr_min(RDB_expression *, const char *attrname, RDB_exec_context *ecp);
</pre>

<h3>Description</h3>

<p>RDB_expr_min creates an expression which represents the <a
href="#min">RDB_min</a> operator.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="expr_sum">RDB_expr_sum</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_expression *
RDB_expr_sum(RDB_expression *, const char *attrname, RDB_exec_context *ecp);
</pre>

<h3>Description</h3>

<p>RDB_expr_sum creates an expression which represents the <a
href="#sum">RDB_sum</a> operator.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="expr_comp">RDB_expr_comp</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_expression *
RDB_expr_comp(RDB_expression *arg, const char *compname, RDB_exec_context *ecp);
</pre>

<h3>Description</h3>

<p>RDB_expr_comp creates an expression which evaluates to a
possible representation component.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="ro_op">RDB_ro_op</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_expression *
RDB_ro_op(const char *opname, int argc, RDB_exec_context *ecp);
</pre>

<h3>Description</h3>

<p>RDB_ro_op creates an expression which represents the invocation
of a readonly operator.

<p>If <var>argc</var> is greater than zero, the arguments must
be added using <a href="#add_arg">RDB_add_arg</a> to obtain
a valid expression.

<h3>Return value</h3>

<p>On success, a pointer to the newly created expression is returned.
If the expression could not be created due to insufficient memory,
NULL is returned and an error is left in *<var>ecp</var>.

<hr>

<h2 id="drop_expr">RDB_drop_expr</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_drop_expr(RDB_expression *exp, RDB_exec_context *ecp);
</pre>

<h3>Description</h3>

<p>RDB_drop_expr destroys the expression specified to by <var>exp</var>
(including all subexpressions) and frees all resources associated with it.

<h3>Return value</h3>

<p>RDB_OK on success, RDB_ERROR on failure.

<h3>Errors</h3>

<p>The call may fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="define_type">RDB_define_type</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_define_type(const char *name, int repc, const <a href="#possrep">RDB_possrep</a> repv[],
                RDB_expression *constraintp, RDB_exec_context *ecp, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_define_type defines a type with the name <var>name</var> and
<var>repc</var> possible representations.
The individual possible representations are
described by the elements of <var>repv</var>.

<p>If <var>constraintp</var> is not NULL, it specifies the type constraint.
When the constraint is evaluated, the value to check is made available
as an attribute with the same name as the type.

<h3>Return value</h3>

<p>RDB_OK on success, RDB_ERROR if an error occurred.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION_ERROR
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_ELEMENT_EXIST_ERROR
<dd>There is already a type with name <var>name</var>.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction may be implicitly rolled back.

<hr>

<h2 id="implement_type">RDB_implement_type</h2>

<pre>
#include &lt;rel/typeimpl.h&gt;

int
RDB_implement_type(const char *name, RDB_type *arep, RDB_int areplen,
        RDB_exec_context *ecp, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_implement_type implements the user-defined type with name
<var>name</var>. The type must have been defined previously using
RDB_define_type. After RDB_implement_type was inkoved successfully,
this type may be used for local variables and table attributes.

<p>If <var>arep</var> is not NULL, it must point to a type which is used
as the actual representation. The getter, setter, and selector operators
must be provided by the caller.

<p>If <var>arep</var> is NULL and <var>areplen</var> is not -1,
<var>areplen</var> specifies the length, in bytes,
of the actual representation, which then is a fixed-length array of bytes.
The getter, setter, and selector operators
must be provided by the caller.

<p>If <var>arep</var> is NULL and <var>areplen</var> is -1,
the getter and setter operators and the selector operator are provided by Duro.
In this case, the type must have exactly one possible representation,
and this representation becomes the actual representation.

<p>For user-provided setters, getters, and selectors,
the following conventions apply:

<dl>
<dt>Selectors
<dd>A selector is a read-only operator whose name is is the name of a possible
representation. It takes one argument for each component.
<dt>Getters
<dd>A getter is a read-only operator whose name consists of the
type and a component name, separated by "_get_".
It takes one argument. The argument must be of the user-defined type in question.
The return type must be the component type.
<dt>Setters
<dd>A setter is an update operator whose name consists of the
type and a component name, separated by "_set_".
It takes two arguments. The first argument is an update argument
and must be of the user-defined type in question.
The second argument is read-only and must be of the type of
the component.
</dl>

<h3>Return value</h3>

<p>On success, RDB_OK is returned. Any other return value indicates an error.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION_ERROR
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_NOT_FOUND_ERROR
<dd>The type has not been previously defined.
<dt>RDB_INVALID_ARGUMENT_ERROR
<dd><var>arep</var> is NULL and <var>areplen</var> is -1,
and the type was defined with more than one possible representation.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction may be implicitly rolled back.

<hr>

<h2 id="create_tuple_type">RDB_create_tuple_type</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_type *
RDB_create_tuple_type(int attrc, const <a href="#attr">RDB_attr</a> attrv[], RDB_exec_context *ecp);
</pre>

<h3>Description</h3>

<p>RDB_create_tuple_type creates a tuple type and stores
a pointer to the type at the location pointed to by <var>typp</var>.
The attributes are specified by <var>attrc</var> and <var>attrv</var>.
The fields defaultp and options of RDB_attr are ignored.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. Any other return value indicates an error.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_ARGUMENT_ERROR
<dd><var>attrv</var> contains two attributes with the same name.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="create_array_type">RDB_create_array_type</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_type *
RDB_create_array_type(RDB_type *typ);
</pre>

<h3>Description</h3>

<p>RDB_create_array_type creates an array type.
The base type is specified by <var>typ</var>.

<h3>Return value</h3>

<p>The new array type, or NULL if the creation failed due to insufficient memory.

<hr>

<h2 id="create_relation_type">RDB_create_relation_type</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_type *
RDB_create_relation_type(int attrc, const <a href="#attr">RDB_attr</a> attrv[],
        RDB_exec_context *ecp);
</pre>

<h3>Description</h3>

<p>RDB_create_relation_type creates a relation type and stores
a pointer to the type at the location pointed to by <var>typp</var>.
The attributes are specified by <var>attrc</var> and <var>attrv</var>.
The fields defaultp and options of RDB_attr are ignored.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, RDB_ERROR is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_ARGUMENT_ERROR
<dd><var>attrv</var> contains two attributes with the same name.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="get_type">RDB_get_type</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_type *
RDB_get_type(const char *name, RDB_transaction *, RDB_exec_context *ecp);
</pre>

<h3>Description</h3>

<p>RDB_get_type obtains a pointer to RDB_type structure which
represents the type with the name <var>name</var>
and stores that pointer at the location pointed to by <var>typp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. Any other return value indicates an error.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION_ERROR
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_NOT_FOUND_ERROR
<dd>A type with the name <var>name</var> could not be found.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction may be implicitly rolled back.

<hr>

<h2 id="drop_type">RDB_drop_type</h2>

<pre>
#include &lt;rel/rdb.h&gt;

void
RDB_drop_type(RDB_type *typ, RDB_exec_context *ecp, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_drop_type destroys the type specified by <var>typ</var>.

<p>If the type is a scalar user-defined type, it is deleted from the
database.

<p>If the type is non-scalar, the argument <var>txp</var> is ignored.

<p>It is not possible to destroy built-in types.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. Any other return value indicates an error.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION_ERROR
<dd>The type is scalar and <var>txp</var> does not point to a running transaction.
<dt>RDB_INVALID_ARGUMENT_ERROR
<dd>The type is a builtin type.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction may be implicitly rolled back.

<hr>

<h2 id="type_attrs">RDB_type_attrs</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_attr *
RDB_type_attrs(RDB_type *typ, int *attrcp);
</pre>

<h3>Description</h3>

<p>RDB_type_attrs returns a pointer to an array of
<a href="#attr">RDB_attr</a> structures
describing the attributes of the tuple or relation type
specified by *<var>typ</var> and stores the number of attributes in
*<var>attrcp</var>.

<h3>Return value</h3>

<p>A pointer to an array of RDB_attr structures or NULL if the type
is not a tuple or relation type.

<hr>

<h2 id="type_name">RDB_type_name</h2>

<pre>
#include &lt;rel/rdb.h&gt;

char *
RDB_type_name(const RDB_type *);
</pre>

<h3>Description</h3>

<p>RDB_type_name returns the name of a type.

<h3>Return value</h3>

<p>A pointer to the name of the type or NULL if the type has no name.

<hr>

<h2 id="type_is_scalar">RDB_type_is_scalar</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_bool
RDB_type_is_scalar(const RDB_type *);
</pre>

<h3>Description</h3>

<p>RDB_type_is_scalar checks if a type is scalar.

<h3>Return value</h3>

<p>RDB_TRUE if the type is scalar, RDB_FALSE otherwise.

<hr>

<h2 id="type_is_numeric">RDB_type_is_numeric</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_bool
RDB_type_is_numeric(const RDB_type *);
</pre>

<h3>Description</h3>

<p>RDB_type_is_numeric checks if a type is numeric.

<h3>Return value</h3>

<p>RDB_TRUE if the type is INTEGER, FLOAT, or DOUBLE, RDB_FALSE otherwise.

<hr>

<h2 id="type_equals">RDB_type_equals</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_bool
RDB_type_equals(const RDB_type *, const RDB_type *);
</pre>

<h3>Description</h3>

<p>RDB_type_equals checks if two types are equal.

<p>Nonscalar types are equal if there definition is the same.

<h3>Return value</h3>

<p>RDB_TRUE if the types are equal, RDB_FALSE otherwise.

<hr>

<h2 id="create_ro_op">RDB_create_ro_op</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_create_ro_op(const char *name, int argc, RDB_type *argtv[], RDB_type *rtyp,
                 const char *libname, const char *sym,
                 const void *iargp, size_t iarglen,
                 RDB_exec_context *ecp, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_create_ro_op creates a read-only operator with name <var>name</var>.
The argument types are specified by <var>argc</var> and <var>argtv</var>.

<p>To execute the operator, Duro will execute the function specified by
<var>sym</var> from the library specified by <var>libname</var>.

<p>The name of the library must be passed without the file extension.

<p>This function must have the following signature:

<pre>
int
&lt;sym&gt;(const char *name, int argc, RDB_object *argv[],
          const void *iargp, size_t iarglen, RDB_exec_context *ecp, RDB_transaction *txp,
          RDB_object *retvalp)
</pre>

<p>When the function is executed, the name of the operator is passed through <var>name</var>
and the arguments are passed through <var>argc</var> and <var>argv</var>.

<p>The function specified by <var>sym</var> must store the result at the
location specified by <var>retvalp</var> and return RDB_OK.
It can indicate an error condition by leaving an error in *<var>ecp</var>
(see <a href="#raise_err">RDB_raise_err</a>)
and returning RDB_ERROR.

<p>If <var>iargp</var> is not NULL, it must point to a byte block
of length <var>iarglen</var> which will be passed to the function
specified by <var>sym</var>.
This can be used to pass code to an interpreter function.

<p>Overloading operators is possible.

<p>Array-valued argument and return types are not supported.

<h3>Return value</h3>

<p>RDB_OK on success, RDB_ERROR if an error occurred.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION_ERROR
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_ELEMENT_EXIST_ERROR
<dd>A read-only operator with this name and signature does already exist.
<dt>RDB_NOT_SUPPORTED_ERROR
<dd>One of the argument types or the return type is an array type.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction may be implicitly rolled back.

<hr>

<h2 id="create_update_op">RDB_create_update_op</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_create_update_op(const char *name, int argc, RDB_type *argtv[],
                  RDB_bool upd[], const char *libname, const char *sym,
                  const void *iargp, size_t iarglen,
                  RDB_exec_context *ecp, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_create_update_op creates an update operator with name <var>name</var>.
The argument types are specified by <var>argc</var> and <var>argtv</var>.

<p>The argument <var>upd</var> specifies which of the arguments are updated.
If upd[<em>i</em>] is RDB_TRUE, this indicates that the <em>i</em>th argument
is updated by the operator.

<p>To execute the operator, Duro will execute the function specified by
<var>sym</var> from the library specified by <var>libname</var>.

<p>The name of the library must be passed without the file extension.

<p>This function must have the following signature:

<pre>
int
&lt;sym&gt;(const char *name, int argc, RDB_object *argv[],
        RDB_bool updv[], const void *iargp, size_t iarglen,
        RDB_exec_context *ecp, RDB_transaction *txp)

</pre>

<p>When the function is executed, the name of the operator is passed through <var>name</var>
and the arguments are passed through <var>argc</var> and <var>argv</var>.

<p>On success, the function specified by <var>sym</var> must return RDB_OK.
It can indicate an error condition by leaving an error in *<var>ecp</var>
(see <a href="#raise_err">RDB_raise_err</a> and related functions)
and returning RDB_ERROR.

<p>If <var>iargp</var> is not NULL, it must point to a byte block
of length <var>iarglen</var> which will be passed to the function
specified by <var>sym</var>.
This can be used to pass code to an interpreter function.

<p>Overloading operators is possible.

<p>Array-valued argument types are not supported.

<h3>Return value</h3>

<p>RDB_OK on success, RDB_ERROR if an error occurred.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION_ERROR
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_ELEMENT_EXIST_ERROR
<dd>An update operator with this name and signature does already exist.
<dt>RDB_NOT_SUPPORTED_ERROR
<dd>One of the argument types is an array type.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction may be implicitly rolled back.

<hr>

<h2 id="call_ro_op">RDB_call_ro_op</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_call_ro_op(const char *name, int argc, RDB_object *argv[],
               RDB_exec_context *ecp, RDB_transaction *txp, RDB_object *retvalp);
</pre>

<h3>Description</h3>

<p>RDB_call_ro_op invokes the read-only operator with the name <var>name</var>,
passing the arguments in <var>argc</var> and <var>argv</var>.

<p>The result will be stored at the location pointed to by
<var>retvalp</var>. 

<h3>Return value</h3>

<p>RDB_OK on success, RDB_ERROR if an error occurred.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION_ERROR
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_OPERATOR_NOT_FOUND_ERROR
<dd>A read-only operator that matches the name and argument types could not be
found.
<dt>RDB_TYPE_MISMATCH_ERROR
<dd>A read-only operator that matches <var>name</var> could be found,
but it does not match the argument types.
</dl>

<p>If the user-supplied function which implements the function raises an
error, this error is returned in *ecp.

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction may be implicitly rolled back.

<hr>

<h2 id="call_update_op">RDB_call_update_op</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_call_update_op(const char *name, int argc, RDB_object *argv[],
                RDB_exec_context *ecp, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_call_update_op invokes the update operator with the name <var>name</var>,
passing the arguments in <var>argc</var> and <var>argv</var>.

<h3>Return value</h3>

<p>RDB_OK on success, RDB_ERROR if an error occurred.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION_ERROR
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_OPERATOR_NOT_FOUND_ERROR
<dd>An update operator that matches the name and arguments could not be
found.
</dl>

<p>If the user-supplied function which implements the operator raises an
error, this error is returned in *ecp.

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction may be implicitly rolled back.

<hr>

<h2 id="drop_op">RDB_drop_op</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_drop_op(const char *name, RDB_exec_context *ecp, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_drop_op deletes the operator with the name <var>name</var>
from the database. This affects all overloaded versions.

<h3>Return value</h3>

<p>RDB_OK on success, RDB_ERROR if an error occurred.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION_ERROR
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_NOT_FOUND_ERROR
<dd>An operator with the specified name could not be found.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction may be implicitly rolled back.

<hr>

<h2 id="create_constraint">RDB_create_constraint</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_create_constraint(const char *name, RDB_expression *constrp,
                      RDB_exec_context *ecp, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_create_constraint creates a constraint with the name <var>name</var>
on the database the transaction specified by <var>txp</var> interacts with.

<h3>Return value</h3>

<p>RDB_OK on success, RDB_ERROR if an error occurred.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION_ERROR
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_TYPE_MISMATCH_ERROR
<dd>The expression specified by <var>constrp</var> is not of type BOOLEAN.
<dt>RDB_PREDICATE_VIOLATION_ERROR
<dd>The expression specified by <var>constrp</var> is not satisfied.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction may be implicitly rolled back.

<hr>

<h2 id="drop_constraint">RDB_drop_constraint</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_drop_constraint(const char *name, RDB_exec_context *ecp, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_drop_constraint deletes the constraint with the name <var>name</var>.

<h3>Return value</h3>

<p>RDB_OK on success, RDB_ERROR if an error occurred.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION_ERROR
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_NOT_FOUND_ERROR
<dd>A constraint with the name <var>name</var> could not be found.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction may be implicitly rolled back.

<hr>

<h2 id="open_env">RDB_open_env</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_open_env(const char *path, RDB_environment **envp);
</pre>

<h3>Description</h3>

<p>RDB_open_env opens a database environment identified by the
system resource <var>path</var>. 

<p>In the current implementation, the path passed to RDB_open_env
is a Berkeley DB database environment directory.
To create a new empty environment, simply pass an empty directory
to RDB_open_env.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<p>See the documentation of the Berkeley function DB_ENV->open for details.

<hr>

<h2 id="close_env">RDB_close_env</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_close_env(RDB_environment *envp);
</pre>

<h3>Description</h3>

<p>RDB_close_env closes the database environment specified by
<var>envp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<p>See the documentation of the Berkeley function DB_ENV->close for details.

<hr>

<h2 id="create_table_index">RDB_create_table_index</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_create_table_index(const char *name, RDB_table *tbp, int idxcompc,
                       const RDB_seq_item idxcompv[], int flags,
                       RDB_exec_context *ecp, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_create_table_index creates an index with name <var>name</var>
for the table specified by <var>tbp</var> over the attributes
specified by <var>idxcompc</var> and <var>idxcompv</var>.
The <var>flags</var> argument must be either 0 or RDB_ORDERED.
If <var>flags</var> is 0, a hash index is created.
If <var>flags</var> is RDB_ORDERED, a B-tree index is created.

<p>Functions which read tuples from a table (like
<a href="#table_to_array">RDB_table_to_array</a>
and <a href="#extract_tuple">RDB_extract_tuple</a>) try to use available
indexes in order to perform faster.

<h3>Return value</h3>

<p>RDB_OK on success, RDB_ERROR if an error occurred.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_ARGUMENT_ERROR
<dd><var>name</var> is not a valid index name.
<dt>RDB_ELEMENT_EXIST_ERROR
<dd>An index with name <var>name</var> already exists.
<dt>RDB_ATTRIBUTE_NOT_FOUND_ERROR
<dd>An attribute specified by <var>idxcompv</var> does not appear in the
table.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction may be implicitly rolled back.

<hr>

<h2 id="drop_table_index">RDB_drop_table_index</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_drop_table_index(const char *name, RDB_exec_context *ecp, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_drop_table_index drops the index specified by <var>name</var>.

<h3>Return value</h3>

<p>RDB_OK on success, RDB_ERROR if an error occurred.

<h3>Errors</h3>

<dl>
<dt>RDB_NOT_FOUND_ERROR
<dd>An index with name <var>name</var> does not exist.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction may be implicitly rolled back.

<hr>

<h2 id="init_exec_context">RDB_init_exec_context</h2>

<pre>
#include &lt;rel/rdb.h&gt;

void
RDB_init_exec_context(RDB_exec_context *ecp);
</pre>

<h3>Description</h3>

<p>RDB_init_exec_context initializes the RDB_exec_context structure given by
<var>ecp</var>. RDB_init_exec_context must be called before any other
operation can be performed on a RDB_exec_context structure.

<hr>

<h2 id="destroy_exec_context">RDB_destroy_exec_context</h2>

<pre>
#include &lt;rel/rdb.h&gt;

void
RDB_destroy_exec_context(RDB_exec_context *ecp);
</pre>

<h3>Description</h3>

<p>RDB_destroy_exec_context frees all resources associated with a
RDB_exec_context.

<hr>

<h2 id="raise_err">RDB_raise_err</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_object *
RDB_raise_err(RDB_exec_context *);
</pre>

<h3>Description</h3>

<p><strong>RDB_raise_err</strong> initializes a RDB_object structure,
makes it the error associated with the RDB_exec_context given
by <var>ecp</var>, and returns a pointer to it.
A previously raised error is overwritten. 
After RDB_raise_err() has been called succssfully, the RDB_object is in the
same state as after a call to RDB_init_obj(). It is the caller's
responsibility to assign a value to the RDB_object,
for example, by calling a selector.

<h3>Return value</h3>

<p>A pointer to the error, or NULL if the call fails.

<h3>Errors</h3>

<p>The call my fail and return NULL if an error was already
associated with the RDB_exec_context and destroying this error
failed.

<hr>

<h2 id="get_err">RDB_get_err</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_object *
RDB_get_err(RDB_exec_context *);
</pre>

<h3>Description</h3>

<p>Returns the error associated with the RDB_exec_context given by
<var>ecp</var>.

<h3>Return value</h3>

<p>A pointer to the error associated with the RDB_exec_context, or NULL
if no error has been raised.

<hr>

<h2 id="clear_err">RDB_clear_err</h2>

<pre>
#include &lt;rel/rdb.h&gt;

void
RDB_clear_err(RDB_exec_context *);
</pre>

<h3>Description</h3>

<p>RDB_clear_err clears the error associated with the RDB_exec_context given by
<var>ecp</var>, freing all resources associated with it.
Subsequent calls calls to RDB_get_err will return NULL.

<hr>

<h2 id="raise_no_memory">RDB_raise_no_memory, RDB_raise_invalid_argument,
RDB_raise_invalid_tx, RDB_raise_not_found,
RDB_raise_type_mismatch, RDB_raise_operator_not_found,
RDB_raise_type_constraint_violation, RDB_raise_element_exists,
RDB_raise_not_supported, RDB_raise_attribute_not_found,
RDB_raise_predicate_violation, RDB_raise_system,
RDB_raise_resource_not_found, RDB_raise_internal,
RDB_raise_lock_not_granted, RDB_raise_aggregate_undefined,
RDB_raise_version_mismatch, RDB_raise_syntax</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_object *
RDB_raise_no_memory(RDB_exec_context *);

RDB_object *
RDB_raise_invalid_tx(RDB_exec_context *);

RDB_object *
RDB_raise_invalid_argument(const char *, RDB_exec_context *);

RDB_object *
RDB_raise_not_found(const char *, RDB_exec_context *);

RDB_object *
RDB_raise_type_mismatch(const char *, RDB_exec_context *);

RDB_object *
RDB_raise_operator_not_found(const char *, RDB_exec_context *);

RDB_object *
RDB_raise_type_constraint_violation(const char *, RDB_exec_context *);

RDB_object *
RDB_raise_element_exists(const char *msg, RDB_exec_context *);

RDB_object *
RDB_raise_not_supported(const char *msg, RDB_exec_context *);

RDB_object *
RDB_raise_attribute_not_found(const char *msg, RDB_exec_context *);

RDB_object *
RDB_raise_predicate_violation(const char *msg, RDB_exec_context *);

RDB_object *
RDB_raise_system(const char *msg, RDB_exec_context *);

RDB_object *
RDB_raise_resource_not_found(const char *msg, RDB_exec_context *);

RDB_object *
RDB_raise_internal(const char *msg, RDB_exec_context *);

RDB_object *
RDB_raise_lock_not_granted(RDB_exec_context *);

RDB_object *
RDB_raise_aggregate_undefined(RDB_exec_context *);

RDB_object *
RDB_raise_version_mismatch(RDB_exec_context *);

RDB_object *
RDB_raise_syntax(const char *msg, RDB_exec_context *);

</pre>

<h3>Description</h3>

<p>The functions shown above raise system-provided errors.

<hr>

<h2 id="ec_set_property">RDB_ec_set_property</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_ec_set_property(RDB_exec_context *, const char *name, void *value);
</pre>

<h3>Description</h3>

<p><strong>RDB_ec_set_property</strong> sets the property <var>name</var>
of the RDB_exec_context given by <var>ecp</var> to <var>value</var>.

<h3>Return value</h3>

<p>RDB_OK on success, RDB_ERROR on failure.

<hr>

<h2 id="ec_get_property">RDB_ec_get_property</h2>

<pre>
#include &lt;rel/rdb.h&gt;

void *
RDB_ec_get_property(RDB_exec_context *, const char *name);
</pre>

<h3>Description</h3>

<p><strong>RDB_ec_get_property</strong> returns the value of the property <var>name</var>
of the RDB_exec_context given by <var>ecp</var>.

<h3>Return value</h3>

<p>The property value.

<hr>

<h2 id="parse_expr">RDB_parse_expr<br>
RDB_parse_table</h2>

<pre>
#include &lt;dli/parse.h&gt;

typedef RDB_table *RDB_ltablefn(const char *, void *);

RDB_expression *
RDB_parse_expr(const char *exprtxt, RDB_ltablefn *ltfnp, void *arg,
        RDB_exec_context *ecp, RDB_transaction *);

RDB_table *
RDB_parse_table(const char *exprtxt, RDB_ltablefn *ltfnp, void *arg,
        RDB_exec_context *ecp, RDB_transaction *);
</pre>

<h3>Description</h3>

<p>These functions parse the <a href="expressions.html">expression</a>
specified by <var>exprtxt</var>. If <var>ltfnp</var> is not NULL,
it must point to a function which is used to look up local tables.
The function is invoked with the table name and <var>arg</var> as
arguments. It must return a pointer to the table or NULL if the table was
not found.

<p><strong>RDB_parse_expr</strong> converts an expression into a RDB_expression.

<p><strong>RDB_parse_table</strong> converts an expression into a virtual table.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, RDB_ERROR is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_SYNTAX_ERROR
<dd>A syntax error occurred during parsing.
<dt>RDB_TYPE_MISMATCH
<dd>Raised by <strong>RDB_parse_table</strong> if the type of
the expression is not a relation type.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction may be implicitly rolled back.


<h3>Notes</h3>

<p>The parser is not reentrant.

<hr>

<h2 id="attr">RDB_attr</h2>

<pre>
typedef struct {
    char *name;
    RDB_type *typ;
    RDB_object *defaultp;
    int options;
} RDB_attr;
</pre>

<hr>

<h2 id="virtual_attr">RDB_virtual_attr</h2>

<pre>
typedef struct {
    char *name;
    RDB_expression *exp;
} RDB_virtual_attr;
</pre>

<hr>

<h2 id="renaming">RDB_renaming</h2>

<pre>
typedef struct {
    char *from;
    char *to;
} RDB_renaming;
</pre>

<hr>

<h2 id="wrapping">RDB_wrapping</h2>

<pre>
typedef struct {
    int attrc;
    char **attrv;
    char *attrname;
} RDB_wrapping;
</pre>

<hr>

<h2 id="possrep">RDB_possrep</h2>

<pre>
typedef struct {
    char *name;
    int compc;
    RDB_attr *compv;
} RDB_possrep;
</pre>

<hr>

<h2 id="aggregate_op">RDB_aggregate_op</h2>

<pre>
typedef enum {
    RDB_COUNT, RDB_SUM, RDB_AVG, RDB_MAX, RDB_MIN, RDB_ALL, RDB_ANY,
    RDB_COUNTD, RDB_SUMD, RDB_AVGD
} RDB_aggregate_op;
</pre>

<hr>

<h2>Built-in types</h2>

<h3 id="data-types">Basic data types</h3>

<table border="1" summary="Built-in types">
<tr><th>Name<th>RDB_type variable<th>C type
<tr><td>BOOLEAN<td>RDB_BOOLEAN<td>RDB_bool
<tr><td>INTEGER<td>RDB_INTEGER<td>RDB_int
<tr><td>FLOAT<td>RDB_FLOAT<td>RDB_float
<tr><td>DOUBLE<td>RDB_DOUBLE<td>RDB_double
<tr><td>STRING<td>RDB_STRING<td>char *
<tr><td>BINARY<td>RDB_BINARY<td>&nbsp;-
</table>

<h3 id="error-types">Error types</h3>

<p>Since version 0.10, Duro errors are scalar types.
They are shown below in Tutorial D notation.

<pre>
TYPE INVALID_TRANSACTION_ERROR POSSREP { };

TYPE INVALID_ARGUMENT_ERROR POSSREP { MSG STRING };

TYPE TYPE_MISMATCH_ERROR POSSREP { MSG STRING };

TYPE NOT_FOUND_ERROR POSSREP { MSG STRING };

TYPE OPERATOR_NOT_FOUND_ERROR POSSREP { MSG STRING };

TYPE ATTRIBUTE_NOT_FOUND_ERROR POSSREP { MSG STRING };

TYPE ELEMENT_EXISTS_ERROR POSSREP { MSG STRING };

TYPE TYPE_CONSTRAINT_VIOLATION_ERROR POSSREP { MSG STRING };

TYPE KEY_VIOLATION_ERROR { MSG STRING };

TYPE PREDICATE_VIOLATION_ERROR { MSG STRING };

TYPE AGGREGATE_UNDEFINED_ERROR { };

TYPE VERSION_MISMATCH_ERROR { };

TYPE NOT_SUPPORTED_ERROR { MSG STRING };

TYPE SYNTAX_ERROR POSSREP { MSG STRING };
</pre>

<h4 id="syserr">System errors</h4>

<pre>
TYPE NO_MEMORY_ERROR POSSREP {  };
</pre>

<p>Insufficient memory.

<pre>
TYPE SYSTEM_ERROR POSSREP { MSG STRING };
</pre>

<p>Unspecified system error.

<pre>
TYPE LOCK_NOT_GRANTED_ERROR POSSREP { };
</pre>

<p>A lock was requested but could not be granted.

<pre>
TYPE DEADLOCK_ERROR POSSREP { };
</pre>

<p>A deadlock condition was detected.

<pre>
TYPE RESOURCE_NOT_FOUND_ERROR POSSREP { MSG STRING };
</pre>

<p>A system resource, usually a file, could not be found.

<pre>
TYPE INTERNAL_ERROR POSSREP { MSG STRING };
</pre>

<p>Internal error.

<pre>
TYPE FATAL_ERROR POSSREP { };
</pre>

<p>Fatal error. This means that future calls will most likely fail.

<h2 id="builtin-ops">Built-in operators</h2>

<p>The built-in operators, shown in Tutorial D notation.

<h3 id="op_eq">OPERATOR =</h3>

<p>OPERATOR = (<em>ANY</em>, <em>ANY</em>) RETURNS BOOLEAN;

<h4>Description</h4>

<p>The equality operator. Defined for every type.
The arguments must be of the same type.

<h4>Return value</h4>

<p>TRUE if the two arguments are equal, FALSE otherwise.

<hr>

<h3 id="op_neq">OPERATOR <></h3>

<p>OPERATOR <> (<em>ANY</em>, <em>ANY</em>) RETURNS BOOLEAN;

<h4>Description</h4>

<p>The inequality operator. Defined for every type.
The arguments must be of the same type.

<h4>Return value</h4>

<p>TRUE if the two arguments are not equal, FALSE otherwise.

<hr>

<h3 id="op_lt">OPERATOR &lt;</h3>

<p>OPERATOR &lt; (INTEGER, INTEGER) RETURNS BOOLEAN;

<p>OPERATOR &lt; (FLOAT, FLOAT) RETURNS BOOLEAN;

<p>OPERATOR &lt; (DOUBLE, DOUBLE) RETURNS BOOLEAN;

<p>OPERATOR &lt; (STRING, STRING) RETURNS BOOLEAN;

<h4>Description</h4>

<p>The lower-than operator.

<h4>Return value</h4>

<p>TRUE if the first argument is lower than the first.
If the operands are strings, the strings will be compared using strcoll().

<hr>

<h3 id="op_lte">OPERATOR &lt;=</h3>

<p>OPERATOR &lt;= (INTEGER, INTEGER) RETURNS BOOLEAN;

<p>OPERATOR &lt;= (FLOAT, FLOAT) RETURNS BOOLEAN;

<p>OPERATOR &lt;= (DOUBLE, DOUBLE) RETURNS BOOLEAN;

<p>OPERATOR &lt;= (STRING, STRING) RETURNS BOOLEAN;

<h4>Description</h4>

<p>The lower-than-or-equal operator.

<h4>Return value</h4>

<p>TRUE if the first argument is lower than or equal to the second.
If the operands are strings, the strings will be compared using strcoll().

<hr>

<h3 id="op_gt">OPERATOR &gt;</h3>

<p>OPERATOR &gt; (INTEGER, INTEGER) RETURNS BOOLEAN;

<p>OPERATOR &gt; (FLOAT, FLOAT) RETURNS BOOLEAN;

<p>OPERATOR &gt; (DOUBLE, DOUBLE) RETURNS BOOLEAN;

<p>OPERATOR &gt; (STRING, STRING) RETURNS BOOLEAN;

<h4>Description</h4>

<p>The greater-than operator.

<h4>Return value</h4>

<p>TRUE if the first argument is greater than the first.
If the operands are strings, the strings will be compared using strcoll().

<hr>

<h3 id="op_gte">OPERATOR &gt;=</h3>

<p>OPERATOR &gt;= (INTEGER, INTEGER) RETURNS BOOLEAN;

<p>OPERATOR &gt;= (FLOAT, FLOAT) RETURNS BOOLEAN;

<p>OPERATOR &gt;= (DOUBLE, DOUBLE) RETURNS BOOLEAN;

<p>OPERATOR &gt;= (STRING, STRING) RETURNS BOOLEAN;

<h4>Description</h4>

<p>The greater-than-or-equal operator.

<h4>Return value</h4>

<p>TRUE if the first argument is greater than or equal to the second.
If the operands are strings, the strings will be compared using strcoll().

<hr>

<h3 id="op_plus">OPERATOR +</h3>

<p>OPERATOR + (INTEGER, INTEGER) RETURNS INTEGER;

<p>OPERATOR + (FLOAT, FLOAT) RETURNS FLOAT;

<p>OPERATOR + (DOUBLE, DOUBLE) RETURNS DOUBLE;

<h4>Description</h4>

<p>The addition operator.

<h4>Return value</h4>

<p>The sum of the two operands.

<hr>

<h3 id="op_uminus">OPERATOR - (unary)</h3>

<p>OPERATOR - (INTEGER) RETURNS INTEGER;

<p>OPERATOR - (FLOAT) RETURNS FLOAT;

<p>OPERATOR - (DOUBLE) RETURNS DOUBLE;

<h4>Description</h4>

<p>The unary minus operator.

<h4>Return value</h4>

<p>The operand, sign inverted.

<hr>

<h3 id="op_bminus">OPERATOR - (binary)</h3>

<p>OPERATOR - (INTEGER, INTEGER) RETURNS INTEGER;

<p>OPERATOR - (FLOAT, FLOAT) RETURNS FLOAT;

<p>OPERATOR - (DOUBLE, DOUBLE) RETURNS DOUBLE;

<h4>Description</h4>

<p>The subtraction operator.

<h4>Return value</h4>

<p>The difference of the two operands.

<hr>

<h3 id="op_times">OPERATOR *</h3>

<p>OPERATOR * (INTEGER, INTEGER) RETURNS INTEGER;;

<p>OPERATOR * (FLOAT, FLOAT) RETURNS FLOAT;

<p>OPERATOR * (DOUBLE, DOUBLE) RETURNS DOUBLE;

<h4>Description</h4>

<p>The multiplication operator.

<h4>Return value</h4>

<p>The product of the two operands.

<hr>

<h3 id="op_div">OPERATOR /</h3>

<p>OPERATOR / (INTEGER, INTEGER) RETURNS INTEGER;

<p>OPERATOR / (FLOAT, FLOAT) RETURNS FLOAT;

<p>OPERATOR / (DOUBLE, DOUBLE) RETURNS DOUBLE;

<h4>Description</h4>

<p>The division operator.

<h4>Return value</h4>

<p>The quotient of the operators.

<h4>Errors</h4>

<dl>
<dt>INVALID_ARGUMENT_ERROR
<dd>The divisor is zero.
</dl>

<hr>

<h3 id="op_and">OPERATOR AND</h3>

<p>OPERATOR AND (BOOLEAN, BOOLEAN) RETURNS BOOLEAN;

<h4>Description</h4>

<p>The boolean AND operator.

<hr>

<h3 id="op_or">OPERATOR OR</h3>

<p>OPERATOR OR (BOOLEAN, BOOLEAN) RETURNS BOOLEAN;

<h4>Description</h4>

<p>The boolean OR operator.

<hr>

<h3 id="op_not">OPERATOR NOT</h3>

<p>OPERATOR NOT (BOOLEAN) RETURNS BOOLEAN;

<h4>Description</h4>

<p>The boolean NOT operator.

<hr>

<h3 id="op_concat">OPERATOR ||</h3>

<p>OPERATOR || (STRING, STRING) RETURNS STRING;

<h4>Description</h4>

<p>The string concatenation operator.

<h4>Return value</h4>

<p>The result of the concatenation of the operands.

<hr>

<h3 id="op_length">OPERATOR LENGTH</h3>

<p>OPERATOR LENGTH (STRING) RETURNS INTEGER;

<h4>Description</h4>

<p>The string length operator.

<h4>Return value</h4>

<p>The length of the operand.

<hr>

<h3 id="op_substring">OPERATOR SUBSTRING</h3>

<p>OPERATOR SUBSTRING(S STRING, START INTEGER, LENGTH INTEGER) RETURNS
STRING;

<h4>Description</h4>

<p>The substring operator.

<h4>Return value</h4>

<p>The substring of S with length LENGTH starting at position
START.

<h4>Errors</h4>

<dl>
<dt>INVALID_ARGUMENT_ERROR
<dd>START is negative, or START + LENGTH is greater than LENGTH(S).
</dl>

<hr>

<h3 id="op_matches">OPERATOR MATCHES</h3>

<p>OPERATOR MATCHES (S STRING, PATTERN STRING) RETURNS BOOLEAN;

<h4>Description</h4>

<p>The regular expression matching operator.

<h4>Return value</h4>

<p>RDB_TRUE if S matches PATTERN, RDB_FALSE otherwise.

<hr>

<h3 id="op_integer">OPERATOR INTEGER</h3>

<p>OPERATOR INTEGER (DOUBLE) RETURNS INTEGER;

<p>OPERATOR INTEGER (FLOAT) RETURNS INTEGER;

<p>OPERATOR INTEGER (STRING) RETURNS INTEGER;

<h4>Description</h4>

<p>Converts the operand to INTEGER.

<h4>Return value</h4>

<p>The operand, converted to INTEGER.

<hr>

<h3 id="op_float">OPERATOR FLOAT</h3>

<p>OPERATOR FLOAT (INTEGER) RETURNS FLOAT;

<p>OPERATOR FLOAT (DOUBLE) RETURNS FLOAT;

<p>OPERATOR FLOAT (STRING) RETURNS FLOAT;

<h4>Description</h4>

<p>Converts the operand to FLOAT.

<h4>Return value</h4>

<p>The operand, converted to FLOAT.

<hr>

<h3 id="op_double">OPERATOR DOUBLE</h3>

<p>OPERATOR DOUBLE (INTEGER) RETURNS DOUBLE;

<p>OPERATOR DOUBLE (FLOAT) RETURNS DOUBLE;

<p>OPERATOR DOUBLE (STRING) RETURNS DOUBLE;

<h4>Description</h4>

<p>Converts the operand to DOUBLE.

<h4>Return value</h4>

<p>The operand, converted to DOUBLE.

<hr>

<h3 id="op_string">OPERATOR STRING</h3>

<p>OPERATOR STRING (INTEGER) RETURNS STRING;

<p>OPERATOR STRING (FLOAT) RETURNS STRING;

<p>OPERATOR STRING (DOUBLE) RETURNS STRING;

<h4>Description</h4>

<p>Converts the operand to a string.

<h4>Return value</h4>

<p>The operand, converted to STRING.

<hr>

<h3 id="op_is_empty">OPERATOR IS_EMPTY</h3>

<p>OPERATOR IS_EMPTY (<em>RELATION</em>) RETURNS BOOLEAN;

<h4>Description</h4>

<p>Checks if a table is empty.

<h4>Return value</h4>

<p>RDB_TRUE if the relation-valued operand is empty, RDB_FALSE
otherwise.

<hr>

<h3 id="op_count">OPERATOR COUNT</h3>

<p>OPERATOR COUNT (<em>RELATION</em>) RETURNS INTEGER;

<h4>Description</h4>

<p>Counts the tuples in a table.

<h4>Return value</h4>

<p>The cardinality of the relation-valued operand.

<hr>

<h3 id="op_in">OPERATOR IN</h3>

<p>OPERATOR IN (T <em>TUPLE</em>, R <em>RELATION</em>) RETURNS BOOLEAN;

<h4>Description</h4>

<p>Checks if a table contains a given tuple.

<h4>Return value</h4>

<p>RDB_TRUE if <var>R</var> contains <var>T</var>, RDB_FALSE otherwise.

<hr>

<h3 id="op_subset_of">OPERATOR SUBSET_OF</h3>

<p>OPERATOR SUBSET_OF (R1 <em>RELATION</em>, R2 <em>RELATION</em>) RETURNS BOOLEAN;

<h4>Description</h4>

<p>Checks if a table is a subset of another table.

<h4>Return value</h4>

<p>RDB_TRUE if the <var>R1</var> is a subset of <var>R2</var>, RDB_FALSE otherwise.

<hr>

<h3 id="op_if">OPERATOR IF</h3>

<p>OPERATOR IF (B BOOLEAN, V1 <em>ANY</em>, V2 <em>ANY</em>) RETURNS <em>ANY</em>;

<h4>Description</h4>

<p>The IF-THEN-ELSE operator. 

<h4>Return value</h4>

<p><var>V1</var> if <var>B</var> is RDB_TRUE, <var>V2</var> otherwise.

<hr>

<h3 id="op_divide">OPERATOR DIVIDE</h3>

<p>OPERATOR DIVIDE(R1 <em>RELATION</em>, R2 <em>RELATION</em>, R2 <em>RELATION</em>) RETURNS <em>RELATION</em>;

<h4>Description</h4>

<p>The relational three-argument (small) DIVIDE operator.

<hr>

<h3 id="op_extend">OPERATOR EXTEND</h3>

<p>OPERATOR EXTEND(R <em>RELATION</em>, ATTREXP <em>ANY</em>, ATTRNAME STRING, ...) RETURNS <em>RELATION</em>;

<hr>

<h3 id="op_group">OPERATOR GROUP</h3>

<p>OPERATOR GROUP(R <em>RELATION</em>, ATTRNAME <em>STRING</em> ...) RETURNS <em>RELATION</em>;

<hr>

<h3 id="op_intersect">OPERATOR INTERSECT</h3>

<p>OPERATOR INTERSECT(R1 <em>RELATION</em>, R2 <em>RELATION</em>) RETURNS <em>RELATION</em>;

<hr>

<h3 id="op_join">OPERATOR JOIN</h3>

<p>OPERATOR JOIN(R1 <em>RELATION</em>, R2 <em>RELATION</em>) RETURNS <em>RELATION</em>;

<hr>

<h3 id="op_minus">OPERATOR MINUS</h3>

<p>OPERATOR MINUS(R1 <em>RELATION</em>, R2 <em>RELATION</em>) RETURNS <em>RELATION</em>;

<hr>

<h3 id="op_project">OPERATOR PROJECT</h3>

<p>OPERATOR PROJECT(R1 <em>RELATION</em>, ATTRNAME STRING ...) RETURNS <em>RELATION</em>;

<hr>

<h3 id="op_remove">OPERATOR REMOVE</h3>

<p>OPERATOR REMOVE(R <em>RELATION</em>, ATTRNAME STRING ...) RETURNS <em>RELATION</em>;

<hr>

<h3 id="op_rename">OPERATOR RENAME</h3>

<p>OPERATOR RENAME(R <em>RELATION</em>, SRC_ATTRNAME STRING, DST_ATTRNAME ...) RETURNS <em>RELATION</em>;

<hr>

<h3 id="op_ungroup">OPERATOR UNGROUP</h3>

<p>OPERATOR UNGROUP(R <em>RELATION</em>, ATTRNAME STRING) RETURNS <em>RELATION</em>;

<hr>

<h3 id="op_union">OPERATOR UNION</h3>

<p>OPERATOR UNION(R1 <em>RELATION</em>, R2 <em>RELATION</em>) RETURNS <em>RELATION</em>;

<hr>

<h3 id="op_unwrap">OPERATOR UNWRAP</h3>

<p>OPERATOR UNWRAP(ATTRNAME STRING, ...) RETURNS <em>RELATION</em>;

<hr>

<h3 id="op_semijoin">OPERATOR SEMIJOIN</h3>

<p>OPERATOR SEMIJOIN(R1 <em>RELATION</em>, R2 <em>RELATION</em>) RETURNS <em>RELATION</em>;

<hr>

<h3 id="op_semiminus">OPERATOR SEMIMINUS</h3>

<p>OPERATOR SEMIMINUS(R1 <em>RELATION</em>, R2 <em>RELATION</em>) RETURNS <em>RELATION</em>;

<hr>

<h3 id="op_summarize">OPERATOR SUMMARIZE</h3>

<p>OPERATOR (R1 <em>RELATION</em>, R2 <em>RELATION</em>, EXPR <em>ANY</em>, ATTRNAME STRING, ...) RETURNS <em>RELATION</em>;

<hr>

<h3 id="op_where">OPERATOR WHERE</h3>

<p>OPERATOR (R <em>RELATION</em>, B BOOLEAN) RETURNS <em>RELATION</em>;

<hr>

<h3 id="op_wrap">OPERATOR WRAP</h3>

<p>OPERATOR WRAP(R <em>RELATION</em>, SCR_ATTRS ARRAY OF STRING, DST_ATTR STRING ...) RETURNS <em>RELATION</em>;

<p>$Id$

</html>
