<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
"http://www.w3.org/TR/html4/strict.dtd">
<html lang="en">
<head>
<title>Duro 0.9 API specification</title>
<body>
<h1>Duro API specification</h1>

<p>Version 0.9

<h2>Contents</h2>

<h3>Built-in types</h3>

<p><a href="#built-in-types">Table of built-in types</a>

<h3>Table functions</h3>

<ul>
<li><a href="#add_table">RDB_add_table</a>
<li><a href="#all">RDB_all</a>
<li><a href="#any">RDB_any</a>
<li><a href="#avg">RDB_avg</a>
<li><a href="#cardinality">RDB_cardinality</a>
<li><a href="#copy_table">RDB_copy_table</a>
<li><a href="#create_table">RDB_create_table</a>
<li><a href="#delete">RDB_delete</a>
<li><a href="#drop_table">RDB_drop_table</a>
<li><a href="#extend">RDB_extend</a>
<li><a href="#extract_tuple">RDB_extract_tuple</a>
<li><a href="#gdivide">RDB_gdivide</a>
<li><a href="#get_table">RDB_get_table</a>
<li><a href="#group">RDB_group</a>
<li><a href="#insert">RDB_insert</a>
<li><a href="#intersect">RDB_intersect</a>
<li><a href="#join">RDB_join</a>
<li><a href="#max">RDB_max</a>
<li><a href="#min">RDB_min</a>
<li><a href="#minus">RDB_minus</a>
<li><a href="#project">RDB_project</a>
<li><a href="#remove">RDB_remove</a>
<li><a href="#rename">RDB_rename</a>
<li><a href="#remove_table">RDB_remove_table</a>
<li><a href="#sdivide">RDB_sdivide</a>
<li><a href="#select">RDB_select</a>
<li><a href="#set_table_name">RDB_set_table_name</a>
<li><a href="#subset">RDB_subset</a>
<li><a href="#sum">RDB_sum</a>
<li><a href="#summarize">RDB_summarize</a>
<li><a href="#table_contains">RDB_table_contains</a>
<li><a href="#table_equals">RDB_table_equals</a>
<li><a href="#table_is_empty">RDB_table_is_empty</a>
<li><a href="#table_name">RDB_table_name</a>
<li><a href="#table_type">RDB_table_type</a>
<li><a href="#ungroup">RDB_ungroup</a>
<li><a href="#union">RDB_union</a>
<li><a href="#unwrap">RDB_unwrap</a>
<li><a href="#update">RDB_update</a>
<li><a href="#wrap">RDB_wrap</a>
</ul>

<h3>Tuple functions</h3>

<ul>
<li><a href="#extend_tuple">RDB_extend_tuple</a>
<li><a href="#join_tuples">RDB_join_tuples</a>
<li><a href="#project_tuple">RDB_project_tuple</a>
<li><a href="#rename_tuple">RDB_rename_tuple</a>
<li><a href="#tuple_attr_names">RDB_tuple_attr_names</a>
<li><a href="#tuple_get">RDB_tuple_get</a>
<li><a href="#tuple_get_bool">RDB_tuple_get_bool</a>
<li><a href="#tuple_get_int">RDB_tuple_get_int</a>
<li><a href="#tuple_get_rational">RDB_tuple_get_rational</a>
<li><a href="#tuple_get_string">RDB_tuple_get_string</a>
<li><a href="#tuple_set">RDB_tuple_set</a>
<li><a href="#tuple_set_bool">RDB_tuple_set_bool</a>
<li><a href="#tuple_set_int">RDB_tuple_set_int</a>
<li><a href="#tuple_set_rational">RDB_tuple_set_rational</a>
<li><a href="#tuple_set_string">RDB_tuple_set_string</a>
<li><a href="#tuple_size">RDB_tuple_size</a>
<li><a href="#unwrap_tuple">RDB_unwrap_tuple</a>
<li><a href="#wrap_tuple">RDB_wrap_tuple</a>
</ul>

<h3>Scalar and generic functions</h3>

<ul>
<li><a href="#binary_get">RDB_binary_get</a>
<li><a href="#binary_set">RDB_binary_set</a>
<li><a href="#binary_length">RDB_binary_length</a>
<li><a href="#copy_obj">RDB_copy_obj</a>
<li><a href="#destroy_obj">RDB_destroy_obj</a>
<li><a href="#init_obj">RDB_init_obj</a>
<li><a href="#obj_bool">RDB_obj_bool</a>
<li><a href="#obj_comp">RDB_obj_comp</a>
<li><a href="#obj_equals">RDB_obj_equals</a>
<li><a href="#obj_int">RDB_obj_int</a>
<li><a href="#obj_rational">RDB_obj_rational</a>
<li><a href="#bool_to_obj">RDB_bool_to_obj</a>
<li><a href="#int_to_obj">RDB_int_to_obj</a>
<li><a href="#rational_to_obj">RDB_rational_to_obj</a>
<li><a href="#string_to_obj">RDB_string_to_obj</a>
<li><a href="#obj_set_comp">RDB_obj_set_comp</a>
<li><a href="#obj_string">RDB_obj_string</a>
<li><a href="#obj_table">RDB_obj_table</a>
<li><a href="#table_to_obj">RDB_table_to_obj</a>
<li><a href="#obj_irep">RDB_obj_irep</a>
</ul>

<h3>Database functions</h3>

<ul>
<li><a href="#create_db_from_env">RDB_create_db_from_env</a>
<li><a href="#db_env">RDB_db_env</a>
<li><a href="#db_name">RDB_db_name</a>
<li><a href="#drop_db">RDB_drop_db</a>
<li><a href="#get_db_from_env">RDB_get_db_from_env</a>
</ul>

<h3>Transaction functions</h3>

<ul>
<li><a href="#begin_tx">RDB_begin_tx</a>
<li><a href="#commit">RDB_commit</a>
<li><a href="#rollback">RDB_rollback</a>
<li><a href="#tx_db">RDB_tx_db</a>
<li><a href="#tx_is_running">RDB_tx_is_running</a>
</ul>

<h3>Array functions</h3>

<ul>
<li><a href="#array_get">RDB_array_get</a>
<li><a href="#array_length">RDB_array_length</a>
<li><a href="#array_set">RDB_array_set</a>
<li><a href="#table_to_array">RDB_table_to_array</a>
<li><a href="#set_array_length">RDB_set_array_length</a>
</ul>

<h3>Expression functions</h3>

<ul>
<li><a href="#expr_is_const">RDB_expr_is_const</a>
<li><a href="#bool_to_expr">RDB_bool_to_expr</a>
<li><a href="#int_to_expr">RDB_int_to_expr</a>
<li><a href="#rational_to_expr">RDB_rational_to_expr</a>
<li><a href="#string_to_expr">RDB_string_to_expr</a>
<li><a href="#obj_to_expr">RDB_obj_to_expr</a>
<li><a href="#expr_attr">RDB_expr_attr</a>
<li><a href="#eq">RDB_eq</a>
<li><a href="#expr_any">RDB_expr_any</a>
<li><a href="#expr_all">RDB_expr_all</a>
<li><a href="#expr_avg">RDB_expr_avg</a>
<li><a href="#expr_comp">RDB_expr_comp</a>
<li><a href="#expr_max">RDB_expr_max</a>
<li><a href="#expr_min">RDB_expr_min</a>
<li><a href="#expr_sum">RDB_expr_sum</a>
<li><a href="#table_to_expr">RDB_table_to_expr</a>
<li><a href="#tuple_attr">RDB_tuple_attr</a>
<li><a href="#ro_op">RDB_ro_op</a>
<li><a href="#ro_op_va">RDB_ro_op_va</a>
<li><a href="#drop_expr">RDB_drop_expr</a>
</ul>

<h3>Type functions</h3>

<ul>
<li><a href="#define_type">RDB_define_type</a>
<li><a href="#implement_type">RDB_implement_type</a>
<li><a href="#create_array_type">RDB_create_array_type</a>
<li><a href="#create_relation_type">RDB_create_relation_type</a>
<li><a href="#create_tuple_type">RDB_create_tuple_type</a>
<li><a href="#get_type">RDB_get_type</a>
<li><a href="#drop_type">RDB_drop_type</a>
<li><a href="#type_name">RDB_type_name</a>
<li><a href="#type_is_scalar">RDB_type_is_scalar</a>
<li><a href="#type_is_numeric">RDB_type_is_numeric</a>
<li><a href="#type_equals">RDB_type_equals</a>
</ul>

<h3>Operator functions</h3>

<ul>
<li><a href="#create_ro_op">RDB_create_ro_op</a>
<li><a href="#create_update_op">RDB_create_update_op</a>
<li><a href="#call_ro_op">RDB_call_ro_op</a>
<li><a href="#call_update_op">RDB_call_update_op</a>
<li><a href="#drop_op">RDB_drop_op</a>
</ul>

<h3>Constraint functions</h3>

<ul>
<li><a href="#create_constraint">RDB_create_constraint</a>
<li><a href="#drop_constraint">RDB_drop_constraint</a>
<li><a href="#begin_uoi">RDB_begin_uoi</a>
<li><a href="#end_uoi">RDB_end_uoi</a>
</ul>

<h3>Database environment functions</h3>

<ul>
<li><a href="#open_env">RDB_open_env</a>
<li><a href="#close_env">RDB_close_env</a>
<li><a href="#set_errfile">RDB_set_errfile</a>
<li><a href="#set_errfn">RDB_set_errfn</a>
</ul>

<h3>Index functions</h3>

<ul>
<li><a href="#create_table_index">RDB_create_table_index</a>
<li><a href="#drop_table_index">RDB_drop_table_index</a>
</ul>

<h3>Error handling functions</h3>

<ul>
<li><a href="#strerror">RDB_strerror</a>
<li><a href="#is_syserr">RDB_is_syserr</a>
</ul>

<h3>Expression parsing functions</h3>

<ul>
<li><a href="#parse_expr">RDB_parse_expr</a>
<li><a href="#parse_expr">RDB_parse_table</a>
</ul>

<h3>C structures and definitions</h3>

<ul>
<li><a href="#attr">RDB_attr</a>
<li><a href="#virtual_attr">RDB_virtual_attr</a>
<li><a href="#renaming">RDB_renaming</a>
<li><a href="#wrapping">RDB_wrapping</a>
<li><a href="#possrep">RDB_possrep</a>
<li><a href="#aggregate_op">RDB_aggregate_op</a>
<li><a href="#syserr">System errors</a>
</ul>

<h2 id="built-in-types">Built-in types</h2>

<table border="1" summary="Built-in types">
<tr><th>Name<th>RDB_type variable<th>C type
<tr><td>BOOLEAN<td>RDB_BOOLEAN<td>RDB_bool
<tr><td>INTEGER<td>RDB_INTEGER<td>RDB_int
<tr><td>RATIONAL<td>RDB_RATIONAL<td>RDB_rational
<tr><td>STRING<td>RDB_STRING<td>char *
<tr><td>BINARY<td>RDB_BINARY<td>&nbsp;-
</table>

<hr>

<h2 id="create_table">RDB_create_table</h2>

<pre>
#include &lt;rel/rdb.h&gt;

typedef struct {
    int strc;
    char **strv;
} RDB_string_vec;

int
RDB_create_table(const char *name, RDB_bool global,
                 int attrc, const <a href="#attr">RDB_attr</a> attrv[],
                 int keyc, const RDB_string_vec keyv[],
                 RDB_transaction *txp, RDB_table **tbpp);
</pre>

<h3>Description</h3>

<p>RDB_create_table creates a table with name <var>name</var> under the control of
the transaction pointed to by <var>txp</var>.
A pointer to the newly created RDB_table structure
will be stored at the location pointed to by <var>tbpp</var>.

<p>If <var>global</var> is RDB_FALSE, a local (transient) table will be created.
In this case, <var>name</var> may be NULL.

<p>If <var>global</var> is RDB_TRUE, a global (persistent) table in the database
the transaction pointed to by <var>txp</var> interacts with will be created.

<p>The table will have <var>attrc</var> attributes. The individual
attributes are specified by the elements of <var>attrv</var>.

<p>The fields of the RDB_attr structure are interpreted as follows:

<dl>
<dt>name
<dd>Specifies the name of the attribute.
<dt>typ
<dd>Specifies the type of the attribute.
<dt>defaultp
<dd>If not NULL, this field must point to a RDB_object variable that specifies
the default value for the attribute.
<dt>options
<dd>This field is currently ignored.
</dl>

<p>The table will have <var>keyc</var> candidate keys. The <var>keyv</var>
argument specifies the key attributes.
The strc field of the RDB_string_vec structure specifies
the number of attributes in a key, while the elements of the strv field specify
the names of the key attributes.

<p>At least one candidate key must be specified.
A candidate key may not be a subset of another.
If a single candidate key is specified, that key
may be empty (not contain any attribute).

<p>Passing a <var>keyv</var> of NULL is equivalent to specifiying a single key
which consists of all attributes, that is, the table will become all-key.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_TYPE_MISMATCH
<dd>The type of a default value does not match the type of the corresponding
attribute.
<dt>RDB_INVALID_ARGUMENT
<dd>One or more of the arguments are incorrect. For example, a key attribute
does not appear in <var>attrv</var>, etc.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="get_table">RDB_get_table</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_get_table(const char *name, RDB_transaction *txp, RDB_table **tbpp);
</pre>

<h3>Description</h3>

<p>RDB_get_table looks up the global table with name <var>name</var>
in the environment of the database the transaction
specified by <var>txp</var> interacts with and stores a pointer to a
RDB_table structure in <var>tbpp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_NOT_FOUND
<dd>A table with the name <var>name</var> could not be found.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="drop_table">RDB_drop_table</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_drop_table(RDB_table *tbp, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_drop_table deletes the table specified by <var>tbp</var>
and frees all resources associated with that table.
If the table is virtual, its unnamed child tables are also deleted.

<p>If the table is local, <var>txp</var> may be NULL.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd>The table is global (persistent) and <var>txp</var>
does not point to a running transaction.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="table_name">RDB_table_name</h2>

<pre>
#include &lt;rel/rdb.h&gt;

char *
RDB_table_name(RDB_table *tbp)
</pre>

<h3>Description</h3>

<p>RDB_table_name returns a pointer to the name of a table.

<h3>Return value</h3>

<p>A pointer to the name of the table, or NULL if the table has no name.

<hr>

<h2 id="table_type">RDB_table_type</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_type *
RDB_table_type(const RDB_table *tbp)
</pre>

<h3>Description</h3>

<p>RDB_table_type returns a pointer to the type of the table
specified by <var>tbp</var>.

<h3>Return value</h3>

<p>A pointer to the type of the table.

<hr>

<h2 id="set_table_name">RDB_set_table_name</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_set_table_name(RDB_table *tbp, const char *name, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_set_table_name sets the name of the table to <var>name</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_INVALID_ARGUMENT
<dd><var>name</var> is not a valid table name.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="subset">RDB_subset</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_subset(RDB_table *tb1p, RDB_table *tb2p, RDB_transaction *txp, RDB_bool *resultp);
</pre>

<h3>Description</h3>

<p>RDB_subset checks if the table specified by <var>tb1p</var> is a subset
of the table specified by <var>tb2p</var> and stores the result at the
location pointed to by <var>resultp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_TYPE_MISMATCH
<dd>The types of the two tables differ.
<dt>RDB_OPERATOR_NOT_FOUND
<dd>The definition of one of the tables
refers to a non-existing operator.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="add_table">RDB_add_table</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_add_table(RDB_table *tbp, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_add_table adds the table specified by <var>tbp</var> to the
database the transaction specified by <var>txp</var> interacts with.

<p>If the table is a local (transient) table, it is made global
(persistent).

<p>The table must have a name.

<p>Currently, RDB_add_table does not work for local real tables.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_INVALID_ARGUMENT
<dd>The table does not have a name.
<dt>RDB_ELEMENT_EXISTS
<dd>The table is already associated with the database.
<dt>RDB_NOT_SUPPORTED
<dd>The table is a local real table.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="remove_table">RDB_remove_table</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_remove_table(RDB_table *tbp, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_remove_table removes the table specified by <var>tbp</var> from the
database the transaction specified by <var>txp</var> interacts with.

<p>If the table is a global table, it is made local.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_INVALID_ARGUMENT
<dd>The table does not belong the database which the transaction interacts
with.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<h3>Notes</h3>

<p><strong>This function is not implemented.</strong>

<hr>

<h2 id="table_contains">RDB_table_contains</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_table_contains(RDB_table *tbp, const RDB_object *tplp, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_table_contains checks if the tuple specified by <var>tplp</var>
is an element of the table specified by <var>tbp</var>.

<h3>Return value</h3>

<p>If the tuple is an element of the table, RDB_OK is returned.
If the tuple is not an element of the table, RDB_NOT_FOUND is returned.
On failure, an error code different from RDB_NOT_FOUND returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_INVALID_ARGUMENT
<dd>A table attribute is missing in the tuple.
<dt>RDB_TYPE_MISMATCH
<dd>The type of a tuple attribute does not match the type of the
corresponding table attribute.
<dt>RDB_OPERATOR_NOT_FOUND
<dd>The definition of the table specified by <var>tbp</var>
refers to a non-existing operator.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="table_equals">RDB_table_equals</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_table_equals(RDB_table *tb1p, RDB_table *tb2p, RDB_transaction *txp, RDB_bool *resultp);
</pre>

<p>RDB_table_equals checks two tables for equality and stores the result at the
location pointed to by <var>resultp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_TYPE_MISMATCH
<dd>The types of the two tables differ.
<dt>RDB_OPERATOR_NOT_FOUND
<dd>The definition of one of the tables
refers to a non-existing operator.
</dl>

<hr>

<h2 id="all">RDB_all</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_all(RDB_table *tbp, const char *attrname, RDB_transaction *txp,
        RDB_bool *resultp);
</pre>

<h3>Description</h3>

<p>RDB_all computes a logical AND over the attribute
<var>attrname</var> of the table specified by <var>tbp</var>
and stores the result at the location pointed to by <var>resultp</var>.

<p>The attribute <var>attrname</var> must be of type BOOLEAN.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_ATTRIBUTE_NOT_FOUND
<dd>The table does not have an attribute <var>attrname</var>.
<dt>RDB_TYPE_MISMATCH
<dd>The type of the attribute is not BOOLEAN.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="any">RDB_any</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_any(RDB_table *tbp, const char *attrname, RDB_transaction *txp,
        RDB_bool *resultp);
</pre>

<h3>Description</h3>

<p>RDB_any computes a logical OR over the attribute
<var>attrname</var> of the table specified by <var>tbp</var>
and stores the result at the location
pointed to by <var>resultp</var>.

<p>The attribute <var>attrname</var> must be of
type BOOLEAN.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_ATTRIBUTE_NOT_FOUND
<dd>The table does not have an attribute <var>attrname</var>.
<dt>RDB_TYPE_MISMATCH
<dd>The type of the attribute is not BOOLEAN.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="avg">RDB_avg</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_avg(RDB_table *tbp, const char *attrname, RDB_transaction *txp,
        RDB_rational *resultp);
</pre>

<h3>Description</h3>

<p>RDB_avg computes the average over the attribute
<var>attrname</var> of the table specified by <var>tbp</var>
and stores the result at the location
pointed to by <var>resultp</var>.

<p>The attribute <var>attrname</var> must be numeric.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_ATTRIBUTE_NOT_FOUND
<dd>The table does not have an attribute <var>attrname</var>.
<dt>RDB_TYPE_MISMATCH
<dd>The type of the attribute is not numeric.
<dt>RDB_AGGREGATE_UNDEFINED
<dd>The table is empty.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="cardinality">RDB_cardinality</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_cardinality(RDB_table *tbp, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_cardinality returns the number of tuples in
the table pointed to by <var>tbp</var>.

<h3>Return value</h3>

<p>On success, the number of tuples is returned.
On failure, an error code lower than zero is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_OPERATOR_NOT_FOUND
<dd>The definition of the table specified by <var>tbp</var>
refers to a non-existing operator.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="max">RDB_max</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_max(RDB_table *tbp, const char *attrname, RDB_transaction *txp,
        RDB_object *resultp);
</pre>

<h3>Description</h3>

<p>RDB_max computes the maximum over the attribute
<var>attrname</var> of the table specified by <var>tbp</var>
and stores the result at the location pointed to by <var>resultp</var>.

<p>The attribute <var>attrname</var> must be numeric
and the result is of the same type as the attribute.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_ATTRIBUTE_NOT_FOUND
<dd>The table does not have an attribute <var>attrname</var>.
<dt>RDB_TYPE_MISMATCH
<dd>The type of the attribute is not numeric.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="min">RDB_min</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_min(RDB_table *tbp, const char *attrname, RDB_transaction *txp,
        RDB_object *resultp);
</pre>

<h3>Description</h3>

<p>RDB_min computes the minimum over the attribute
<var>attrname</var> of the table specified by <var>tbp</var>
and stores the result at the location pointed to by <var>resultp</var>.

<p>The attribute <var>attrname</var> must be numeric
and the result is of the same type as the attribute.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_ATTRIBUTE_NOT_FOUND
<dd>The table does not have an attribute <var>attrname</var>.
<dt>RDB_TYPE_MISMATCH
<dd>The type of the attribute is not numeric.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="sum">RDB_sum</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_sum(RDB_table *tbp, const char *attrname, RDB_transaction *txp,
        RDB_object *resultp);
</pre>

<h3>Description</h3>

<p>RDB_sum computes the sum over the attribute
<var>attrname</var> of the table pointed to by <var>tbp</var>
and stores the result at the location pointed to by <var>resultp</var>.

<p>The attribute <var>attrname</var> must be numeric
and the result is of the same type as the attribute.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_ATTRIBUTE_NOT_FOUND
<dd>The table does not have an attribute <var>attrname</var>.
<dt>RDB_TYPE_MISMATCH
<dd>The type of the attribute is not numeric.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="table_is_empty">RDB_table_is_empty</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_table_is_empty(RDB_table *tbp, RDB_transaction *txp, RDB_bool *resultp);
</pre>

<h3>Description</h3>

<p>RDB_table_is_empty checks if the table specified by <var>tbp</var>
is empty and stores the result of
the check at the location pointed to by <var>resultp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_OPERATOR_NOT_FOUND
<dd>The definition of the table specified by <var>tbp</var>
refers to a non-existing operator.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="insert">RDB_insert</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_insert(RDB_table *tbp, const RDB_object *tplp, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_insert inserts the tuple specified by <var>tplp</var>
into the table specified by <var>tbp</var>.

<p>Currently, RDB_insert is not supported for virtual tables which are the result
of a MINUS, SUMMARIZE, DIVIDEBY PER, GROUP, or UNGROUP.
 
<h3>Return value</h3>

<p>If the insert was successful, RDB_OK is returned.
On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_INVALID_ARGUMENT
<dd>A table attribute is missing in the tuple and no default value
was specified for that attribute.
<dt>RDB_ELEMENT_EXISTS
<dd>The tuple was already an element of the table.
<dt>RDB_KEY_VIOLATION
<dd>Inserting the tuple would result in a table which contains
a key value twice.
<dt>RDB_PREDICATE_VIOLATION
<dd>Inserting the tuple would result in a table which violates its
predicate.
<dt>RDB_TYPE_MISMATCH
<dd>The type of a tuple attribute does not match the type of the
corresponding table attribute.
<dt>RDB_OPERATOR_NOT_FOUND
<dd>The definition of the table specified by <var>tbp</var>
refers to a non-existing operator.
<dt>RDB_NOT_SUPPORTED
<dd>RDB_insert is not supported for this type of table.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="update">RDB_update</h2>

<pre>
#include &lt;rel/rdb.h&gt;

typedef struct {
    char *name;
    RDB_expression *exp;
} RDB_attr_update;

int
RDB_update(RDB_table *tbp, RDB_expression *exp, int updc,
        const RDB_attr_update updv[], RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_update updates all tuples from the table specified by <var>tbp</var>
for which the expression specified by <var>exp</var> evaluates to true.
If <var>exp</var> is NULL, all tuples are updated.

<p>The attributes to be updated are specified by the <var>updv</var> array.
The attribute specified by the field name is set to the value
obtained by evaluating the expression specified by the field exp.

<p>Currently, RDB_update is not supported for virtual tables except select.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.

<dt>RDB_INVALID_ARGUMENT
<dd>One of the attributes in <var>updv</var> does not exist in the table.
<dd>One of the expressions specified in <var>updv</var> refers to an attribute
which does not exist in the table.

<dt>RDB_ELEMENT_EXISTS
<dd>The update operation would update a tuple so that it would be equal
to a tuple which is already an element of the table.

<dt>RDB_KEY_VIOLATION
<dd>The update operation would result in a table which contains
a key value twice.

<dt>RDB_PREDICATE_VIOLATION
<dd>The update operation would result in a table which violates its
predicate.

<dt>RDB_TYPE_MISMATCH
<dd>The type of one of the expressions in <var>updv</var> is not the same
as the type of the corresponding table attribute.

<dt>RDB_OPERATOR_NOT_FOUND
<dd>The definition of the table specified by <var>tbp</var>
refers to a non-existing operator.
<dd>The expression specified by <var>exp</var>
refers to a non-existing operator.
<dd>One of the expressions specified in <var>updv</var>
refers to a non-existing operator.

<dt>RDB_NOT_SUPPORTED
<dd>RDB_update is not supported for this type of table.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="delete">RDB_delete</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_delete(RDB_table *tbp, RDB_expression *exp, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_delete deletes all tuples from the table specified by <var>tbp</var>
for which the expression specified by <var>exp</var> evaluates to true.
If <var>exp</var> is NULL, all tuples are deleted.

<p>Currently, RDB_delete is not supported for virtual tables which are the result of
a JOIN, SUMMARIZE, WRAP, UNWRAP, GROUP, UNGROUP, or DIVIDEBY PER.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_INVALID_ARGUMENT
<dd><var>exp</var> refers to an attribute which does not exist in the table.
<dt>RDB_PREDICATE_VIOLATION
<dd>Deleting the tuples would result in a table which violates its
predicate.
<dt>RDB_OPERATOR_NOT_FOUND
<dd>The definition of the table specified by <var>tbp</var>
refers to a non-existing operator.
<dd>The expression specified by <var>exp</var>
refers to a non-existing operator.
<dt>RDB_NOT_SUPPORTED
<dd>RDB_delete is not supported for this type of table.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="extract_tuple">RDB_extract_tuple</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_extract_tuple(RDB_table *tbp, RDB_transaction *txp, RDB_object *tplp);
</pre>

<h3>Description</h3>

<p>RDB_extract_tuple extracts a single tuple from a table which contains
only one tuple and stores its value in the variable pointed to by <var>tplp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned
and the tuple value of the variable pointed to by <var>tplp</var> is undefined.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_NOT_FOUND
<dd>The table is empty.
<dt>RDB_INVALID_ARGUMENT
<dd>The table contains more than one tuple.
<dt>RDB_OPERATOR_NOT_FOUND
<dd>The definition of the table specified by <var>tbp</var>
refers to a non-existing operator.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="copy_table">RDB_copy_table</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_copy_table(RDB_table *dstp, RDB_table *srcp, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_copy_table copies all tuples from the table specified
by <var>srcp</var> to the table specified by <var>dstp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_TYPE_MISMATCH
<dd>The types of the two tables differ.
<dt>RDB_OPERATOR_NOT_FOUND
<dd>The definition of the table specified by <var>srcp</var>
refers to a non-existing operator.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="rename">RDB_rename</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_rename(RDB_table *tbp, int renc, const <a href="#renaming">RDB_renaming</a> renv[],
           RDB_table **resultpp);
</pre>

<h3>Description</h3>

<p>RDB_rename creates a virtual table which is the result of a relational
RENAME operator on the table specified by <var>tbp</var>.
A pointer to the result table is stored at the location pointed to by
<var>resultpp</var>.

<p>The attributes to be renamed are specified by the arguments
<var>renc</var> and <var>renv</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<p>The call may fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="select">RDB_select</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_select(RDB_table *tbp, RDB_expression *exp, RDB_transaction *txp,
           RDB_table **resultpp);
</pre>

<h3>Description</h3>

<p>RDB_select creates a local (transient) virtual table which contains those
tuples from the table specified by <var>tbp</var> for which the
condition specified by <var>exp</var> evaluates to true.
A pointer to the result table is stored at the location pointed to by
<var>resultpp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_TYPE_MISMATCH
<dd>The condition is not of type BOOLEAN.
<dt>RDB_ATTRIBUTE_NOT_FOUND
<dd>The condition refers to an attribute which is not present in the table.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="extend">RDB_extend</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_extend(RDB_table *, int attrc, const <a href="#virtual_attr">RDB_virtual_attr</a> attrv[],
        RDB_transaction *txp, RDB_table **resultpp);
</pre>

<h3>Description</h3>

<p>RDB_extend creates a local (transient) virtual table which is the result of a relational
EXTEND operator on the table specified by <var>tbp</var>.

<p>The new table will have <var>attrc</var> additional attributes.
The values of these attributes are obtained by evaluating the
exp fields of the elements of <var>attrv</var>.

<p>If the operation is successful, the new table takes responsibility
for the expressions in <var>attrv</var>. These expressions are
automatically dropped when the table is dropped.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_ARGUMENT
<dd>An invalid attribute name has been specified.
</dl>

<hr>

<h2 id="project">RDB_project</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_project(RDB_table *, int attrc, char *attrv[], RDB_table **resultpp);
</pre>

<h3>Description</h3>

<p>RDB_project creates a relational projection over the table specified
by <var>tbp</var>.

<p>The attributes of the new table are specified by <var>attrc</var>
and <var>attrv</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_ATTRIBUTE_NOT_FOUND
<dd>One of the attributes specified by <var>attrv</var> is not an attribute
of the original table.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="remove">RDB_remove</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_remove(RDB_table *, int attrc, char *attrv[], RDB_table **resultpp);
</pre>

<h3>Description</h3>

<p>RDB_remove creates a relational projection over the table specified
by <var>tbp</var>.

<p>The new table has the attributes of the original table except those
specified by <var>attrc</var> and <var>attrv</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_ATTRIBUTE_NOT_FOUND
<dd>One of the attributes specified by <var>attrv</var> is not an attribute
of the original table.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="join">RDB_join</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_join(RDB_table *tb1p, RDB_table *tb2p, RDB_table **resultpp);
</pre>

<h3>Description</h3>

<p>RDB_join creates a local (transient) virtual table which is a natural join
of the two tables specified by <var>tb1p</var> and <var>tb2p</var>.

<p>If the two tables have no common attribute, the result becomes
a cartesian product.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_TYPE_MISMATCH
<dd>The two tables have an attribute with the same name, but with
different types.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="union">RDB_union</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_union(RDB_table *, RDB_table *, RDB_table **resultpp);
</pre>

<h3>Description</h3>

<p>RDB_union creates a local (transient) virtual table which is the
result of a relational UNION of the two tables, that is,
it contains the tuples from both tables. A pointer to the
new RDB_table is stored in <var>resultpp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_TYPE_MISMATCH
<dd>The types of the two tables differ.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="intersect">RDB_intersect</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_intersect(RDB_table *, RDB_table *, RDB_table **resultpp);
</pre>

<h3>Description</h3>

<p>RDB_intersect creates a local (transient) virtual table which is the
result of a relational INTERSECT of the two tables, that is,
it contains the tuples which both tables contain.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_TYPE_MISMATCH
<dd>The types of the two tables differ.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="minus">RDB_minus</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_minus(RDB_table *, RDB_table *, RDB_table **resultpp);
</pre>

<h3>Description</h3>

<p>RDB_intersect creates a local (transient) virtual table which is the
result of a relational MINUS of the two tables, that is,
it contains the tuples from the first table,
except those which the second table contains.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_TYPE_MISMATCH
<dd>The types of the two tables differ.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="sdivide">RDB_sdivide</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_sdivide(RDB_table *, RDB_table *, RDB_table *, RDB_table **resultpp);
</pre>

<h3>Description</h3>

<p>RDB_sdivide creates a local (transient) virtual table which is the
result of a small divide of the three tables.

<p>Table #3 must be of the same type as the join of table #1 and table #2.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_TYPE_MISMATCH
<dd>Table #1 and table #2 have an attribute with the same name, but a
different type.
<dt>RDB_NOT_SUPPORTED
<dd>Table #3 is not of the same type as the join of table #1 and table #2.
</dl>

<hr>

<h2 id="gdivide">RDB_gdivide</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_gdivide(RDB_table *, RDB_table *, RDB_table *, RDB_table *,
           RDB_table **resultpp);
</pre>

<h3>Description</h3>

<p>RDB_gdivide creates a local (transient) virtual table which is the
result of a great divide of the four tables.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Notes</h3>

<p><strong>This function is not implemented.</strong>

<hr>

<h2 id="summarize">RDB_summarize</h2>

<pre>
#include &lt;rel/rdb.h&gt;

typedef struct {
    <a href="#aggregate_op">RDB_aggregate_op</a> op;
    RDB_expression *exp;
    char *name;
} RDB_summarize_add;

int
RDB_summarize(RDB_table *tb1p, RDB_table *tb2p, int addc,
              const RDB_summarize_add addv[], RDB_transaction *txp,
              RDB_table **resultpp);
</pre>

<h3>Description</h3>

<p>RDB_summarize creates a local (transient) virtual table which is the result
of a SUMMARIZE T1 PER T2 (ADD1, ...), where T1 is the table specified by
<var>tb1p</var>, T2 is the table specified by <var>tb2p</var>, and ADD1 ...
is specified by <var>addc</var> and <var>addv</var>.
A pointer to the result table is stored in resultpp.

<p>The two argument tables must not share an unnamed child table.

<p>Currently, COUNTD, SUMD, and AVGD are not supported.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_NOT_SUPPORTED
<dd>The field op of one of the elements of <var>addv</var>
is COUNTD, SUMD, or AVGD.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="wrap">RDB_wrap</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_wrap(RDB_table *tbp, int wrapc, const <a href="#wrapping">RDB_wrapping</a> wrapv[],
         RDB_table **resultpp);
</pre>

<h3>Description</h3>

<p>RDB_wrap creates a local (transient) virtual table which is the result of a
relational WRAP operator.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_ATTRIBUTE_NOT_FOUND
<dd>An attribute specified by wrapv[i].attrv does not exist.
</dl>

<hr>

<h2 id="unwrap">RDB_unwrap</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_unwrap(RDB_table *, int attrc, char *attrv[], RDB_table **);
</pre>

<h3>Description</h3>

<p>RDB_wrap creates a local (transient) virtual table which is the result of a
relational UNWRAP operator.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_ATTRIBUTE_NOT_FOUND
<dd>An attribute specified by <var>attrv</var> does not exist.
<dt>RDB_INVALID_ARGUMENT
<dd>An attribute specified by <var>attrv</var> is not tuple-typed.
</dl>

<hr>

<h2 id="group">RDB_group</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_group(RDB_table *, int attrc, char *attrv[], const char *gattr,
         RDB_table **resultpp);
</pre>

<h3>Description</h3>

<p>RDB_group creates a local (transient) virtual table which is the result of a
relational GROUP operator. The attributes specified by <var>attrc</var>
and <var>attrv</var> are grouped into a relation-valued attribute
<var>gattr</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_ATTRIBUTE_NOT_FOUND
<dd>An attribute specified by <var>attrv</var> does not exist.
<dt>RDB_INVALID_ARGUMENT
<dd>The attribute <var>gattr</var> already appears in the table,
but not in <var>attrv</var>.
</dl>

<hr>

<h2 id="ungroup">RDB_ungroup</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_ungroup(RDB_table *, const char *attr, RDB_table **resultpp);
</pre>

<h3>Description</h3>

<p>RDB_wrap creates a local (transient) virtual table which is the result of a
relational UNGROUP operator.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<dl>
<dt>RDB_ATTRIBUTE_NOT_FOUND
<dd>The attribute <var>attr</var> does not exist.
<dt>RDB_INVALID_ARGUMENT
<dd>The attribute <var>attr</var> is not relation-typed.
<dd>A sub-attribute of <var>attr</var> clashes wth a table attribute.
</dl>

<hr>

<h2 id="join_tuples">RDB_join_tuples</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_join_tuples(const RDB_object *tpl1p, const RDB_object *tpl2p,
                RDB_transaction *txp, RDB_object *restplp);
</pre>

<h3>Description</h3>

<p>RDB_join creates a tuple which contains the attributes
of the two tuples specified by <var>tpl1p</var> and <var>tpl2p</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_TYPE_MISMATCH
<dd>The two tuples have an attribute with the same name, but with
different types.
<dt>RDB_INVALID_ARGUMENT
<dd>The two tuples have an attribute with the same name, but with
different values.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="project_tuple">RDB_project_tuple</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_project_tuple(const RDB_object *, int attrc, char *attrv[],
                  RDB_object *restplp);
</pre>

<h3>Description</h3>

<p>RDB_project_tuple creates a tuple which contains only the attributes
specified by <var>attrc</var> and <var>attrv</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_ATTRIBUTE_NOT_FOUND
<dd>One of the attributes specified by <var>attrv</var> is not an attribute
of the original tuple.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="tuple_set">RDB_tuple_set</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_tuple_set(RDB_object *tplp, const char *name, const RDB_object *valp);
</pre>

<h3>Description</h3>

<p>RDB_tuple_set sets the attribute <var>name</var> of the tuple
variable specified by <var>tplp</var> to the value specified by
<var>valp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<p>The call may fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="tuple_set_bool">RDB_tuple_set_bool</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_tuple_set_bool(RDB_object *tplp, const char *name, RDB_bool val);
</pre>

<h3>Description</h3>

<p>RDB_tuple_set_bool sets the attribute <var>name</var> of the tuple
variable specified by <var>tplp</var> to the boolean value specified by
<var>val</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<p>The call may fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="tuple_set_int">RDB_tuple_set_int</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_tuple_set_int(RDB_object *tplp, const char *name, RDB_int val);
</pre>

<h3>Description</h3>

<p>RDB_tuple_set_int sets the attribute <var>name</var> of the tuple
variable specified by <var>tplp</var> to the integer value specified by
<var>val</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<p>The call may fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="tuple_set_rational">RDB_tuple_set_rational</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_tuple_set_rational(RDB_object *tplp, const char *name, RDB_rational val);
</pre>

<h3>Description</h3>

<p>RDB_tuple_set_int sets the attribute <var>name</var> of the tuple
variable specified by <var>tplp</var> to the rational value specified by
<var>val</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<p>The call may fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="tuple_set_string">RDB_tuple_set_string</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_tuple_set_string(RDB_object *tplp, const char *name, const char *str);
</pre>

<h3>Description</h3>

<p>RDB_tuple_set_int sets the attribute <var>name</var> of the tuple
variable specified by <var>tplp</var> to the string value specified by
<var>str</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<p>The call may fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="tuple_size">RDB_tuple_size</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_int
RDB_tuple_size(const RDB_object *tplp);
</pre>

<h3>Description</h3>

<p>RDB_tuple_size determines the number of attributes of the tuple
specified by <var>tplp</var>.

<h3>Return value</h3>

<p>The number of attributes.

<hr>

<h2 id="tuple_attr_names">RDB_tuple_attr_names</h2>

<pre>
#include &lt;rel/rdb.h&gt;

void
RDB_tuple_attr_names(const RDB_object *, char **namev);
</pre>

<h3>Description</h3>

<p>RDB_tuple_attr_names fills <var>namev</var> with pointers to
the attribute names of the tuple specified by <var>tplp</var>.

<p><var>namev</var> must be large enough for all attribute names.
The pointers must not be modified by the caller and will become invalid
when the tuple is destroyed.

<h3>Return value</h3>

<p>None.

<hr>

<h2 id="tuple_get">RDB_tuple_get</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_object *
RDB_tuple_get(const RDB_object *, const char *name);
</pre>

<h3>Description</h3>

<p>RDB_tuple_get returns a pointer to a RDB_object structure
which contains the value for attribute <var>name</var>.
The value is not copied.

<h3>Return value</h3>

<p>A pointer to the value of the attribute, or NULL if no
attribute with that name exists.

<hr>

<h2 id="tuple_get_bool">RDB_tuple_get_bool</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_bool
RDB_tuple_get_bool(const RDB_object *, const char *name);
</pre>

<h3>Description</h3>

<p>RDB_tuple_get_bool returns the value of attribute <var>name</var>
as a RDB_bool. The attribute must exist and it must be of
type BOOLEAN.

<h3>Return value</h3>

<p>The attribute value.

<hr>

<h2 id="tuple_get_int">RDB_tuple_get_int</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_int
RDB_tuple_get_int(const RDB_object *, const char *name);
</pre>

<h3>Description</h3>

<p>RDB_tuple_get_int returns the value of attribute <var>name</var>
as a RDB_int. The attribute must exist and it must be of
type INTEGER.

<h3>Return value</h3>

<p>The attribute value.

<hr>

<h2 id="tuple_get_rational">RDB_tuple_get_rational</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_rational
RDB_tuple_get_rational(const RDB_object *, const char *name);
</pre>

<h3>Description</h3>

<p>RDB_tuple_get_rational returns the value of attribute <var>name</var>
as a RDB_rational. The attribute must exist and it must be of
type RATIONAL.

<h3>Return value</h3>

<p>The attribute value.

<hr>

<h2 id="tuple_get_string">RDB_tuple_get_string</h2>

<pre>
#include &lt;rel/rdb.h&gt;

char *
RDB_tuple_get_string(const RDB_object *, const char *name);
</pre>

<h3>Description</h3>

<p>RDB_tuple_get_string returns a pointer to the value of attribute
<var>name</var>. The attribute must exist and it must be of
type STRING.

<h3>Return value</h3>

<p>A pointer to the attribute value.

<hr>

<h2 id="extend_tuple">RDB_extend_tuple</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_extend_tuple(RDB_object *tplp, int attrc, const <a href="#virtual_attr">RDB_virtual_attr</a> attrv[],
                 RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_extend_tuple extends the tuple specified by <var>tplp</var>
by the attributes specified by <var>attrc</var> and <var>attrv</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_ARGUMENT
<dd>One of the expressions specified in <var>updv</var> refers to an attribute
which does not exist in the tuple.
<dt>RDB_OPERATOR_NOT_FOUND
<dd>One of the expressions specified in <var>updv</var> refers to an
operator which does not exist.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="rename_tuple">RDB_rename_tuple</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_rename_tuple(const RDB_object *, int renc, const <a href="#renaming">RDB_renaming</a> renv[],
                 RDB_object *restplp);
</pre>

<h3>Description</h3>

<p>RDB_rename_tuple creates copies the tuple specified by <var>tplp</var>
to the tuple specified by <var>restplp</var>, renaming the attributes
specified by <var>renc</var> and <var>renv</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<p>The call may fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="wrap_tuple">RDB_wrap_tuple</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_wrap_tuple(const RDB_object *tplp, int wrapc, const <a href="#wrapping">RDB_wrapping</a> wrapv[],
               RDB_object *restplp);
</pre>

<h3>Description</h3>

<p>RDB_wrap_tuple performs a tuple WRAP operator on the tuple pointed to by
<var>tplp</var> and stores the result in the variable pointed to by
<var>restplp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_ATTRIBUTE_NOT_FOUND
<dd>One or more of the attributes specified by wrapv[i].attrv does not
exist.
</dl>

<hr>

<h2 id="unwrap_tuple">RDB_unwrap_tuple</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_unwrap_tuple(const RDB_object *tplp, int attrc, const char *attrv[],
        RDB_object *restplp);
</pre>

<h3>Description</h3>

<p>RDB_unwrap_tuple performs a tuple UNWRAP operator on the tuple pointed to by
<var>tplp</var> and stores the result in the variable pointed to by
<var>restplp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_ATTRIBUTE_NOT_FOUND
<dd>An attribute specified by attrv does not exist.
<dt>RDB_INVALID_ARGUMENT
<dd>An attribute specified by attrv is not tuple-typed.
</dl>

<hr>

<h2 id="init_obj">RDB_init_obj</h2>

<pre>
#include &lt;rel/rdb.h&gt;

void
RDB_init_obj(RDB_object *valp);
</pre>

<h3>Description</h3>

<p>RDB_init_obj initializes the variable pointed to by
<var>valp</var>. RDB_init_obj must be called before any other
operation can be performed on a RDB_object variable.

<hr>

<h2 id="destroy_obj">RDB_destroy_obj</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_destroy_obj(RDB_object *valp);
</pre>

<h3>Description</h3>

<p>RDB_destroy_obj frees all resources associated with a RDB_obj
variable.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<hr>

<h2 id="obj_equals">RDB_obj_equals</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_obj_equals(const RDB_object *, const RDB_object *, RDB_transaction *txp,
               RDB_bool *resp);
</pre>

<h3>Description</h3>

<p>RDB_obj_equals checks two RDB_object variables for equality
and stores the result in the variable pointed to by <var>resp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<hr>

<h2 id="copy_obj">RDB_copy_obj</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_copy_obj(RDB_object *dstvalp, const RDB_object *srcvalp);
</pre>

<h3>Description</h3>

<p>RDB_copy_obj copies the value of the RDB_object pointed to
by <var>srcp</var> to the RDB_object pointed to by <var>dstp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<p>The call may fail for a <a href="#syserr">system error</a>.

<h3>Notes</h3>

<p>If the object specified by <var>srcvalp</var> is table-valued,
the table is not copied. After RDB_obj_copy was invoked, the two
RDB_objects will share the same RDB_table.

<hr>

<h2 id="bool_to_obj">RDB_bool_to_obj</h2>

<pre>
#include &lt;rel/rdb.h&gt;

void
RDB_bool_to_obj(RDB_object *valp, RDB_bool v);
</pre>

<h3>Description</h3>

<p>RDB_bool_to_obj sets the RDB_object pointed to by <var>valp</var>
to the boolean value specified by <var>v</var>.

<p>The RDB_object must either be newly initialized or of type
BOOLEAN.

<hr>

<h2 id="int_to_obj">RDB_int_to_obj</h2>

<pre>
#include &lt;rel/rdb.h&gt;

void
RDB_int_to_obj(RDB_object *valp, RDB_int v);
</pre>

<h3>Description</h3>

<p>RDB_int_to_obj sets the RDB_object pointed to by <var>valp</var>
to the integer value specified by <var>v</var>.

<p>The RDB_object must either be newly initialized or of type
INTEGER.

<hr>

<h2 id="rational_to_obj">RDB_rational_to_obj</h2>

<pre>
#include &lt;rel/rdb.h&gt;

void
RDB_rational_to_obj(RDB_object *valp, RDB_rational v);
</pre>

<h3>Description</h3>

<p>RDB_rational_to_obj sets the RDB_object pointed to by <var>valp</var>
to the rational value specified by <var>v</var>.

<p>The RDB_object must either be newly initialized or of type
RATIONAL.

<hr>

<h2 id="string_to_obj">RDB_string_to_obj</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_string_to_obj(RDB_object *valp, const char *str);
</pre>

<h3>Description</h3>

<p>RDB_string_to_obj sets the RDB_object pointed to by <var>valp</var>
to the string value specified by <var>str</var>.

<p>The RDB_object must either be newly initialized or of type
STRING.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<hr>

<h2 id="obj_bool">RDB_obj_bool</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_bool
RDB_obj_bool(const RDB_object *valp);
</pre>

<h3>Description</h3>

<p>RDB_obj_bool returns the value of the RDB_object pointed to by
<var>valp</var> as a RDB_bool. The RDB_object must be of type
BOOLEAN.

<h3>Return value</h3>

<p>The value of the RDB_object.

<hr>

<h2 id="obj_int">RDB_obj_int</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_int
RDB_obj_int(const RDB_object *valp);
</pre>

<h3>Description</h3>

<p>RDB_obj_int returns the value of the RDB_object pointed to by
<var>valp</var> as a RDB_int. The RDB_object must be of type
INTEGER.

<h3>Return value</h3>

<p>The value of the RDB_object.

<hr>

<h2 id="obj_rational">RDB_obj_rational</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_rational
RDB_obj_rational(const RDB_object *valp);
</pre>

<h3>Description</h3>

<p>RDB_obj_rational returns the value of the RDB_object pointed to by
<var>valp</var> as a RDB_rational. The RDB_object must be of type
RATIONAL.

<h3>Return value</h3>

<p>The value of the RDB_object.

<hr>

<h2 id="obj_string">RDB_obj_string</h2>

<pre>
#include &lt;rel/rdb.h&gt;

char *
RDB_obj_string(const RDB_object *valp);
</pre>

<h3>Description</h3>

<p>RDB_obj_string returns a pointer to the value of the RDB_object pointed to by
<var>valp</var> as a char *. The RDB_object must be of type STRING.

<h3>Return value</h3>

<p>The string value of the RDB_object.

<hr>

<h2 id="obj_table">RDB_obj_table</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_table *
RDB_obj_table(const RDB_object *valp);
</pre>

<h3>Description</h3>

<p>RDB_obj_table returns a pointer to the table wrapped by the RDB_object pointed to by
<var>valp</var>.

<h3>Return value</h3>

<p>A pointer to the table wrapped by the RDB_object, or NULL if the object
does not wrap a table.

<hr>

<h2 id="table_to_obj">RDB_table_to_obj</h2>

<pre>
#include &lt;rel/rdb.h&gt;

void
RDB_table_to_obj(RDB_object *objp, RDB_table *tbp);

</pre>

<h3>Description</h3>

<p>RDB_table_to_obj wraps the table specified by <var>tbp</var> into
the RDB_object pointed to by <var>objp</var>.

<hr>

<h2 id="obj_comp">RDB_obj_comp</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_obj_comp(const RDB_object *valp, const char *compname,
             RDB_object *comp, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_obj_comp copies the value of component <var>compname</var>
of a possible representation of the variable pointed to by <var>valp</var>
to the variable pointed to by <var>comp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_ARGUMENT
<dd>The type of the variable pointed to by <var>valp</var> ist not
a scalar user-defined type.
<dt>RDB_OPERATOR_NOT_FOUND
<dd>The getter method for component <var>compname</var> has not been created.
</dl>

<p>RDB_obj_comp may also return an error code returned by a
user-provided getter function.

<p>The call may also fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="obj_set_comp">RDB_obj_set_comp</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_obj_set_comp(RDB_object *valp, const char *compname,
                 const RDB_object *comp, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_obj_set_comp sets the the value of component <var>compname</var>
of a possible representation of the RDB_object specified to by <var>valp</var>
to the value of the variable pointed to by <var>comp</var>.

<p>The RDB_object must be of a type which has a component
<var>compname</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<hr>

<h2 id="binary_set">RDB_binary_set</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_binary_set(RDB_object *, size_t pos, const void *srcp, size_t len);
</pre>

<h3>Description</h3>

<p>RDB_binary_set copies <var>len</var> bytes from srcp to
the position <var>pos</var> in the RDB_object pointed to by <var>valp</var>.
<var>valp</var> must point either to a new initialized RDB_object
or to a RDB_object of type BINARY.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<p>The call may fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="binary_get">RDB_binary_get</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_binary_get(const RDB_object *, size_t pos, void **pp, size_t len, size_t *alenp);
</pre>

<h3>Description</h3>

<p>RDB_binary_get obtains a pointer to <var>len</var> bytes starting at position
<var>pos</var> of the RDB_object pointed to by <var>valp</var>
and stores this pointer at the location pointed to by <var>pp</var>.
If the sum of <var>pos</var> and <var>len</var> exceeds the length of the
object, the length of the byte block will be lower than requested.

<p>If <var>alenp</var> is not NULL, the actual length of the byte block is stored
at the location pointed to by <var>alenp</var>.

<p><var>valp</var> must point to a RDB_object of type BINARY.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<p>The call may fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="binary_length">RDB_binary_length</h2>

<pre>
#include &lt;rel/rdb.h&gt;

size_t
RDB_binary_length(const RDB_object *valp);
</pre>

<h3>Description</h3>

<p>RDB_binary_length determines the number of bytes stored in the
RDB_object pointed to by <var>valp</var>. The RDB_object
must be of type BINARY.

<h3>Return value</h3>

<p>The length of the RDB_object.

<hr>

<h2 id="obj_irep">RDB_obj_irep</h2>

<pre>
#include &lt;rel/rdb.h&gt;

void *
RDB_obj_irep(RDB_object *valp, size_t *lenp);
</pre>

<h3>Description</h3>

<p>RDB_obj_irep returns a pointer to the binary internal representation of
the variable specified by <var>valp</var>.
If lenp is not NULL, the size of the internal representation
is stored at the location pointed to by <var>lenp</var>.

<p>RDB_obj_irep only works types with a binary internal representation.
These are built-in types and user-defined types
which use a built-in type or a byte array as actual representation.

<h3>Return value</h3>

<p>A pointer to the internal representation.

<hr>

<h2 id="create_db_from_env">RDB_create_db_from_env</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_create_db_from_env(const char *name, RDB_environment *envp, RDB_database **dbpp);
</pre>

<h3>Description</h3>

<p>RDB_create_db_from_env creates a database from a database environment.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<hr>

<h2 id="get_db_from_env">RDB_get_db_from_env</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_get_db_from_env(const char *name, RDB_environment *envp, RDB_database **dbpp);
</pre>

<h3>Description</h3>

<p>RDB_get_db_from_env obtains a pointer to the database with name
<var>name</var> in the environment specified by <var>envp</var>
and stores this pointer at the location pointed to by <var>dbpp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<hr>

<h2 id="drop_db">RDB_drop_db</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_drop_db(RDB_database *dbp);
</pre>

<h3>Description</h3>

<p>RDB_drop_db deletes the database specified by <var>dbp</var>.
If deleting non-empty databases is supported, all tables
which belong only to this database are also deleted.
Wheter or not deleting non-empty databases is supported
is implementation-dependent.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_NOT_FOUND
<dd>The database was not found.
<dt>RDB_ELEMENT_EXISTS
<dd>The database is not empty and dropping non-empty databases is not
supported.
</dl>

<hr>

<h2 id="db_name">RDB_db_name</h2>

<pre>
#include &lt;rel/rdb.h&gt;

char *
RDB_db_name(RDB_database *dbp)
</pre>

<h3>Description</h3>

<p>RDB_db_name returns a pointer to the name of the database
specified by <var>dbp</var>.

<h3>Return value</h3>

<p>The name of the database.

<hr>

<h2 id="db_env">RDB_db_env</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_environment *
RDB_db_env(RDB_database *dbp);
</pre>

<h3>Description</h3>

<p>RDB_db_env returns a pointer to the database environment of the database
specified by <var>dbp</var>.

<h3>Return value</h3>

<p>A pointer to the database environment.

<hr>

<h2 id="begin_tx">RDB_begin_tx</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_begin_tx(RDB_transaction *txp, RDB_database *dbp,
        RDB_transaction *parentp);
</pre>

<h3>Description</h3>

<p>RDB_begin_tx starts a transaction which interacts with the
database specified by <var>dbp</var>.

<p>If <var>parentp</var> is not NULL, the new transaction is
a subtransaction of the transaction specified by <var>parentp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<hr>

<h2 id="commit">RDB_commit</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_commit(RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_commit commits the transaction pointed to by <var>txp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="rollback">RDB_rollback</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_rollback(RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_rollback terminates the transaction pointed to by <var>txp</var>
and rolls back all changes made by this transaction and its subtrabsactions.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="tx_db">RDB_tx_db</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_database *
RDB_tx_db(RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_tx_db determines the database the transaction pointed
to by <var>txp</var> interacts with.

<h3>Return value</h3>

<p>A pointer the RDB_database structure that represents the database.

<hr>

<h2 id="tx_is_running">RDB_tx_is_running</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_bool
RDB_tx_is_running(RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_tx_is_running determines if <var>txp</var> points to a running
transaction.

<h3>Return value</h3>

<p>RDB_TRUE if the transaction is running, RDB_FALSE otherwise.

<hr>

<h2 id="table_to_array">RDB_table_to_array</h2>

<pre>
#include &lt;rel/rdb.h&gt;

typedef struct {
    char *attrname;
    RDB_bool asc;
} RDB_seq_item;

int
RDB_table_to_array(RDB_object *arrp, RDB_table *tbp,
                   int seqitc, const RDB_seq_item seqitv[],
                   RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_table_to_array creates an array which contains
all tuples from the table specified by <var>tbp</var>.
If <var>seqitc</var> is zero, the order of the tuples is undefined.
If <var>seqitc</var> is greater than zero, the order of the tuples
is specified by <var>seqitv</var>.

<h3>Return value</h3>

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_OPERATOR_NOT_FOUND
<dd>The definition of the table specified by <var>tbp</var>
refers to a non-existing operator.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<h3>Notes</h3>

<p>An RDB_array created by RDB_table_to_array becomes invalid after the
end of the transaction in which it was created.

<p>The table from which a RDB_array was created must not be dropped before
the array is destroyed.

<hr>

<h2 id="array_get">RDB_array_get</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_array_get(RDB_object *, RDB_int idx, RDB_object **tplpp);
</pre>

<h3>Description</h3>

<p>RDB_array_get stores a pointer to the tuple at index <var>idx</var>
at the location pointed to by <var>tplpp</var>. This pointer may become
invalid after the next invocation of RDB_array_get.
The pointer will become invalid when the array is destroyed.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_NOT_FOUND
<dd><var>idx</var> exceeds the array length.
<dt>RDB_OPERATOR_NOT_FOUND
<dd>The array was created from a table which refers to a non-existing
operator.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="array_set">RDB_array_set</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_array_set(RDB_object *, RDB_int idx, const RDB_object *tplp);
</pre>

<h3>Description</h3>

<p>RDB_array_set copies the tuple pointed to by tplp
into the RDB_object at index <var>idx</var>.

<p>RDB_array_set is not supported for arrays which have been created
using RDB_table_to_array.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_NOT_FOUND
<dd><var>idx</var> exceeds the array length.
<dt>RDB_NOT_SUPPORTED
<dd>The table has been created using RDB_table_to_array.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="array_length">RDB_array_length</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_int
RDB_array_length(RDB_object *);
</pre>

<h3>Description</h3>

<p>RDB_array_length determines the length of an array.

<h3>Return value</h3>

<p>The length of the array. A return code lower than zero
indicates an error.

<h3>Errors</h3>

<dl>
<dt>RDB_OPERATOR_NOT_FOUND
<dd>The array was created from a table which refers to a non-existing
operator.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="set_array_length">RDB_set_array_length</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_set_array_length(RDB_object *arrp, RDB_int len);
</pre>

<h3>Description</h3>

<p>RDB_set_array_length sets the length of the array specified by
<var>arrp</var>.

<p>RDB_array_set is not supported for arrays which have been created
using RDB_table_to_array.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_NOT_SUPPORTED
<dd>The array has been created using RDB_table_to_array.
</dl>

<hr>

<h2 id="expr_is_const">RDB_expr_is_const</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_bool
RDB_expr_is_const(const RDB_expression *);
</pre>

<h3>Description</h3>

<p>RDB_expr_is_const determines if the expression is a constant expression.

<h3>Return value</h3>

<p>RDB_TRUE if the expression is a constant expression, RDB_FALSE otherwise.

<h3>Errors</h3>

<hr>

<h2 id="bool_to_expr">RDB_bool_to_expr</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_expression *
RDB_bool_to_expr(RDB_bool);
</pre>

<h3>Description</h3>

<p>RDB_bool_to_expr creates a constant expression of type BOOLEAN.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="int_to_expr">RDB_int_to_expr</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_expression *
RDB_int_to_expr(RDB_int);
</pre>

<h3>Description</h3>

<p>RDB_int_to_expr creates a constant expression of type INTEGER.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="rational_to_expr">RDB_rational_to_expr</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_expression *
RDB_rational_to_expr(RDB_rational);
</pre>

<h3>Description</h3>

<p>RDB_rational_to_expr creates a constant expression of type RATIONAL.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="string_to_expr">RDB_string_to_expr</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_expression *
RDB_string_to_expr(const char *);
</pre>

<h3>Description</h3>

<p>RDB_string_to_expr creates a constant expression of type STRING.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="obj_to_expr">RDB_obj_to_expr</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_expression *
RDB_obj_to_expr(const RDB_object *valp);
</pre>

<h3>Description</h3>

<p>RDB_obj_to_expr creates a constant expression from a RDB_object.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="expr_attr">RDB_expr_attr</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_expression *
RDB_expr_attr(const char *attrname);
</pre>

<h3>Description</h3>

<p>RDB_expr_attr creates an expression that represents an attribute.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="eq">RDB_eq</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_expression *
RDB_eq(RDB_expression *, RDB_expression *);
</pre>

<h3>Description</h3>

<p>RDB_eq creates an expression that represents an "is equal" operator.
If one of the arguments is NULL, NULL is returned.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="table_to_expr">RDB_table_to_expr</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_expression *
RDB_table_to_expr(RDB_table *);
</pre>

<h3>Description</h3>

<p>RDB_table_to_expr creates an expression that represents a table.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="tuple_attr">RDB_tuple_attr</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_expression *
RDB_tuple_attr(RDB_expression *, const char *attrname);
</pre>

<h3>Description</h3>

<p>RDB_tuple_attr creates an expression that represents a tuple attribute
extraction.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="expr_any">RDB_expr_any</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_expression *
RDB_expr_any(RDB_expression *, const char *attrname);
</pre>

<h3>Description</h3>

<p>RDB_expr_any creates an expression which represents the <a
href="#any">RDB_any</a> operator.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="expr_all">RDB_expr_all</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_expression *
RDB_expr_all(RDB_expression *, const char *attrname);
</pre>

<h3>Description</h3>

<p>RDB_expr_all creates an expression which represents the <a
href="#all">RDB_all</a> operator.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="expr_avg">RDB_expr_avg</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_expression *
RDB_expr_avg(RDB_expression *, const char *attrname);
</pre>

<h3>Description</h3>

<p>RDB_expr_avg creates an expression which represents the <a
href="#avg">RDB_avg</a> operator.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="expr_max">RDB_expr_max</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_expression *
RDB_expr_max(RDB_expression *, const char *attrname);
</pre>

<h3>Description</h3>

<p>RDB_expr_max creates an expression which represents the <a
href="#max">RDB_max</a> operator.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="expr_min">RDB_expr_min</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_expression *
RDB_expr_min(RDB_expression *, const char *attrname);
</pre>

<h3>Description</h3>

<p>RDB_expr_min creates an expression which represents the <a
href="#min">RDB_min</a> operator.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="expr_sum">RDB_expr_sum</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_expression *
RDB_expr_sum(RDB_expression *, const char *attrname);
</pre>

<h3>Description</h3>

<p>RDB_expr_sum creates an expression which represents the <a
href="#sum">RDB_sum</a> operator.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="expr_comp">RDB_expr_comp</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_expression *
RDB_expr_comp(RDB_expression *arg, const char *compname);
</pre>

<h3>Description</h3>

<p>RDB_expr_comp creates an expression which evaluates to a
possible representation component.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="ro_op">RDB_ro_op</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_expression *
RDB_ro_op(const char *opname, int argc, RDB_expression *argv[]);
</pre>

<h3>Description</h3>

<p>RDB_ro_op creates an expression which represents the invocation
of a user-defined operator.

<h3>Return value</h3>

<p>On success, a pointer to the newly created expression is returned.
If the expression could not be created due to insufficient memory,
NULL is returned.

<hr>

<h2 id="ro_op_va">RDB_ro_op_va</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_expression *
RDB_ro_op_va(const char *opname, RDB_expression *arg, ... /* (RDB_expression *) NULL */ );
</pre>

<h3>Description</h3>

<p>RDB_ro_op_va creates an expression which represents the invocation
of a user-defined operator. The arguments are passed as a variable argument
list, delimited by a NULL.

<h3>Return value</h3>

<p>On success, a pointer to the newly created expression is returned.
If the expression could not be created due to insufficient memory,
NULL is returned.

<hr>

<h2 id="drop_expr">RDB_drop_expr</h2>

<pre>
#include &lt;rel/rdb.h&gt;

void
RDB_drop_expr(RDB_expression *exp);
</pre>

<h3>Description</h3>

<p>RDB_drop_expr destroys the expression specified to by <var>exp</var>
(including all subexpressions) and frees all resources associated with it.

<h3>Return value</h3>

<h3>Errors</h3>

<hr>

<h2 id="define_type">RDB_define_type</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_define_type(const char *name, int repc, const <a href="#possrep">RDB_possrep</a> repv[],
                RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_define_type defines a type with the name <var>name</var> and
<var>repc</var> possible representations.
The individual possible representations are
described by the elements of <var>repv</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_ELEMENT_EXISTS
<dd>There is already a type with name <var>name</var>.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="implement_type">RDB_implement_type</h2>

<pre>
#include &lt;rel/typeimpl.h&gt;

int
RDB_implement_type(const char *name, RDB_type *arep, RDB_int areplen, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_implement_type implements the user-defined type with name
<var>name</var>. The type must have been defined previously using
RDB_define_type. After RDB_implement_type was inkoved successfully,
this type may be used for local variables and table attributes.

<p>If <var>arep</var> is not NULL, it must point to a type which is used
as the actual representation. The getter, setter, and selector operators
must be provided by the caller.

<p>If <var>arep</var> is NULL and <var>areplen</var> is not -1,
<var>areplen</var> specifies the length, in bytes,
of the actual representation, which then is a fixed-length array of bytes.
The getter, setter, and selector operators
must be provided by the caller.

<p>If <var>arep</var> is NULL and <var>areplen</var> is -1,
the getter and setter operators and the selector operator are provided by Duro.
In this case, the type must have exactly one possible representation,
and this representation becomes the actual representation.

<p>For user-provided setters, getters, and selectors,
the following conventions apply:

<dl>
<dt>Selectors
<dd>A selector is a read-only operator whose name is is the name of a possible
representation. It takes one argument for each component.
<dt>Getters
<dd>A getter is a read-only operator whose name consists of the
type and a component name, separated by "_get_".
It takes one argument. The type of the argument must be the type of
the component.
<dt>Setters
<dd>A setter is an update operator whose name consists of the
type and a component name, separated by "_set_".
It takes two arguments. The first argument is an update argument
and must be of the user-defined type in question.
The second argument is read-only and must be of the type of
the component.
</dl>

<h3>Return value</h3>

<p>On success, RDB_OK is returned. Any other return value indicates an error.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_NOT_FOUND
<dd>The type has not been previously defined.
<dt>RDB_INVALID_ARGUMENT
<dd><var>arep</var> is NULL and <var>areplen</var> is -1,
and the type was defined with more than one possible representation.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="create_tuple_type">RDB_create_tuple_type</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_create_tuple_type(int attrc, const <a href="#attr">RDB_attr</a> attrv[], RDB_type **typp);
</pre>

<h3>Description</h3>

<p>RDB_create_tuple_type creates a tuple type and stores
a pointer to the type at the location pointed to by <var>typp</var>.
The attributes are specified by <var>attrc</var> and <var>attrv</var>.
The fields defaultp and options of RDB_attr are ignored.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. Any other return value indicates an error.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_ARGUMENT
<dd><var>attrv</var> contains two attributes with the same name.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="create_array_type">RDB_create_array_type</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_type *
RDB_create_array_type(RDB_type *typ);
</pre>

<h3>Description</h3>

<p>RDB_create_array_type creates an array type.
The base type is specified by <var>typ</var>.

<h3>Return value</h3>

<p>The new array type, or NULL if the creation failed.

<hr>

<h2 id="create_relation_type">RDB_create_relation_type</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_create_relation_type(int attrc, const <a href="#attr">RDB_attr</a> attrv[], RDB_type **typp);
</pre>

<h3>Description</h3>

<p>RDB_create_relation_type creates a relation type and stores
a pointer to the type at the location pointed to by <var>typp</var>.
The attributes are specified by <var>attrc</var> and <var>attrv</var>.
The fields defaultp and options of RDB_attr are ignored.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. Any other return value indicates an error.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_ARGUMENT
<dd><var>attrv</var> contains two attributes with the same name.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="get_type">RDB_get_type</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_get_type(const char *name, RDB_transaction *, RDB_type **typp);
</pre>

<h3>Description</h3>

<p>RDB_get_type obtains a pointer to RDB_type structure which
represents the type with the name <var>name</var>
and stores that pointer at the location pointed to by <var>typp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. Any other return value indicates an error.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_NOT_FOUND
<dd>A type with the name <var>name</var> could not be found.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="drop_type">RDB_drop_type</h2>

<pre>
#include &lt;rel/rdb.h&gt;

void
RDB_drop_type(RDB_type *typ, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_drop_type destroys the type specified by <var>typ</var>.

<p>If the type is transient, the argument <var>txp</var> is ignored.

<p>It is not possible to destroy built-in types.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. Any other return value indicates an error.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_INVALID_ARGUMENT
<dd>The type is a builtin type.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="type_name">RDB_type_name</h2>

<pre>
#include &lt;rel/rdb.h&gt;

char *
RDB_type_name(const RDB_type *);
</pre>

<h3>Description</h3>

<p>RDB_type_name returns the name of a type.

<h3>Return value</h3>

<p>A pointer to the name of the type or NULL if the type has no name.

<hr>

<h2 id="type_is_scalar">RDB_type_is_scalar</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_bool
RDB_type_is_scalar(const RDB_type *);
</pre>

<h3>Description</h3>

<p>RDB_type_is_scalar checks if a type is scalar.

<h3>Return value</h3>

<p>RDB_TRUE if the type is scalar, RDB_FALSE otherwise.

<hr>

<h2 id="type_is_numeric">RDB_type_is_numeric</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_bool
RDB_type_is_numeric(const RDB_type *);
</pre>

<h3>Description</h3>

<p>RDB_type_is_numeric checks if a type is numeric.

<h3>Return value</h3>

<p>RDB_TRUE if the type is INTEGER or RATIONAL, RDB_FALSE otherwise.

<h3>Return value</h3>

<hr>

<h2 id="type_equals">RDB_type_equals</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_bool
RDB_type_equals(const RDB_type *, const RDB_type *);
</pre>

<h3>Description</h3>

<p>RDB_type_equals checks if two types are equal.

<p>Nonscalar types are equal if there definition is the same.

<h3>Return value</h3>

<p>RDB_TRUE if the types are equal, RDB_FALSE otherwise.

<hr>

<h2 id="create_ro_op">RDB_create_ro_op</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_create_ro_op(const char *name, int argc, RDB_type *argtv[], RDB_type *rtyp,
                 const char *libname, const char *sym,
                 const void *iargp, size_t iarglen,
                 RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_create_ro_op creates a read-only operator with name <var>name</var>.
The argument types are specified by <var>argc</var> and <var>argtv</var>.

<p>To execute the operator, Duro will execute the function specified by
<var>sym</var> from the library specified by <var>libname</var>.

<p>This function must have the following signature:

<pre>
int
&lt;sym&gt;(const char *name, int argc, RDB_object *argv[],
          const void *iargp, size_t iarglen, RDB_transaction *txp,
          RDB_object *retvalp)
</pre>

<p>When the function is executed, the name of the operator is passed through <var>name</var>
and the arguments are passed through <var>argc</var> and <var>argv</var>.

<p>The function specified by <var>sym</var> must store the result at the
location specified by <var>retvalp</var> and return RDB_OK.
It can indicate an error condition by returning an error code.

<p>If <var>iargp</var> is not NULL, it must point to a byte block
of length <var>iarglen</var> which will be passed to the function
specified by <var>sym</var>.
This can be used to pass code to an interpreter function.

<p>Overloading operators is possible.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_ELEMENT_EXISTS
<dd>A read-only operator with this name and signature does already exist.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="create_update_op">RDB_create_update_op</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_create_update_op(const char *name, int argc, RDB_type *argtv[],
                  RDB_bool upd[], const char *libname, const char *sym,
                  const void *iargp, size_t iarglen,
                  RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_create_update_op creates an update operator with name <var>name</var>.
The argument types are specified by <var>argc</var> and <var>argtv</var>.

<p>The argument <var>upd</var> specifies which of the arguments are updated.
If upd[<em>i</em>] is RDB_TRUE, this indicates that the <em>i</em>th argument
is updated by the operator.

<p>To execute the operator, Duro will execute the function specified by
<var>sym</var> from the library specified by <var>libname</var>.

<p>This function must have the following signature:

<pre>
int
&lt;sym&gt;(const char *name, int argc, RDB_object *argv[],
        RDB_bool updv[], const void *iargp, size_t iarglen, RDB_transaction *txp)

</pre>

<p>When the function is executed, the name of the operator is passed through <var>name</var>
and the arguments are passed through <var>argc</var> and <var>argv</var>.

<p>On success, the function specified by <var>sym</var> must return RDB_OK.
It can indicate an error condition by returning an error code.

<p>If <var>iargp</var> is not NULL, it must point to a byte block
of length <var>iarglen</var> which will be passed to the function
specified by <var>sym</var>.
This can be used to pass code to an interpreter function.

<p>Overloading operators is possible.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_ELEMENT_EXISTS
<dd>An update operator with this name and signature does already exist.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="call_ro_op">RDB_call_ro_op</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_call_ro_op(const char *name, int argc, RDB_object *argv[],
               RDB_transaction *txp, RDB_object *retvalp);
</pre>

<h3>Description</h3>

<p>RDB_call_ro_op invokes the read-only operator with the name <var>name</var>,
passing the arguments in <var>argc</var> and <var>argv</var>.

<p>The result will be stored at the location pointed to by
<var>retvalp</var>. 

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_OPERATOR_NOT_FOUND
<dd>A read-only operator that matches the name and argument types could not be
found.
<dt>RDB_TYPE_MISMATCH
<dd>A read-only operator that matches <var>name</var> could be found,
but it does not match the argument types.
</dl>

<p>If the user-supplied function which implements the function returns an
error code, this code is returned.

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="call_update_op">RDB_call_update_op</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_call_update_op(const char *name, int argc, RDB_object *argv[],
                RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_call_update_op invokes the update operator with the name <var>name</var>,
passing the arguments in <var>argc</var> and <var>argv</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_OPERATOR_NOT_FOUND
<dd>An update operator that matches the name and arguments could not be
found.
</dl>

<p>If the user-supplied function which implements the operator returns an
error code, this code is returned.

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="drop_op">RDB_drop_op</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_drop_op(const char *name, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_drop_op deletes the operator with the name <var>name</var>
from the database. This affects all overloaded versions.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_NOT_FOUND
<dd>An operator with the specified name could not be found.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="create_constraint">RDB_create_constraint</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_create_constraint(const char *name, RDB_expression *constrp,
                      RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_create_constraint creates a constraint with the name <var>name</var>
on the database the transaction specified by <var>txp</var> interacts with.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_TYPE_MISMATCH
<dd>The expression specified by <var>constrp</var> is not of type BOOLEAN.
<dt>RDB_PREDICATE_VIOLATION
<dd>The expression specified by <var>constrp</var> is not satisfied.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<h3>Notes</h3>

<p><strong>This function is not implemented.</strong>

<hr>

<h2 id="drop_constraint">RDB_drop_constraint</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_drop_constraint(const char *name, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_drop_constraint deletes the constraint with the name <var>name</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_NOT_FOUND
<dd>A constraint with the name <var>name</var> could not be found.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<h3>Notes</h3>

<p><strong>This function is not implemented.</strong>

<hr>

<h2 id="begin_uoi">RDB_begin_uoi</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_begin_uoi(RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_begin_uoi starts a unit of integrity (UOI), which means that
integrity checking is delayed until the of the UOI.
UOIs cannot be nested.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_INVALID_ARGUMENT
<dd>A unit of integrity has already been started.
</dl>

<h3>Notes</h3>

<p><strong>This function is not implemented.</strong>

<hr>

<h2 id="end_uoi">RDB_end_uoi</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_end_uoi(RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_end_uoi ends a unit of integrity.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_INVALID_ARGUMENT
<dd>A unit of integrity has not been started.
<dt>RDB_PREDICATE_VIOLATION
<dd>A violation of an integrity constraint has been detected.
</dl>

<h3>Notes</h3>

<p><strong>This function is not implemented.</strong>

<hr>

<h2 id="open_env">RDB_open_env</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_open_env(const char *path, RDB_environment **envp);
</pre>

<h3>Description</h3>

<p>RDB_open_env opens a database environment identified by the
system resource <var>path</var>. 

<p>In the current implementation, the path passed to RDB_open_env
is a Berkeley DB database environment directory.
To create a new empty environment, simply pass an empty directory
to RDB_open_env.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_RESOURCE_NOT_FOUND
<dd>The resource specified by <var>path</var> could not be found.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>
different from RDB_RESOURCE_NOT_FOUND.

<h3>Return value</h3>

<h3>Errors</h3>

<hr>

<h2 id="close_env">RDB_close_env</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_close_env(RDB_environment *envp);
</pre>

<h3>Description</h3>

<p>RDB_close_env closes the database environment specified by
<var>envp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<p>The call may fail for a <a href="#syserr">system error</a>

<hr>

<h2 id="set_errfile">RDB_set_errfile</h2>

<pre>
#include &lt;rel/rdb.h&gt;

void
RDB_set_errfile(RDB_environment *, FILE *errfile);
</pre>

<h3>Description</h3>

<p>RDB_set_errfile sets a C library FILE * to be used for error messages.

<hr>

<h2 id="set_errfn">RDB_set_errfn</h2>

<pre>
#include &lt;rel/rdb.h&gt;

void
RDB_set_errfn(RDB_environment *envp, void (*errfn)(const char *msg, void *arg), void *arg);
</pre>

<h3>Description</h3>

<p>RDB_set_errfile sets an error reporting function.

<hr>

<h2 id="create_table_index">RDB_create_table_index</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_create_table_index(const char *name, RDB_table *tbp, int idxcompc,
                       const RDB_seq_item idxcompv[], int flags, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_create_table_index creates and index with name <var>name</var>
for the table specified by <var>tbp</var> over the attributes
specified by <var>idxcompc</var> and <var>idxcompv</var>.
The <var>flags</var> argument must be either 0 or RDB_ORDERED.
If <var>flags</var> is 0, a hash index is created.
If <var>flags</var> is RDB_ORDERED, a B-tree index is created.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_ARGUMENT
<dd><var>name</var> is not a valid index name.
<dt>RDB_ELEMENT_EXISTS
<dd>An index with name <var>name</var> already exists.
<dt>RDB_ATTRIBUTE_NOT_FOUND
<dd>An attribute specified by <var>idxcompv</var> does not appear in the
table.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="drop_table_index">RDB_drop_table_index</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_drop_table_index(const char *name, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_drop_table_index drops the index specified by <var>name</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_NOT_FOUND
<dd>An index with name <var>name</var> does not exist.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="strerror">RDB_strerror</h2>

<pre>
#include &lt;rel/rdb.h&gt;

const char *
RDB_strerror(int err);
</pre>

<h3>Description</h3>

<p>Returns a string describing the Duro error code passed in the
argument <var>err</var>.

<h3>Return value</h3>

<p>Returns the appropriate description string, or a message
"unkown error" if the error code is unkown.

<hr>

<h2 id="is_syserr">RDB_is_syserr</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_is_syserr(int err);
</pre>

<h3>Description</h3>

<p>Checks whether <var>err</var> represents a system error.

<h3>Return value</h3>

<p>The value returned is nonzero if <var>err</var> represents a system error,
and zero if it does not.

<hr>

<h2 id="parse_expr">RDB_parse_expr<br>
RDB_parse_table</h2>

<pre>
#include &lt;dli/parse.h&gt;

typedef RDB_table *RDB_ltablefn(const char *, void *);

int
RDB_parse_expr(const char *exprtxt, RDB_ltablefn *ltfnp, void *arg, RDB_transaction *,
        RDB_expression **);

int
RDB_parse_table(const char *exprtxt, RDB_ltablefn *ltfnp, void *arg, RDB_transaction *,
        RDB_table **);
</pre>

<h3>Description</h3>

<p>These functions parse the <a href="expressions.html">expression</a>
specified by <var>exprtxt</var>. If <var>ltfnp</var> is not NULL,
it must point to a function which is used to look up local tables.
The function is invoked with the table name and <var>arg</var> as
arguments. It must return a pointer to the table or NULL if the table was
not found.

<p>RDB_parse_expr converts an expression into a RDB_expression.

<p>RDB_parse_table converts an expression into a virtual table.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Notes</h3>

<p>The parser is not reentrant.

<hr>

<h2 id="attr">RDB_attr</h2>

<pre>
typedef struct {
    char *name;
    RDB_type *typ;
    RDB_object *defaultp;
    int options;
} RDB_attr;
</pre>

<hr>

<h2 id="virtual_attr">RDB_virtual_attr</h2>

<pre>
typedef struct {
    char *name;
    RDB_expression *exp;
} RDB_virtual_attr;
</pre>

<hr>

<h2 id="renaming">RDB_renaming</h2>

<pre>
typedef struct {
    char *from;
    char *to;
} RDB_renaming;
</pre>

<hr>

<h2 id="wrapping">RDB_wrapping</h2>

<pre>
typedef struct {
    int attrc;
    char **attrv;
    char *attrname;
} RDB_wrapping;
</pre>

<hr>

<h2 id="possrep">RDB_possrep</h2>

<pre>
typedef struct {
    char *name;
    int compc;
    RDB_attr *compv;
    RDB_expression *constraintp;
} RDB_possrep;
</pre>

<hr>

<h2 id="aggregate_op">RDB_aggregate_op</h2>

<pre>
typedef enum {
    RDB_COUNT, RDB_SUM, RDB_AVG, RDB_MAX, RDB_MIN, RDB_ALL, RDB_ANY,
    RDB_COUNTD, RDB_SUMD, RDB_AVGD
} RDB_aggregate_op;
</pre>

<hr>

<h2 id="syserr">System errors</h2>

<dl>
<dt>RDB_NO_SPACE
<dd>Insufficient disk space.
<dt>RDB_NO_MEMORY
<dd>Insufficient memory.
<dt>RDB_DEADLOCK
<dd>A deadlock condition was detected.
<dt>RDB_INTERNAL
<dd>Internal error.
<dt>RDB_RESOURCE_NOT_FOUND
<dd>A system resource, usually a file, could not be found.
<dt>RDB_SYSTEM_ERROR
<dd>Unspecified system error.
</dl>

<hr>

<p>$Id$

</html>
