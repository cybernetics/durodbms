<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
"http://www.w3.org/TR/html4/strict.dtd">
<html lang="en">
<head>
<title>Duro API specification</title>
<body>
<h1>Duro API specification</h1>

<p>- DRAFT -

<p>Not all the functions described in this document are already implemented.
See the release notes for details.

<h2>Contents</h2>

<h3>Built-in types</h3>

<p><a href="#built-in-types">Table of built-in types</a>

<h3>Table functions</h3>

<ul>
<li><a href="#add_table">RDB_add_table</a>
<li><a href="#all">RDB_all</a>
<li><a href="#any">RDB_any</a>
<li><a href="#avg">RDB_avg</a>
<li><a href="#cardinality">RDB_cardinality</a>
<li><a href="#copy_table">RDB_copy_table</a>
<li><a href="#create_table">RDB_create_table</a>
<li><a href="#delete">RDB_delete</a>
<li><a href="#drop_table">RDB_drop_table</a>
<li><a href="#extend">RDB_extend</a>
<li><a href="#extract_tuple">RDB_extract_tuple</a>
<li><a href="#gdivide">RDB_gdivide</a>
<li><a href="#get_table">RDB_get_table</a>
<li><a href="#group">RDB_group</a>
<li><a href="#insert">RDB_insert</a>
<li><a href="#intersect">RDB_intersect</a>
<li><a href="#join">RDB_join</a>
<li><a href="#max">RDB_max</a>
<li><a href="#min">RDB_min</a>
<li><a href="#minus">RDB_minus</a>
<li><a href="#project">RDB_project</a>
<li><a href="#remove">RDB_remove</a>
<li><a href="#rename">RDB_rename</a>
<li><a href="#remove_table">RDB_remove_table</a>
<li><a href="#sdivide">RDB_sdivide</a>
<li><a href="#select">RDB_select</a>
<li><a href="#set_table_name">RDB_set_table_name</a>
<li><a href="#subset">RDB_subset</a>
<li><a href="#sum">RDB_sum</a>
<li><a href="#summarize">RDB_summarize</a>
<li><a href="#table_contains">RDB_table_contains</a>
<li><a href="#table_is_empty">RDB_table_is_empty</a>
<li><a href="#table_name">RDB_table_name</a>
<li><a href="#table_type">RDB_table_type</a>
<li><a href="#ungroup">RDB_ungroup</a>
<li><a href="#union">RDB_union</a>
<li><a href="#unwrap">RDB_unwrap</a>
<li><a href="#update">RDB_update</a>
<li><a href="#wrap">RDB_wrap</a>
</ul>

<h3>Tuple functions</h3>

<ul>
<li><a href="#extend_tuple">RDB_extend_tuple</a>
<li><a href="#join_tuples">RDB_join_tuples</a>
<li><a href="#project_tuple">RDB_project_tuple</a>
<li><a href="#rename_tuple">RDB_rename_tuple</a>
<li><a href="#tuple_attr_names">RDB_tuple_attr_names</a>
<li><a href="#tuple_get">RDB_tuple_get</a>
<li><a href="#tuple_get_bool">RDB_tuple_get_bool</a>
<li><a href="#tuple_get_int">RDB_tuple_get_int</a>
<li><a href="#tuple_get_rational">RDB_tuple_get_rational</a>
<li><a href="#tuple_get_string">RDB_tuple_get_string</a>
<li><a href="#tuple_set">RDB_tuple_set</a>
<li><a href="#tuple_set_bool">RDB_tuple_set_bool</a>
<li><a href="#tuple_set_int">RDB_tuple_set_int</a>
<li><a href="#tuple_set_rational">RDB_tuple_set_rational</a>
<li><a href="#tuple_set_string">RDB_tuple_set_string</a>
<li><a href="#tuple_size">RDB_tuple_size</a>
<li><a href="#unwrap_tuple">RDB_unwrap_tuple</a>
<li><a href="#wrap_tuple">RDB_wrap_tuple</a>
</ul>

<h3>Scalar and generic functions</h3>

<ul>
<li><a href="#binary_get">RDB_binary_get</a>
<li><a href="#binary_set">RDB_binary_set</a>
<li><a href="#binary_length">RDB_binary_length</a>
<li><a href="#copy_obj">RDB_copy_obj</a>
<li><a href="#destroy_obj">RDB_destroy_obj</a>
<li><a href="#init_obj">RDB_init_obj</a>
<li><a href="#obj_bool">RDB_obj_bool</a>
<li><a href="#obj_comp">RDB_obj_comp</a>
<li><a href="#obj_equals">RDB_obj_equals</a>
<li><a href="#obj_int">RDB_obj_int</a>
<li><a href="#obj_rational">RDB_obj_rational</a>
<li><a href="#bool_to_obj">RDB_bool_to_obj</a>
<li><a href="#int_to_obj">RDB_int_to_obj</a>
<li><a href="#rational_to_obj">RDB_rational_to_obj</a>
<li><a href="#string_to_obj">RDB_string_to_obj</a>
<li><a href="#obj_set_comp">RDB_obj_set_comp</a>
<li><a href="#obj_string">RDB_obj_string</a>
<li><a href="#obj_table">RDB_obj_table</a>
<li><a href="#table_to_obj">RDB_table_to_obj</a>

</ul>

<h3>Database functions</h3>

<ul>
<li><a href="#create_db_from_env">RDB_create_db_from_env</a>
<li><a href="#db_env">RDB_db_env</a>
<li><a href="#db_name">RDB_db_name</a>
<li><a href="#drop_db">RDB_drop_db</a>
<li><a href="#get_db_from_env">RDB_get_db_from_env</a>
</ul>

<h3>Transaction functions</h3>

<ul>
<li><a href="#begin_tx">RDB_begin_tx</a>
<li><a href="#commit">RDB_commit</a>
<li><a href="#rollback">RDB_rollback</a>
<li><a href="#tx_is_db">RDB_tx_db</a>
<li><a href="#tx_is_running">RDB_tx_is_running</a>
</ul>

<h3>Array functions</h3>

<ul>
<li><a href="#array_get">RDB_array_get</a>
<li><a href="#array_length">RDB_array_length</a>
<li><a href="#array_set">RDB_array_set</a>
<li><a href="#table_to_array">RDB_table_to_array</a>
<li><a href="#set_array_length">RDB_set_array_length</a>
</ul>

<h3>Expression functions</h3>

<ul>
<li><a href="#expr_is_const">RDB_expr_is_const</a>
<li><a href="#bool_to_expr">RDB_bool_to_expr</a>
<li><a href="#int_to_expr">RDB_int_to_expr</a>
<li><a href="#rational_to_expr">RDB_rational_to_expr</a>
<li><a href="#string_to_expr">RDB_string_to_expr</a>
<li><a href="#obj_to_expr">RDB_obj_to_expr</a>
<li><a href="#expr_attr">RDB_expr_attr</a>
<li><a href="#eq">RDB_eq</a>
<li><a href="#neq">RDB_neq</a>
<li><a href="#lt">RDB_lt</a>
<li><a href="#gt">RDB_gt</a>
<li><a href="#let">RDB_let</a>
<li><a href="#get">RDB_get</a>
<li><a href="#and">RDB_and</a>
<li><a href="#or">RDB_or</a>
<li><a href="#not">RDB_not</a>
<li><a href="#add">RDB_add</a>
<li><a href="#subtract">RDB_subtract</a>
<li><a href="#negate">RDB_negate</a>
<li><a href="#multiply">RDB_multiply</a>
<li><a href="#divide">RDB_divide</a>
<li><a href="#concat">RDB_concat</a>
<li><a href="#strlen">RDB_strlen</a>
<li><a href="#regmatch">RDB_regmatch</a>
<li><a href="#expr_any">RDB_expr_any</a>
<li><a href="#expr_all">RDB_expr_all</a>
<li><a href="#expr_avg">RDB_expr_avg</a>
<li><a href="#expr_cardinality">RDB_expr_cardinality</a>
<li><a href="#expr_contains">RDB_expr_contains</a>
<li><a href="#expr_comp">RDB_expr_comp</a>
<li><a href="#expr_is_empty">RDB_expr_is_empty</a>
<li><a href="#expr_max">RDB_expr_max</a>
<li><a href="#expr_min">RDB_expr_min</a>
<li><a href="#expr_sum">RDB_expr_sum</a>
<li><a href="#expr_subset">RDB_expr_subset</a>
<li><a href="#table_to_expr">RDB_table_to_expr</a>
<li><a href="#user_op">RDB_user_op</a>
<li><a href="#drop_expr">RDB_drop_expr</a>
</ul>

<h3>Type functions</h3>

<ul>
<li><a href="#define_type">RDB_define_type</a>
<li><a href="#implement_type">RDB_implement_type</a>
<li><a href="#create_tuple_type">RDB_create_tuple_type</a>
<li><a href="#create_relation_type">RDB_create_relation_type</a>
<li><a href="#get_type">RDB_get_type</a>
<li><a href="#drop_type">RDB_drop_type</a>
<li><a href="#type_name">RDB_type_name</a>
<li><a href="#type_is_scalar">RDB_type_is_scalar</a>
<li><a href="#type_is_numeric">RDB_type_is_numeric</a>
<li><a href="#type_equals">RDB_type_equals</a>
</ul>

<h3>Operator functions</h3>

<ul>
<li><a href="#create_ro_op">RDB_create_ro_op</a>
<li><a href="#create_update_op">RDB_create_update_op</a>
<li><a href="#call_ro_op">RDB_call_ro_op</a>
<li><a href="#call_update_op">RDB_call_update_op</a>
<li><a href="#drop_op">RDB_drop_op</a>
</ul>

<h3>Constraint functions</h3>

<ul>
<li><a href="#create_constraint">RDB_create_constraint</a>
<li><a href="#drop_constraint">RDB_drop_constraint</a>
<li><a href="#begin_uoi">RDB_begin_uoi</a>
<li><a href="#end_uoi">RDB_end_uoi</a>
</ul>

<h3>Database Environment functions</h3>

<ul>
<li><a href="#create_env">RDB_create_env</a>
<li><a href="#open_env">RDB_open_env</a>
<li><a href="#close_env">RDB_close_env</a>
<li><a href="#set_errfile">RDB_set_errfile</a>
</ul>

<h3>Error handling functions</h3>

<ul>
<li><a href="#strerror">RDB_strerror</a>
<li><a href="#is_syserr">RDB_is_syserr</a>
</ul>

<h3>Expression parsing functions</h3>

<ul>
<li><a href="#parse_expr">RDB_parse_expr</a>
<li><a href="#parse_expr">RDB_parse_table</a>
</ul>

<h3>C structures and definitions</h3>

<ul>
<li><a href="#attr">RDB_attr</a>
<li><a href="#virtual_attr">RDB_virtual_attr</a>
<li><a href="#renaming">RDB_renaming</a>
<li><a href="#wrapping">RDB_wrapping</a>
<li><a href="#possrep">RDB_possrep</a>
<li><a href="#aggregate_op">RDB_aggregate_op</a>
<li><a href="#syserr">System errors</a>
</ul>

<h2 id="built-in-types">Built-in types</h2>

<table border="1" summary="Built-in types">
<tr><th>Name<th>RDB_type variable<th>C type
<tr><td>BOOLEAN<td>RDB_BOOLEAN<td>RDB_bool
<tr><td>INTEGER<td>RDB_INTEGER<td>RDB_int
<tr><td>RATIONAL<td>RDB_RATIONAL<td>RDB_rational
<tr><td>STRING<td>RDB_STRING<td>char *
<tr><td>BINARY<td>RDB_BINARY<td>&nbsp;-
</table>

<hr>

<h2 id="create_table">RDB_create_table</h2>

<pre>
#include &lt;rel/rdb.h&gt;

typedef struct {
    int strc;
    char **strv;
} RDB_string_vec;

int
RDB_create_table(const char *name, RDB_bool global,
                 int attrc, <a href="#attr">RDB_attr</a> attrv[],
                 int keyc, RDB_string_vec keyv[],
                 RDB_transaction *txp, RDB_table **tbpp);
</pre>

<h3>Description</h3>

<p>RDB_create_table creates a table with name <var>name</var> under the control of
the transaction pointed to by <var>txp</var>.
A pointer to the newly created RDB_table structure
will be stored at the location pointed to by <var>tbpp</var>.

<p>If <var>global</var> is RDB_FALSE, a local (transient) table will be created.
In this case, <var>name</var> may be NULL.

<p>If <var>global</var> is RDB_TRUE, a global (persistent) table in the database
the transaction pointed to by <var>txp</var> interacts with will be created.

<p>The table will have <var>attrc</var> attributes. The individual
attributes are specified by the elements of <var>attrv</var>.

<p>The fields of the RDB_attr structure are interpreted as follows:

<dl>
<dt>name
<dd>Specifies the name of the attribute.
<dt>typ
<dd>Specifies the type of the attribute.
<dt>defaultp
<dd>If not NULL, this field must point to a RDB_object variable that specifies
the default value for the attribute.
<dt>options
<dd>May be either zero, or RDB_SYSTEM_GENERATED. In the latter case
the attribute must be a candidate key, and the system then will automatically
generate a value for that attribute on insertion.
</dl>

<p>The table will have <var>keyc</var> candidate keys. The <var>keyv</var>
argument specifies the names of the candidate keys.
The strc field of the RDB_string_vec structure specifies
the number of fields in a key, while the elements of the strv field specify
the names of the key attributes.

<p>At least one candidate key must be specified.
A candidate key may not be a subset of another.
If a single candidate key is specified, that key
may be empty (not contain any attribute).

<p>Passing a <var>keyv</var> of NULL is equivalent to passing
all attributes in <var>keyv</var> and the number of table attributes
in <var>keyc</var>, that is, the table will become all-key.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_TYPE_MISMATCH
<dd>The type of a default value does not match the type of the corresponding
attribute.
<dt>RDB_INVALID_ARGUMENT
<dd>One or more of the arguments are incorrect. For example, a key attribute
does not appear in <var>attrv</var>, etc.
<dt>RDB_NOT_SUPPORTED
<dd>The combination of arguments is not supported by the version
of Duro used. Consult the release notes of that version for details.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<h2 id="get_table">RDB_get_table</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_get_table(const char *name, RDB_transaction *txp, RDB_table **tbpp);
</pre>

<h3>Description</h3>

<p>RDB_get_table looks up the global table with name <var>name</var>
in the environment of the database the transaction
specified by <var>txp</var> interacts with and stores a pointer to a
RDB_table structure in <var>tbpp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_NOT_FOUND
<dd>A table with the name <var>name</var> could not be found.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="drop_table">RDB_drop_table</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_drop_table(RDB_table *tbp, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_drop_table deletes the table specified by <var>tbp</var>
and frees all resources associated with that table.
If the table is virtual, its unnamed child tables are also deleted.

<p>If the table is local, <var>txp</var> may be NULL.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd>The table is global (persistent) and <var>txp</var>
does not point to a running transaction.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="table_name">RDB_table_name</h2>

<pre>
#include &lt;rel/rdb.h&gt;

char *
RDB_table_name(RDB_table *tbp)
</pre>

<h3>Description</h3>

<p>RDB_table_name returns a pointer to the name of a table.

<h3>Return value</h3>

<p>A pointer to the name of the table, or NULL if the table has no name.

<hr>

<h2 id="table_type">RDB_table_type</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_type *
RDB_table_type(const RDB_table *tbp)
</pre>

<h3>Description</h3>

<p>RDB_table_type returns a pointer to the type of the table
specified by <var>tbp</var>.

<h3>Return value</h3>

<p>A pointer to the type of the table.

<hr>

<h2 id="set_table_name">RDB_set_table_name</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_set_table_name(RDB_table *tbp, const char *name, RDB_transaction *);
</pre>

<h3>Description</h3>

<p>RDB_set_table_name sets the name of the table to <var>name</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_INVALID_ARGUMENT
<dd><var>name</var> is not a valid table name.
<dt>RDB_NOT_SUPPORTED
<dd>The combination of arguments is not supported by the version
of Duro used. Consult the release notes of that version for details.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="add_table">RDB_add_table</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_add_table(RDB_table *tbp, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_add_table adds the table specified by <var>tbp</var> to the
database the transaction specified by <var>txp</var> interacts with.

<p>If the table is a local (transient) table, it is made global
(persistent).

<p>The table must have a name.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_INVALID_ARGUMENT
<dd>The table does not have a name.
<dt>RDB_ELEMENT_EXISTS
<dd>The table is already associated with the database.
<dt>RDB_NOT_SUPPORTED
<dd>The combination of arguments is not supported by the version
of Duro used. Consult the release notes of that version for details.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="remove_table">RDB_remove_table</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_remove_table(RDB_table *tbp, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_remove_table removes the table specified by <var>tbp</var> from the
database the transaction specified by <var>txp</var> interacts with.

<p>If the table is a global table, it is made local.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_INVALID_ARGUMENT
<dd>The table does not belong the database which the transaction interacts
with.
<dt>RDB_NOT_SUPPORTED
<dd>The combination of arguments is not supported by the version
of Duro used. Consult the release notes of that version for details.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="table_contains">RDB_table_contains</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_table_contains(RDB_table *tbp, const RDB_object *tplp, RDB_transaction *);
</pre>

<h3>Description</h3>

<p>RDB_table_contains checks if the tuple specified by <var>tplp</var>
is an element of the table specified by <var>tbp</var>.

<h3>Return value</h3>

<p>If the tuple is an element of the table, RDB_OK is returned.
If the tuple is not an element of the table, RDB_NOT_FOUND is returned.
On failure, an error code different from RDB_NOT_FOUND returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_INVALID_ARGUMENT
<dd>A table attribute is missing in the tuple.
<dt>RDB_TYPE_MISMATCH
<dd>The type of a tuple attribute does not match the type of the
corresponding table attribute.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="all">RDB_all</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_all(RDB_table *tbp, const char *attrname, RDB_transaction *txp,
        RDB_bool *resultp);
</pre>

<h3>Description</h3>

<p>RDB_all computes a logical AND over the attribute
<var>attrname</var> of the table specified by <var>tbp</var>
and stores the result at the location pointed to by <var>resultp</var>.

<p>The attribute <var>attrname</var> must be of type BOOLEAN.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_INVALID_ARGUMENT
<dd>The table does not have an attribute <var>attrname</var>.
<dt>RDB_TYPE_MISMATCH
<dd>The type of the attribute is not BOOLEAN.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="any">RDB_any</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_any(RDB_table *tbp, const char *attrname, RDB_transaction *txp,
        RDB_bool *resultp);
</pre>

<h3>Description</h3>

<p>RDB_any computes a logical OR over the attribute
<var>attrname</var> of the table specified by <var>tbp</var>
and stores the result at the location
pointed to by <var>resultp</var>.

<p>The attribute <var>attrname</var> must be of
type BOOLEAN.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_INVALID_ARGUMENT
<dd>The table does not have an attribute <var>attrname</var>.
<dt>RDB_TYPE_MISMATCH
<dd>The type of the attribute is not BOOLEAN.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="avg">RDB_avg</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_avg(RDB_table *tbp, const char *attrname, RDB_transaction *txp,
        RDB_rational *resultp);
</pre>

<h3>Description</h3>

<p>RDB_avg computes the average over the attribute
<var>attrname</var> of the table specified by <var>tbp</var>
and stores the result at the location
pointed to by <var>resultp</var>.

<p>The attribute <var>attrname</var> must be numeric.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_INVALID_ARGUMENT
<dd>The table does not have an attribute <var>attrname</var>.
<dt>RDB_TYPE_MISMATCH
<dd>The type of the attribute is not numeric.
<dt>RDB_AGGREGATE_UNDEFINED
<dd>The table is empty.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="cardinality">RDB_cardinality</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_cardinality(RDB_table *tbp, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_cardinality returns the number of tuples in
the table pointed to by <var>tbp</var>.

<h3>Return value</h3>

<p>On success, the number of tuples is returned.
On failure, an error code lower than zero is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="max">RDB_max</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_max(RDB_table *tbp, const char *attrname, RDB_transaction *txp,
        RDB_object *resultp);
</pre>

<h3>Description</h3>

<p>RDB_max computes the maximum over the attribute
<var>attrname</var> of the table specified by <var>tbp</var>
and stores the result at the location pointed to by <var>resultp</var>.

<p>The attribute <var>attrname</var> must be numeric
and the result is of the same type as the attribute.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_INVALID_ARGUMENT
<dd>The table does not have an attribute <var>attrname</var>.
<dt>RDB_TYPE_MISMATCH
<dd>The type of the attribute is not numeric.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="min">RDB_min</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_min(RDB_table *tbp, const char *attrname, RDB_transaction *txp,
        RDB_object *resultp);
</pre>

<h3>Description</h3>

<p>RDB_min computes the minimum over the attribute
<var>attrname</var> of the table specified by <var>tbp</var>
and stores the result at the location pointed to by <var>resultp</var>.

<p>The attribute <var>attrname</var> must be numeric
and the result is of the same type as the attribute.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_INVALID_ARGUMENT
<dd>The table does not have an attribute <var>attrname</var>.
<dt>RDB_TYPE_MISMATCH
<dd>The type of the attribute is not numeric.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="sum">RDB_sum</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_sum(RDB_table *tbp, const char *attrname, RDB_transaction *txp,
        RDB_object *resultp);
</pre>

<h3>Description</h3>

<p>RDB_sum computes the sum over the attribute
<var>attrname</var> of the table pointed to by <var>tbp</var>
and stores the result at the location pointed to by <var>resultp</var>.

<p>The attribute <var>attrname</var> must be numeric
and the result is of the same type as the attribute.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_INVALID_ARGUMENT
<dd>The table does not have an attribute <var>attrname</var>.
<dt>RDB_TYPE_MISMATCH
<dd>The type of the attribute is not numeric.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="table_is_empty">RDB_table_is_empty</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_table_is_empty(RDB_table *tbp, RDB_transaction *txp, RDB_bool *resultp);
</pre>

<h3>Description</h3>

<p>RDB_table_is_empty checks if the table specified by <var>tbp</var>
is empty and stores the result of
the check at the location pointed to by <var>resultp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="insert">RDB_insert</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_insert(RDB_table *tbp, const RDB_object *tplp, RDB_transaction *);
</pre>

<h3>Description</h3>

<p>RDB_insert inserts the tuple specified by <var>tplp</var>
into the table specified by <var>tbp</var>.
 
<h3>Return value</h3>

<p>If the insert was successful and the tuple was not already
an element of the table, RDB_OK is returned.
If the tuple was already an element of the table,
RDB_ELEMENT_EXISTS is returned.
On failure, an error code different from RDB_ELEMENT_EXISTS is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_INVALID_ARGUMENT
<dd>A table attribute is missing in the tuple and no default value
was specified for that attribute.
<dt>RDB_KEY_VIOLATION
<dd>Inserting the tuple would result in a table which contains
a key value twice.
<dt>RDB_PREDICATE_VIOLATION
<dd>Inserting the tuple would result in a table which violates its
predicate.
<dt>RDB_TYPE_MISMATCH
<dd>The type of a tuple attribute does not match the type of the
corresponding table attribute.
<dt>RDB_NOT_SUPPORTED
<dd>The combination of arguments is not supported by the version
of Duro used. Consult the release notes of that version for details.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="update">RDB_update</h2>

<pre>
#include &lt;rel/rdb.h&gt;

typedef struct {
    char *name;
    RDB_expression *exp;
} RDB_attr_update;

int
RDB_update(RDB_table *tbp, RDB_expression *exp, int updc,
        const RDB_attr_update updv[], RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_update updates all tuples from the table specified by <var>tbp</var>
for which the expression specified by <var>exp</var> evaluates to true.
If <var>exp</var> is NULL, all tuples are updated.

<p>The attributes to be updated are specified by the <var>updv</var> array.
The attribute specified by the field name is set to the value
obtained by evaluating the expression specified by the field exp.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.

<dt>RDB_INVALID_ARGUMENT
<dd>One of the attributes in <var>updv</var> does not exist in the table.
<dd>One of the expressions specified in <var>updv</var> refers to an attribute
which does not exist in the table.

<dt>RDB_KEY_VIOLATION
<dd>The update operation would result in a table which contains
a key value twice.

<dt>RDB_PREDICATE_VIOLATION
<dd>The update operation would result in a table which violates its
predicate.

<dt>RDB_TYPE_MISMATCH
<dd>The type of one of the expressions in <var>updv</var> is not the same
as the type of the corresponding table attribute.

<dt>RDB_NOT_SUPPORTED
<dd>RDB_update is not supported for this type of table in this version of
Duro.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="delete">RDB_delete</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_delete(RDB_table *tbp, RDB_expression *exp, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_delete deletes all tuples from the table specified by <var>tbp</var>
for which the expression specified by <var>exp</var> evaluates to true.
If <var>exp</var> is NULL, all tuples are deleted.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_INVALID_ARGUMENT
<dd><var>exp</var> refers to an attribute which does not exist in the table.
<dt>RDB_NOT_SUPPORTED
<dd>RDB_delete is not supported for this type of table in this version of
Duro.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="extract_tuple">RDB_extract_tuple</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_extract_tuple(RDB_table *, RDB_object *tplp, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_extract_tuple extracts a single tuple from a table which contains
only one tuple and stores its value in the variable pointed to by <var>tplp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned
and the value of <var>tplp</var> is undefined.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_NOT_FOUND
<dd>The table is empty.
<dt>RDB_INVALID_ARGUMENT
<dd>The table contains more than one tuple.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="copy_table">RDB_copy_table</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_copy_table(RDB_table *dstp, RDB_table *srcp, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_copy_table copies all tuples from the table specified
by <var>srcp</var> to the table specified by <var>dstp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_TYPE_MISMATCH
<dd>The types of the two tables differ.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="rename">RDB_rename</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_rename(RDB_table *tbp, int renc, <a href="#renaming">RDB_renaming</a> renv[],
           RDB_table **resultpp);
</pre>

<h3>Description</h3>

<p>RDB_rename creates a virtual table which is the result of a relational
RENAME operator on the table specified by <var>tbp</var>.
A pointer to the result table is stored at the location pointed to by
<var>resultpp</var>.

<p>The attributes to be renamed are specified by the arguments
<var>renc</var> and <var>renv</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<p>The call may fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="select">RDB_select</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_select(RDB_table *tbp, RDB_expression *exp, RDB_table **resultpp);
</pre>

<h3>Description</h3>

<p>RDB_select creates a local (transient) virtual table which contains those
tuples from the table specified by <var>tbp</var> for which the
condition specified by <var>exp</var> evaluates to true.
A pointer to the result table is stored at the location pointed to by
<var>resultpp</var>

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_TYPE_MISMATCH
<dd>The condition is not of type BOOLEAN.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="extend">RDB_extend</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_extend(RDB_table *, int attrc, <a href="#virtual_attr">RDB_virtual_attr</a> attrv[],
        RDB_table **resultpp);
</pre>

<h3>Description</h3>

<p>RDB_rename creates a local (transient) virtual table which is the result of a relational
EXTEND operator on the table specified by <var>tbp</var>.

<p>The new table will have <var>attrc</var> additional attributes.
The values of these attributes are obtained by evaluating the
exp fields of the elements of <var>attrv</var>.

<p>If the operation is successful, the new table takes responsibility
for the expressions in <var>attrv</var>. These expressions are
automatically dropped when the table is dropped.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_ARGUMENT
<dd>An invalid attribute name has been specified.
</dl>

<hr>

<h2 id="project">RDB_project</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_project(RDB_table *, int attrc, char *attrv[], RDB_table **resultpp);
</pre>

<h3>Description</h3>

<p>RDB_project creates a relational projection over the table specified
by <var>tbp</var>.

<p>The attributes of the new table are specified by <var>attrc</var>
and <var>attrv</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_ARGUMENT
<dd>One of the attributes specified by <var>attrv</var> is not an attribute
of the original table.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="remove">RDB_remove</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_remove(RDB_table *, int attrc, char *attrv[], RDB_table **resultpp);
</pre>

<h3>Description</h3>

<p>RDB_remove creates a relational projection over the table specified
by <var>tbp</var>.

<p>The new table has the attributes of the original table except those
specified by <var>attrc</var> and <var>attrv</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_ARGUMENT
<dd>One of the attributes specified by <var>attrv</var> is not an attribute
of the original table.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="join">RDB_join</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_join(RDB_table *tb1p, RDB_table *tb2p, RDB_table **resultpp);
</pre>

<h3>Description</h3>

<p>RDB_join creates a local (transient) virtual table which is a natural join
of the two tables specified by <var>tb1p</var> and <var>tb2p</var>.

<p>If the two tables have no common attribute, the result becomes
a cartesian product.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_TYPE_MISMATCH
<dd>The two tables have an attribute with the same name, but with
different types.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="union">RDB_union</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_union(RDB_table *, RDB_table *, RDB_table **resultpp);
</pre>

<h3>Description</h3>

<p>RDB_union creates a local (transient) virtual table which is the
result of a relational UNION of the two tables, that is,
it contains the tuples from both tables. A pointer to the
new RDB_table is stored in <var>resultpp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_TYPE_MISMATCH
<dd>The types of the two tables differ.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="intersect">RDB_intersect</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_intersect(RDB_table *, RDB_table *, RDB_table **resultpp);
</pre>

<h3>Description</h3>

<p>RDB_intersect creates a local (transient) virtual table which is the
result of a relational INTERSECT of the two tables, that is,
it contains the tuples which both tables contain.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_TYPE_MISMATCH
<dd>The types of the two tables differ.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="minus">RDB_minus</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_minus(RDB_table *, RDB_table *, RDB_table **resultpp);
</pre>

<h3>Description</h3>

<p>RDB_intersect creates a local (transient) virtual table which is the
result of a relational MINUS of the two tables, that is,
it contains the tuples which the first table contains,
except those which the second table contains.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_TYPE_MISMATCH
<dd>The types of the two tables differ.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="sdivide">RDB_sdivide</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_sdivide(RDB_table *, RDB_table *, RDB_table *, RDB_table **resultpp);
</pre>

<h3>Description</h3>

<p>RDB_creates a local (transient) virtual table which is the
result of a small divide of the three tables.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<hr>

<h2 id="gdivide">RDB_gdivide</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_gdivide(RDB_table *, RDB_table *, RDB_table *, RDB_table *,
           RDB_table **resultpp);
</pre>

<h3>Description</h3>

<p>RDB_creates a local (transient) virtual table which is the
result of a great divide of the four tables.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<hr>

<h2 id="summarize">RDB_summarize</h2>

<pre>
#include &lt;rel/rdb.h&gt;

typedef struct {
    <a href="#aggregate_op">RDB_aggregate_op</a> op;
    RDB_expression *exp;
    char *name;
} RDB_summarize_add;

int
RDB_summarize(RDB_table *tb1p, RDB_table *tb2p, int addc, RDB_summarize_add addv[],
              RDB_table **resultpp);
</pre>

<h3>Description</h3>

<p>RDB_summarize creates a local (transient) virtual table which is the result
of a SUMMARIZE T1 PER T2 (ADD1, ...), where T1 is the table specified by
<var>tb1p</var>, T2 is the table specified by <var>tb2p</var>, and ADD1 ...
is specified by <var>addc</var> and <var>addv</var>.
A pointer to the result table is stored in resultpp.

<p>The two argument tables must not share an unnamed child table.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_NOT_SUPPORTED
<dd>The combination of arguments is not supported by the version
of Duro used. Consult the release notes of that version for details.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="wrap">RDB_wrap</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_wrap(RDB_table *tbp, int wrapc, <a href="#wrapping">RDB_wrapping</a> wrapv[],
         RDB_table **resultpp);
</pre>

<h3>Description</h3>

<p>RDB_wrap creates a local (transient) virtual table which is the result of a
relational WRAP operator.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<hr>

<h2 id="unwrap">RDB_unwrap</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_unwrap(RDB_table *, int attrc, char *attrv[], RDB_table **);
</pre>

<h3>Description</h3>

<p>RDB_wrap creates a local (transient) virtual table which is the result of a
relational UNWRAP operator.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<hr>

<h2 id="group">RDB_group</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_group(RDB_table *, int attrc, char *attrv[], const char *,
         RDB_table **resultpp);
</pre>

<h3>Description</h3>

<p>RDB_group creates a local (transient) virtual table which is the result of a
relational GROUP operator.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<hr>

<h2 id="ungroup">RDB_ungroup</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_ungroup(RDB_table *, const char *, RDB_table **resultpp);
</pre>

<h3>Description</h3>

<p>RDB_wrap creates a local (transient) virtual table which is the result of a
relational UNGROUP operator.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<hr>

<h2 id="join_tuples">RDB_join_tuples</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_join_tuples(const RDB_object *tpl1p, const RDB_object *tpl2p,
                RDB_object *restplp);
</pre>

<h3>Description</h3>

<p>RDB_join creates a tuple which contains the attributes
of the two tuples specified by <var>tpl1p</var> and <var>tpl2p</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_TYPE_MISMATCH
<dd>The two tuples have an attribute with the same name, but with
different types.
<dt>RDB_INVALID_ARGUMENT
<dd>The two tuples have an attribute with the same name, but with
different values.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="project_tuple">RDB_project_tuple</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_project_tuple(const RDB_object *, int attrc, char *attrv[],
                  RDB_object *restplp);
</pre>

<h3>Description</h3>

<p>RDB_project_tuple creates a tuple which contains only the attributes
specified by <var>attrc</var> and <var>attrv</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_ARGUMENT
<dd>One of the attributes specified by <var>attrv</var> is not an attribute
of the original tuple.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="tuple_set">RDB_tuple_set</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_tuple_set(RDB_object *tplp, const char *name, const RDB_object *valp);
</pre>

<h3>Description</h3>

<p>RDB_tuple_set sets the attribute <var>name</var> of the tuple
variable specified by <var>tplp</var> to the value specified by
<var>valp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<p>The call may fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="tuple_set_bool">RDB_tuple_set_bool</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_tuple_set_bool(RDB_object *tplp, const char *name, RDB_bool val);
</pre>

<h3>Description</h3>

<p>RDB_tuple_set_bool sets the attribute <var>name</var> of the tuple
variable specified by <var>tplp</var> to the boolean value specified by
<var>val</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<p>The call may fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="tuple_set_int">RDB_tuple_set_int</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_tuple_set_int(RDB_object *tplp, const char *name, RDB_int val);
</pre>

<h3>Description</h3>

<p>RDB_tuple_set_int sets the attribute <var>name</var> of the tuple
variable specified by <var>tplp</var> to the integer value specified by
<var>val</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<p>The call may fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="tuple_set_rational">RDB_tuple_set_rational</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_tuple_set_rational(RDB_object *tplp, const char *name, RDB_rational val);
</pre>

<h3>Description</h3>

<p>RDB_tuple_set_int sets the attribute <var>name</var> of the tuple
variable specified by <var>tplp</var> to the rational value specified by
<var>val</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<p>The call may fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="tuple_set_string">RDB_tuple_set_string</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_tuple_set_string(RDB_object *tplp, const char *name, const char *str);
</pre>

<h3>Description</h3>

<p>RDB_tuple_set_int sets the attribute <var>name</var> of the tuple
variable specified by <var>tplp</var> to the string value specified by
<var>str</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<p>The call may fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="tuple_size">RDB_tuple_size</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_int
RDB_tuple_size(const RDB_object *tplp);
</pre>

<h3>Description</h3>

<p>RDB_tuple_size determines the number of attributes of the tuple
specified by <var>tplp</var>.

<h3>Return value</h3>

<p>The number of attributes.

<hr>

<h2 id="tuple_attr_names">RDB_tuple_attr_names</h2>

<pre>
#include &lt;rel/rdb.h&gt;

void
RDB_tuple_attr_names(const RDB_object *, char **namev);
</pre>

<h3>Description</h3>

<p>RDB_tuple_attr_names fills <var>namev</var> with pointers to
the attribute names of the tuple specified by <var>tplp</var>.

<p><var>namev</var> must be large enough for all attribute names.
The pointers must not be modified by the caller and will become invalid
when the tuple is destroyed.

<h3>Return value</h3>

<p>None.

<h2 id="tuple_get">RDB_tuple_get</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_object *
RDB_tuple_get(const RDB_object *, const char *name);
</pre>

<h3>Description</h3>

<p>RDB_tuple_get returns a pointer to a RDB_object structure
which contains the value for attribute <var>name</var>.
The value is not copied.

<h3>Return value</h3>

<p>A pointer to the value of the attribute, or NULL if no
attribute with that name exists.

<hr>

<h2 id="tuple_get_bool">RDB_tuple_get_bool</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_bool
RDB_tuple_get_bool(const RDB_object *, const char *name);
</pre>

<h3>Description</h3>

<p>RDB_tuple_get_bool returns the value of attribute <var>name</var>
as a RDB_bool. The attribute must exist and it must be of
type BOOLEAN.

<h3>Return value</h3>

<p>The attribute value.

<hr>

<h2 id="tuple_get_int">RDB_tuple_get_int</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_int
RDB_tuple_get_int(const RDB_object *, const char *name);
</pre>

<h3>Description</h3>

<p>RDB_tuple_get_int returns the value of attribute <var>name</var>
as a RDB_int. The attribute must exist and it must be of
type INTEGER.

<h3>Return value</h3>

<p>The attribute value.

<hr>

<h2 id="tuple_get_rational">RDB_tuple_get_rational</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_rational
RDB_tuple_get_rational(const RDB_object *, const char *name);
</pre>

<h3>Description</h3>

<p>RDB_tuple_get_rational returns the value of attribute <var>name</var>
as a RDB_rational. The attribute must exist and it must be of
type RATIONAL.

<h3>Return value</h3>

<p>The attribute value.

<hr>

<h2 id="tuple_get_string">RDB_tuple_get_string</h2>

<pre>
#include &lt;rel/rdb.h&gt;

char *
RDB_tuple_get_string(const RDB_object *, const char *name);
</pre>

<h3>Description</h3>

<p>RDB_tuple_get_string returns a pointer to the value of attribute
<var>name</var>. The attribute must exist and it must be of
type STRING.

<h3>Return value</h3>

<p>A pointer to the attribute value.

<hr>

<h2 id="extend_tuple">RDB_extend_tuple</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_extend_tuple(RDB_object *, int attrc, <a href="#virtual_attr">RDB_virtual_attr</a> attrv[],
                 RDB_transaction *);
</pre>

<h3>Description</h3>

<p>RDB_extend_tuple extends the tuple by the attributes specified by
<var>attrc</var> and <var>attrv</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_ARGUMENT
<dd>One of the expressions specified in <var>updv</var> refers to an attribute
which does not exist in the table.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="rename_tuple">RDB_rename_tuple</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_rename_tuple(const RDB_object *, int renc, <a href="#renaming">RDB_renaming</a> renv[],
                 RDB_object *restplp);
</pre>

<h3>Description</h3>

<p>RDB_rename_tuple creates copies the tuple specified by <var>tplp</var>
to the tuple specified by <var>restplp</var>, renaming the attributes
specified by <var>renc</var> and <var>renv</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<p>The call may fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="wrap_tuple">RDB_wrap_tuple</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_wrap_tuple(const RDB_object *tplp, int wrapc, <a href="#wrapping">RDB_wrapping</a> wrapv[],
               RDB_object *restplp);
</pre>

<h3>Description</h3>

<p>RDB_wrap_tuple performs a tuple WRAP operator on the tuple pointed to by
<var>tplp</var> and stores the result in the variable pointed to by
<var>restplp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<hr>

<h2 id="unwrap_tuple">RDB_unwrap_tuple</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_unwrap_tuple(const RDB_object *tplp, int attrc, const char *attrv[],
        RDB_object *restplp);
</pre>

<h3>Description</h3>

<p>RDB_unwrap_tuple performs a tuple UNWRAP operator on the tuple pointed to by
<var>tplp</var> and stores the result in the variable pointed to by
<var>restplp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<hr>

<h2 id="init_obj">RDB_init_obj</h2>

<pre>
#include &lt;rel/rdb.h&gt;

void
RDB_init_obj(RDB_object *valp);
</pre>

<h3>Description</h3>

<p>RDB_init_obj initializes the variable pointed to by
<var>valp</var>. RDB_init_obj must be called before any other
operation can be performed on a RDB_object variable.

<hr>

<h2 id="destroy_obj">RDB_destroy_obj</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_destroy_obj(RDB_object *valp);
</pre>

<h3>Description</h3>

<p>RDB_destroy_obj frees all resources associated with a RDB_obj
variable.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<hr>

<h2 id="obj_equals">RDB_obj_equals</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_bool
RDB_obj_equals(const RDB_object *, const RDB_object *);
</pre>

<h3>Description</h3>

<p>RDB_obj_equals checks two RDB_object variables for equality.

<h3>Return value</h3>

<p>If the value of the two variables are equal, RDB_obj_equals returns RDB_TRUE,
othwerwise RDB_FALSE.

<hr>

<h2 id="copy_obj">RDB_copy_obj</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_copy_obj(RDB_object *dstvalp, const RDB_object *srcvalp);
</pre>

<h3>Description</h3>

<p>RDB_copy_obj copies the value of the RDB_object pointed to
by <var>srcp</var> to the RDB_object pointed to by <var>dstp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<p>The call may fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="bool_to_obj">RDB_bool_to_obj</h2>

<pre>
#include &lt;rel/rdb.h&gt;

void
RDB_bool_to_obj(RDB_object *valp, RDB_bool v);
</pre>

<h3>Description</h3>

<p>RDB_bool_to_obj sets the RDB_object pointed to by <var>valp</var>
to the boolean value specified by <var>v</var>.

<hr>

<h2 id="int_to_obj">RDB_int_to_obj</h2>

<pre>
#include &lt;rel/rdb.h&gt;

void
RDB_int_to_obj(RDB_object *valp, RDB_int v);
</pre>

<h3>Description</h3>

<p>RDB_bool_to_obj sets the RDB_object pointed to by <var>valp</var>
to the integer value specified by <var>v</var>.

<hr>

<h2 id="rational_to_obj">RDB_rational_to_obj</h2>

<pre>
#include &lt;rel/rdb.h&gt;

void
RDB_rational_to_obj(RDB_object *valp, RDB_rational v);
</pre>

<h3>Description</h3>

<p>RDB_obj_set_rational sets the RDB_object pointed to by <var>valp</var>
to the rational value specified by <var>v</var>.

<hr>

<h2 id="string_to_obj">RDB_string_to_obj</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_string_to_obj(RDB_object *valp, const char *str);
</pre>

<h3>Description</h3>

<p>RDB_string_to_obj sets the RDB_object pointed to by <var>valp</var>
to the string value specified by <var>str</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<hr>

<h2 id="obj_bool">RDB_obj_bool</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_bool
RDB_obj_bool(const RDB_object *valp);
</pre>

<h3>Description</h3>

<p>RDB_obj_bool returns the value of the RDB_object pointed to by
<var>valp</var> as a RDB_bool. The RDB_object must be of type
BOOLEAN.

<h3>Return value</h3>

<p>The value of the RDB_object.

<hr>

<h2 id="obj_int">RDB_obj_int</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_int
RDB_obj_int(const RDB_object *valp);
</pre>

<h3>Description</h3>

<p>RDB_obj_int returns the value of the RDB_object pointed to by
<var>valp</var> as a RDB_int. The RDB_object must be of type
INTEGER.

<h3>Return value</h3>

<p>The value of the RDB_object.

<hr>

<h2 id="obj_rational">RDB_obj_rational</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_rational
RDB_obj_rational(const RDB_object *valp);
</pre>

<h3>Description</h3>

<p>RDB_obj_rational returns the value of the RDB_object pointed to by
<var>valp</var> as a RDB_rational. The RDB_object must be of type
RATIONAL.

<h3>Return value</h3>

<p>The value of the RDB_object.

<hr>

<h2 id="obj_string">RDB_obj_string</h2>

<pre>
#include &lt;rel/rdb.h&gt;

char *
RDB_obj_string(const RDB_object *valp);
</pre>

<h3>Description</h3>

<p>RDB_obj_string returns a pointer to the value of the RDB_object pointed to by
<var>valp</var> as a char *. The RDB_object must be of type STRING.

<h3>Return value</h3>

<p>The string value of the RDB_object.

<hr>

<h2 id="obj_table">RDB_obj_table</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_table *
RDB_obj_table(const RDB_object *valp);
</pre>

<h3>Description</h3>

<p>RDB_obj_table returns a pointer to the table wrapped by the RDB_object pointed to by
<var>valp</var>. The RDB_object must be of a relation type.

<h3>Return value</h3>

<p>The table wrapped by the RDB_object.

<hr>

<h2 id="table_to_obj">RDB_table_to_obj</h2>

<pre>
#include &lt;rel/rdb.h&gt;

void
RDB_table_to_obj(RDB_object *objp, RDB_table *tbp);

</pre>

<h3>Description</h3>

<p>RDB_table_to_obj wraps the table specified by <var>tbp</var> into
the RDB_object pointed to by <var>objp</var>.

<hr>

<h2 id="obj_comp">RDB_obj_comp</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_obj_comp(const RDB_object *valp, const char *compname,
             RDB_object *comp, RDB_transaction *);
</pre>

<h3>Description</h3>

<p>RDB_obj_comp copies the value of component <var>compname</var>
of a possible representation of the variable pointed to by <var>valp</var>
to the variable pointed to by <var>comp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_ARGUMENT
<dd>The type of the variable pointed to by <var>valp</var> ist not
a scalar user-defined type.
</dl>

<p>RDB_obj_comp may also return an error code returned by a
user-provided getter function.

<p>The call may also fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="obj_set_comp">RDB_obj_set_comp</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_obj_set_comp(RDB_object *valp, const char *compname,
                 const RDB_object *comp, RDB_transaction *);
</pre>

<h3>Description</h3>

<p>RDB_obj_set_comp sets the the value of component <var>compname</var>
of a possible representation of the variable pointed to by <var>valp</var>
to the value of the riable pointed to by <var>comp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<hr>

<h2 id="binary_set">RDB_binary_set</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_binary_set(RDB_object *, size_t pos, const void *srcp, size_t len);
</pre>

<h3>Description</h3>

<p>RDB_binary_set copies <var>len</var> bytes from srcp to
the position <var>pos</var> in the RDB_object pointed to by <var>valp</var>.
<var>valp</var> must point to a RDB_object of type BINARY.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<p>The call may fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="binary_get">RDB_binary_get</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_binary_get(const RDB_object *valp, size_t pos, void *dstp, size_t len);
</pre>

<h3>Description</h3>

<p>RDB_binary_get copies <var>len</var> bytes starting at position
<var>pos</var> from the RDB_object pointed to by <var>valp</var>
to <var>dstp</var>. <var>valp</var> must point to a RDB_object of
type BINARY.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<p>The call may fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="binary_length">RDB_binary_length</h2>

<pre>
#include &lt;rel/rdb.h&gt;

size_t
RDB_binary_length(const RDB_object *valp);
</pre>

<h3>Description</h3>

<p>RDB_binary_length determines the number of bytes stored in the
RDB_object pointed to by <var>valp</var>. The RDB_object
must be of type BINARY.

<h3>Return value</h3>

<p>The length of the RDB_object.

<hr>

<h2 id="create_db_from_env">RDB_create_db_from_env</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_create_db_from_env(const char *name, RDB_environment *envp, RDB_database **dbpp);
</pre>

<h3>Description</h3>

<p>RDB_create_db_from_env creates a database from a database environment.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<hr>

<h2 id="get_db_from_env">RDB_get_db_from_env</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_get_db_from_env(const char *name, RDB_environment *envp, RDB_database **dbpp);
</pre>

<h3>Description</h3>

<p>RDB_get_db_from_env obtains a pointer to the database with name
<var>name</var> in the environment specified by <var>envp</var>
and stores this pointer at the location pointed to by <var>dbpp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<hr>

<h2 id="drop_db">RDB_drop_db</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_drop_db(RDB_database *dbp);
</pre>

<h3>Description</h3>

<p>RDB_drop_db deletes the database specified by <var>dbp</var>.
If deleting non-empty databases is supported, all tables
which belong only to this database are also deleted.
Wheter or not deleting non-empty databases is supported
is implementation-dependent.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_NOT_FOUND
<dd>The database was not found.
<dt>RDB_ELEMENT_EXISTS
<dd>The database is not empty and dropping non-empty databases is not
supported.
</dl>

<hr>

<h2 id="db_name">RDB_db_name</h2>

<pre>
#include &lt;rel/rdb.h&gt;

char *
RDB_db_name(RDB_database *dbp)
</pre>

<h3>Description</h3>

<p>RDB_db_name returns a pointer to the name of the database
specified by <var>dbp</var>.

<h3>Return value</h3>

<p>The name of the database.

<hr>

<h2 id="begin_tx">RDB_begin_tx</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_begin_tx(RDB_transaction *txp, RDB_database *dbp,
        RDB_transaction *parentp);
</pre>

<h3>Description</h3>

<p>RDB_begin_tx starts a transaction which interacts with the
database specified by <var>dbp</var>.

<p>If <var>parentp</var> is not NULL, the new transaction is
a subtransaction of the transaction specified by <var>parentp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<hr>

<h2 id="commit">RDB_commit</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_commit(RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_commit commits the transaction pointed to by <var>txp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="rollback">RDB_rollback</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_rollback(RDB_transaction *);
</pre>

<h3>Description</h3>

<p>RDB_rollback terminates the transaction pointed to by <var>txp</var>
and rolls back all changes made by this transaction and its subtrabsactions.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="tx_db">RDB_tx_db</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_database *
RDB_tx_db(RDB_transaction *txp)
</pre>

<h3>Description</h3>

<p>RDB_tx_db determines the database with which the transaction pointed
to by <var>txp</var> interacts.

<h3>Return value</h3>

<p>A pointer the RDB_database structure that represents the database.

<hr>

<h2 id="tx_is_running">RDB_tx_is_running</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_bool
RDB_tx_is_running(RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_tx_is_running determines if <var>txp</var> points to a running
transaction.

<h3>Return value</h3>

<p>RDB_TRUE if the transaction is running, RDB_FALSE otherwise.

<hr>

<h2 id="table_to_array">RDB_table_to_array</h2>

<pre>
#include &lt;rel/rdb.h&gt;

typedef struct {
    char *attrname;
    RDB_bool asc;
} RDB_seq_item;

int
RDB_table_to_array(RDB_object *arrp, RDB_table *tbp,
                   int seqitc, RDB_seq_item seqitv[],
                   RDB_transaction *);
</pre>

<h3>Description</h3>

<p>RDB_table_to_array creates an array which contains
all tuples from the table specified by <var>tbp</var>.
If <var>seqitc</var> is zero, the order of the tuples is undefined.
If <var>seqitc</var> is greater than zero, the order of the tuples
is specified by <var>seqitv</var>.

<h3>Return value</h3>

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="array_get">RDB_array_get</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_array_get(RDB_object *, RDB_int idx, RDB_object **tplpp);
</pre>

<h3>Description</h3>

<p>RDB_array_get stores a pointer to the tuple at index <var>idx</var>
at the location pointed to by <var>tplpp</var>. This pointer may become
invalid after the next invocation of RDB_array_get.
The pointer will become invalid when the array is destroyed.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<hr>

<h2 id="array_set">RDB_array_set</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_array_set(RDB_object *, RDB_int idx, const RDB_object *tplp);
</pre>

<h3>Description</h3>

<p>RDB_array_set copies the tuple pointed to by tplp
into the RDB_object at index <var>idx</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<hr>

<h2 id="array_length">RDB_array_length</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_int
RDB_array_length(RDB_object *);
</pre>

<h3>Description</h3>

<p>RDB_array_length determines the length of the array.

<h3>Return value</h3>

<p>The length of the array. A return code lower than zero
indicates an error.

<hr>

<h2 id="set_array_length">RDB_set_array_length</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_set_array_length(RDB_object *arrp, int len);
</pre>

<h3>Description</h3>

<p>RDB_set_array_length sets the length of the array specified by
<var>arrp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<hr>

<h2 id="expr_is_const">RDB_expr_is_const</h2>

<pre>
RDB_bool
RDB_expr_is_const(const RDB_expression *);
</pre>

<h3>Description</h3>

<p>RDB_expr_is_const determines if the expression is a constant expression.

<h3>Return value</h3>

<p>RDB_TRUE if the expression is a constant expression, RDB_FALSE otherwise.

<h3>Errors</h3>

<hr>

<h2 id="bool_to_expr">RDB_bool_to_expr</h2>

<pre>
RDB_expression *
RDB_bool_to_expr(RDB_bool);
</pre>

<h3>Description</h3>

<p>RDB_bool_to_expr creates a constant expression of type BOOLEAN.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="int_to_expr">RDB_int_to_expr</h2>

<pre>
RDB_expression *
RDB_int_to_expr(RDB_int);
</pre>

<h3>Description</h3>

<p>RDB_int_to_expr creates a constant expression of type INTEGER.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="rational_to_expr">RDB_rational_to_expr</h2>

<pre>
RDB_expression *
RDB_rational_to_expr(RDB_rational);
</pre>

<h3>Description</h3>

<p>RDB_rational_to_expr creates a constant expression of type RATIONAL.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="string_to_expr">RDB_string_to_expr</h2>

<pre>
RDB_expression *
RDB_string_to_expr(const char *);
</pre>

<h3>Description</h3>

<p>RDB_string_to_expr creates a constant expression of type STRING.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="obj_to_expr">RDB_obj_to_expr</h2>

<pre>
RDB_expression *
RDB_obj_to_expr(const RDB_object *valp);
</pre>

<h3>Description</h3>

<p>RDB_obj_to_expr creates a constant expression from a RDB_object.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="expr_attr">RDB_expr_attr</h2>

<pre>
RDB_expression *
RDB_expr_attr(const char *attrname);
</pre>

<h3>Description</h3>

<p>RDB_expr_attr creates an expression that represents an attribute.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="eq">RDB_eq</h2>

<pre>
RDB_expression *
RDB_eq(RDB_expression *, RDB_expression *);
</pre>

<h3>Description</h3>

<p>RDB_eq creates an expression that represents an "is equal" operator.
If one of the arguments is NULL, NULL is returned.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="neq">RDB_neq</h2>

<pre>
RDB_expression *
RDB_neq(RDB_expression *, RDB_expression *);
</pre>

<h3>Description</h3>

<p>RDB_neq creates an expression that represents an "is not equal" operator.
If one of the arguments is NULL, NULL is returned.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="lt">RDB_lt</h2>

<pre>
RDB_expression *
RDB_lt(RDB_expression *, RDB_expression *);
</pre>

<h3>Description</h3>

<p>RDB_lt creates an expression that represents a "lower than" operator.
If one of the arguments is NULL, NULL is returned.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="gt">RDB_gt</h2>

<pre>
RDB_expression *
RDB_gt(RDB_expression *, RDB_expression *);
</pre>

<h3>Description</h3>

<p>RDB_gt creates an expression that represents a "greater than" operator.
If one of the arguments is NULL, NULL is returned.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="let">RDB_let</h2>

<pre>
RDB_expression *
RDB_let(RDB_expression *, RDB_expression *);
</pre>

<h3>Description</h3>

<p>RDB_let creates an expression that represents a "lower or equal than" operator.
If one of the arguments is NULL, NULL is returned.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="get">RDB_get</h2>

<pre>
RDB_expression *
RDB_get(RDB_expression *, RDB_expression *);
</pre>

<h3>Description</h3>

<p>RDB_get creates an expression that represents a "greater or equal than" operator.
If one of the arguments is NULL, NULL is returned.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="and">RDB_and</h2>

<pre>
RDB_expression *
RDB_and(RDB_expression *, RDB_expression *);
</pre>

<h3>Description</h3>

<p>RDB_and creates an expression that represents a logical AND.
If one of the arguments is NULL, NULL is returned.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="or">RDB_or</h2>

<pre>
RDB_expression *
RDB_or(RDB_expression *, RDB_expression *);
</pre>

<h3>Description</h3>

<p>RDB_or creates an expression that represents a logical OR.
If one of the arguments is NULL, NULL is returned.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="not">RDB_not</h2>

<pre>
RDB_expression *
RDB_not(RDB_expression *);
</pre>

<h3>Description</h3>

<p>RDB_or creates an expression that represents a logical NOT.
If the argument is NULL, NULL is returned.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="add">RDB_add</h2>

<pre>
RDB_expression *
RDB_add(RDB_expression *, RDB_expression *);
</pre>

<h3>Description</h3>

<p>RDB_add creates an expression that represents an arithmetical addition.
Both arguments must be numeric and of the same type.
If one of the arguments is NULL, NULL is returned.


<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="subtract">RDB_subtract</h2>

<pre>
RDB_expression *
RDB_subtract(RDB_expression *, RDB_expression *);
</pre>

<h3>Description</h3>

<p>RDB_subtract creates an expression that represents an arithmetical
subtraction. Both arguments must be numeric and of the same type.
If one of the arguments is NULL, NULL is returned.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="negate">RDB_negate</h2>

<pre>
RDB_expression *
RDB_negate(RDB_expression *);
</pre>

<h3>Description</h3>

<p>RDB_negate creates an expression that represents a unary
minus. The argument must be numeric.
If it is NULL, NULL is returned.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="multiply">RDB_multiply</h2>

<pre>
RDB_expression *
RDB_multiply(RDB_expression *, RDB_expression *);
</pre>

<h3>Description</h3>

<p>RDB_multiply creates an expression that represents an arithmetical
multiplication. Both arguments must be numeric and of the same type.
If one of the arguments is NULL, NULL is returned.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="divide">RDB_divide</h2>

<pre>
RDB_expression *
RDB_divide(RDB_expression *, RDB_expression *);
</pre>

<h3>Description</h3>

<p>RDB_subtract creates an expression that represents an arithmetical
division. Both arguments must be numeric and of the same type.
If one of the arguments is NULL, NULL is returned.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="concat">RDB_concat</h2>

<pre>
RDB_expression *
RDB_concat(RDB_expression *, RDB_expression *);
</pre>

<h3>Description</h3>

<p>RDB_concat creates an expression that represents a string
concatenation. Both arguments must be of type STRING.
If one of the arguments is NULL, NULL is returned.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="strlen">RDB_strlen</h2>

<pre>
RDB_expression *
RDB_strlen(RDB_expression *arg);
</pre>

<h3>Description</h3>

<p>RDB_subtract creates an expression that represents a string length
operator. If the argument is NULL, NULL is returned.


<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="regmatch">RDB_regmatch</h2>

<pre>
RDB_expression *
RDB_regmatch(RDB_expression *arg1p, RDB_expression *arg2p);
</pre>

<h3>Description</h3>

<p>RDB_regmatch creates an expression that represents a regular
expression match. Both subexpressions must be of type STRING.
The expression evaluates to RDB_TRUE if the expression represented by arg1p
evaluates to a string that matches the regular expression
to which the expression represented by arg2p evaluates.
If one of the arguments is NULL, NULL is returned.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="table_to_expr">RDB_table_to_expr</h2>

<pre>
RDB_expression *
RDB_table_to_expr(RDB_table *);
</pre>

<h3>Description</h3>

<p>RDB_table_to_expr creates an expression that represents a table.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="expr_is_empty">RDB_expr_is_empty</h2>

<pre>
RDB_expression *
RDB_expr_is_empty(RDB_expression *);
</pre>

<h3>Description</h3>

<p>RDB_expr_is_empty creates an expression which evaluates to RDB_TRUE
if the subexpression evaluates to an empty table.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="expr_any">RDB_expr_any</h2>

<pre>
RDB_expression *
RDB_expr_any(RDB_expression *, const char *attrname);
</pre>

<h3>Description</h3>

<p>RDB_expr_ creates an expression which represents the <a
href="#any">RDB_any</a> operator.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="expr_all">RDB_expr_all</h2>

<pre>
RDB_expression *
RDB_expr_all(RDB_expression *, const char *attrname);
</pre>

<h3>Description</h3>

<p>RDB_expr_ creates an expression which represents the <a
href="#all">RDB_all</a> operator.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="expr_avg">RDB_expr_avg</h2>

<pre>
RDB_expression *
RDB_expr_avg(RDB_expression *, const char *attrname);
</pre>

<h3>Description</h3>

<p>RDB_expr_avg creates an expression which represents the <a
href="#avg">RDB_avg</a> operator.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="expr_cardinality">RDB_expr_cardinality</h2>

<pre>
RDB_expression *
RDB_expr_cardinality(RDB_expression *arg1);
</pre>

<h3>Description</h3>

<p>RDB_expr_cardinality creates an expression which represents the <a
href="#cardinality">RDB_cardinality</a> operator.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="expr_max">RDB_expr_max</h2>

<pre>
RDB_expression *
RDB_expr_max(RDB_expression *, const char *attrname);
</pre>

<h3>Description</h3>

<p>RDB_expr_ creates an expression which represents the <a
href="#max">RDB_max</a> operator.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="expr_min">RDB_expr_min</h2>

<pre>
RDB_expression *
RDB_expr_min(RDB_expression *, const char *attrname);
</pre>

<h3>Description</h3>

<p>RDB_expr_min creates an expression which represents the <a
href="#min">RDB_min</a> operator.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="expr_sum">RDB_expr_sum</h2>

<pre>
RDB_expression *
RDB_expr_sum(RDB_expression *, const char *attrname);
</pre>

<h3>Description</h3>

<p>RDB_expr_sum creates an expression which represents the <a
href="#sum">RDB_sum</a> operator.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="expr_comp">RDB_expr_comp</h2>

<pre>
RDB_expression *
RDB_expr_comp(RDB_expression *arg, const char *compname);
</pre>

<h3>Description</h3>

<p>RDB_expr_comp creates an expression which evaluates to a
possible representation component.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="user_op">RDB_user_op</h2>

<pre>
int
RDB_user_op(const char *opname, int argc, RDB_expression *argv[],
       RDB_transaction *txp, RDB_expression **expp);
</pre>

<h3>Description</h3>

<p>RDB_user_op creates an expression which represents the invocation
of a user-defined operator and stores a pointer to the expression
at the location pointed to by <var>expp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_NOT_FOUND
<dd>The user-defined operator was not found.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="drop_expr">RDB_drop_expr</h2>

<pre>
void
RDB_drop_expr(RDB_expression *exp);
</pre>

<h3>Description</h3>

<p>RDB_drop_expr frees the memory pointed to by <var>exprp</var> and calls
RDB_drop_expr on all subexpressions.

<h3>Return value</h3>

<h3>Errors</h3>

<hr>

<h2 id="define_type">RDB_define_type</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_define_type(const char *name, int repc, <a href="#possrep">RDB_possrep</a> repv[],
                RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_define_type defines a type with the name <var>name</var> and
<var>repc</var> possible representations.
The individual possible representations are
described by the elements of <var>repv</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_ELEMENT_EXISTS
<dd>There is already a type with name <var>name</var>.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="implement_type">RDB_implement_type</h2>

<pre>
#include &lt;rel/typeimpl.h&gt;

RDB_implement_type(const char *name, RDB_type *arep,
                   size_t areplen, RDB_transaction *txp);
</pre>

<p>Note: The specification of RDB_implement_type is not stable yet;
it will probably change in future versions of Duro.

<h3>Description</h3>

<p>RDB_implement_type implements the user-defined type with name
<var>name</var>. After RDB_implement_type was inkoved successfully,
this type may be used for local variables and table attributes.

<p>If <var>arep</var> is not NULL, it must point to a type which is used
as the actual representation.

<p>If <var>arep</var> is NULL and <var>areplen</var> is not -1,
<var>areplen</var> specifies the length, in bytes,
of the actual representation,
which is a fixed-length array of bytes.

<p>If <var>arep</var> is NULL and <var>areplen</var> is not -1,
the getter functions, setter functions, and selector
must be provided by the user.
Otherwise, these functions are provided by Duro,
the type may only have one possible representation,
and this representation becomes the actual representation.

<p>...

<h3>Return value</h3>

<p>On success, RDB_OK is returned. Any other return value indicates an error.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_INVALID_ARGUMENT
<dd>An invalid combination of <var>libname</var> and <var>arep</var> was
used.
<dt>RDB_NOT_SUPPORTED
<dd>The requested internal representation is not supported by this version
of the library.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="create_tuple_type">RDB_create_tuple_type</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_type *
RDB_create_tuple_type(int attrc, <a href="#attr">RDB_attr</a> attrv[]);
</pre>

<h3>Description</h3>

<p>RDB_create_tuple_type creates a transient tuple type. The attributes
are specified by <var>attrc</var> and <var>attrv</var>.
The fields defaultp and options of RDB_attr are ignored.

<h3>Return value</h3>

<p>A pointer to the newly created type, or NULL if the creation failed.

<hr>

<h2 id="create_relation_type">RDB_create_relation_type</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_type *
RDB_create_relation_type(int attrc, RDB_attr attrv[]);
</pre>

<h3>Description</h3>

<p>RDB_create_relation_type creates a transient relation type. The attributes
are specified by <var>attrc</var> and <var>attrv</var>.

<h3>Return value</h3>

<p>A pointer to the newly created type, or NULL if the creation failed.

<hr>

<h2 id="get_type">RDB_get_type</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_get_type(const char *name, RDB_transaction *, RDB_type **typp);
</pre>

<h3>Description</h3>

<p>RDB_get_type obtains a pointer to RDB_type structure which
represents the type with the name <var>name</var>
and stores that pointer at the location pointed to by <var>typp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. Any other return value indicates an error.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_NOT_FOUND
<dd>A type with the name <var>name</var> could not be found.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="drop_type">RDB_drop_type</h2>

<pre>
#include &lt;rel/rdb.h&gt;

void
RDB_drop_type(RDB_type *typ, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_drop_type destroys the type specified by <var>typ</var>.

<p>If the type is transient, the argument <var>txp</var> is ignored.

<p>It is not possible to destroy built-in types.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. Any other return value indicates an error.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_INVALID_ARGUMENT
<dd>The type is a builtin type.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="type_name">RDB_type_name</h2>

<pre>
#include &lt;rel/rdb.h&gt;

char *
RDB_type_name(const RDB_type *);
</pre>

<h3>Description</h3>

<p>RDB_type_name returns the name of a type.

<h3>Return value</h3>

<p>A pointer to the name of the type or NULL if the type has no name.

<hr>

<h2 id="type_is_scalar">RDB_type_is_scalar</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_bool
RDB_type_is_scalar(const RDB_type *);
</pre>

<h3>Description</h3>

<p>RDB_type_is_scalar checks if a type is scalar.

<h3>Return value</h3>

<p>RDB_TRUE if the type is scalar, RDB_FALSE otherwise.

<hr>

<h2 id="type_is_numeric">RDB_type_is_numeric</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_bool
RDB_type_is_numeric(const RDB_type *);
</pre>

<h3>Description</h3>

<p>RDB_type_is_numeric checks if a type is numeric.

<h3>Return value</h3>

<p>RDB_TRUE if the type is INTEGER or RATIONAL, RDB_FALSE otherwise.

<h3>Return value</h3>

<hr>

<h2 id="type_equals">RDB_type_equals</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_bool
RDB_type_equals(const RDB_type *, const RDB_type *);
</pre>

<h3>Description</h3>

<p>RDB_type_equals checks if two types are equal.

<p>Nonscalar types are equal if there definition is the same.

<h3>Return value</h3>

<p>RDB_TRUE if the types are equal, RDB_FALSE otherwise.

<hr>

<h2 id="create_ro_op">RDB_create_ro_op</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_create_ro_op(const char *name, int argc, RDB_type *argtv[], RDB_type *rtyp,
                 const char *libname, const char *sym,
                 const void *iargp, size_t iarglen,
                 RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_create_ro_op creates a read-only operator with name <var>name</var>.
The argument types are specified by <var>argc</var> and <var>argtv</var>.

<p>To execute the operator, Duro will execute the function specified by
<var>sym</var> from the library specified by <var>libname</var>.

<p>This function must have the following signature:

<pre>
int
&lt;sym&gt;(const char *name, int argc, RDB_object *argv[],
          const void *iargp, size_t iarglen, RDB_transaction *txp,
          RDB_object *retvalp)
</pre>

<p>When the function is executed, the name of the operator is passed through <var>name</var>
and the arguments are passed through <var>argc</var> and <var>argv</var>.

<p>The function specified by <var>sym</var> must store the result at the
location specified by <var>retvalp</var> and return RDB_OK.
It can indicate an error condition by returning an error code.

<p>If <var>iargp</var> is not NULL, it must point to a byte block
of length <var>iarglen</var> which will be passed to the function
specified by <var>sym</var>.
This can be used to pass code to an interpreter function.

<p>Overloading operators is possible.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_ELEMENT_EXISTS
<dd>A read-only operator with this name and signature does already exists.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="create_update_op">RDB_create_update_op</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_create_update_op(const char *name, int argc, RDB_type *argtv[],
                  RDB_bool upd[], const char *libname, const char *sym,
                  const void *iargp, size_t iarglen,
                  RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_create_update_op creates an update operator with name <var>name</var>.
The argument types are specified by <var>argc</var> and <var>argtv</var>.

<p>The argument <var>upd</var> specifies which of the arguments are updated.
If upd[<em>i</em>] is RDB_TRUE, this indicates that the <em>i</em>th argument
is updated by the operator.

<p>To execute the operator, Duro will execute the function specified by
<var>sym</var> from the library specified by <var>libname</var>.

<p>This function must have the following signature:

<pre>
int
&lt;sym&gt;(const char *name, int argc, RDB_object *argv[],
        RDB_bool updv[], const void *iargp, size_t iarglen, RDB_transaction *txp)

</pre>

<p>When the function is executed, the name of the operator is passed through <var>name</var>
and the arguments are passed through <var>argc</var> and <var>argv</var>.

<p>On success, the function specified by <var>sym</var> must return RDB_OK.
It can indicate an error condition by returning an error code.

<p>If <var>iargp</var> is not NULL, it must point to a byte block
of length <var>iarglen</var> which will be passed to the function
specified by <var>sym</var>.
This can be used to pass code to an interpreter function.

<p>Overloading functions is possible.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_ELEMENT_EXISTS
<dd>An update operator with this name and signature does already exists.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="call_ro_op">RDB_call_ro_op</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_call_ro_op(const char *name, int argc, RDB_object *argv[],
               RDB_object *retvalp, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_call_ro_op invokes the read-only operator with the name <var>name</var>,
passing the arguments in <var>argc</var> and <var>argv</var>.

<p>The result will be stored at the location pointed to by
<var>retvalp</var>. 

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_NOT_FOUND
<dd>A read-only operator that matches the name and arguments could not be
found.
</dl>

<p>If the user-supplied function which implements the function returns an
error code, this code is returned.

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="call_update_op">RDB_call_update_op</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_call_update_op(const char *name, int argc, RDB_object *argv[],
                RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_call_update_op invokes the update operator with the name <var>name</var>,
passing the arguments in <var>argc</var> and <var>argv</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_NOT_FOUND
<dd>An update operator that matches the name and arguments could not be
found.
</dl>

<p>If the user-supplied function which implements the operator returns an
error code, this code is returned.

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="drop_op">RDB_drop_op</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_drop_op(const char *name, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_drop_op deletes the operator with the name <var>name</var>
from the database. This affects all overloaded versions.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_NOT_FOUND
<dd>An operator with the specified name could not be found.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="create_constraint">RDB_create_constraint</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_create_constraint(const char *name, RDB_expression *constrp,
                      RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_create_constraint creates a constraint with the name <var>name</var>
on the database the transaction specified by <var>txp</var> interacts with.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_TYPE_MISMATCH
<dd>The expression specified by <var>constrp</var> is not of type BOOLEAN.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="drop_constraint">RDB_drop_constraint</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_drop_constraint(const char *name, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_drop_constraint deletes the constraint with the name <var>name</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_NOT_FOUND
<dd>A constraint with the name <var>name</var> could not be found.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="begin_uoi">RDB_begin_uoi</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_begin_uoi(RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_begin_uoi starts a unit of integrity (UOI), which means that
integrity checking is delayed until the of the UOI.
UOIs cannot be nested.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_INVALID_ARGUMENT
<dd>A unit of integrity has already been started.
</dl>

<hr>

<h2 id="end_uoi">RDB_end_uoi</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_end_uoi(RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_end_uoi ends a unit of integrity.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_INVALID_ARGUMENT
<dd>A unit of integrity has not been started.
<dt>RDB_PREDICATE_VIOLATION
<dd>A violation of an integrity constraint has been detected.
</dl>

<hr>

<h2 id="create_env">RDB_create_env</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_create_env(const char *path, RDB_environment **);
</pre>

<h3>Description</h3>

<p>RDB_create_env creates a database environment from the
system resource <var>path</var>. See the release notes for details.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_RESOURCE_NOT_FOUND
<dd>The resource specified by <var>path</var> could not be found.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>
different from RDB_RESOURCE_NOT_FOUND.

<hr>

<h2 id="open_env">RDB_open_env</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_open_env(const char *path, RDB_environment **envp);
</pre>

<h3>Description</h3>

<p>RDB_open_env opens a database environment identified by the
system resource <var>path</var>.  See the release notes for details.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_RESOURCE_NOT_FOUND
<dd>The resource specified by <var>path</var> could not be found.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>
different from RDB_RESOURCE_NOT_FOUND.

<h3>Return value</h3>

<h3>Errors</h3>

<hr>

<h2 id="close_env">RDB_close_env</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_close_env(RDB_environment *envp);
</pre>

<h3>Description</h3>

<p>RDB_close_env closes the database environment specified by
<var>envp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<p>The call may fail for a <a href="#syserr">system error</a>

<hr>

<h2 id="set_errfile">RDB_set_errfile</h2>

<pre>
#include &lt;rel/rdb.h&gt;

void
RDB_set_errfile(RDB_environment *, FILE *errfile);
</pre>

<h3>Description</h3>

<p>RDB_set_errfile sets a C library FILE * to be used for error messages.

<hr>

<h2 id="strerror">RDB_strerror</h2>

<pre>
#include &lt;rel/rdb.h&gt;

const char *
RDB_strerror(int err);
</pre>

<h3>Description</h3>

<p>Returns a string describing the Duro error code passed in the
argument <var>err</var>.

<h3>Return value</h3>

<p>Returns the appropriate description string, or an unkown
error message if the error code is unkown.

<hr>

<h2 id="is_syserr">RDB_is_syserr</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_is_syserr(int err);
</pre>

<h3>Description</h3>

<p>Checks whether <var>err</var> represents a system error.

<h3>Return value</h3>

<p>The value returned is nonzero if <var>err</var> represents a system error,
and zero if it does not.

<hr>

<h2 id="parse_expr">RDB_parse_expr</h2>

<pre>
#include &lt;dli/parse.h&gt;

typedef RDB_table *RDB_ltablefn(const char *, void *);

int
RDB_parse_expr(const char *exprtxt, RDB_ltablefn *ltfnp, void *arg, RDB_transaction *,
        RDB_expression **);

int
RDB_parse_table(const char *txt, RDB_ltablefn *ltfnp, void *arg, RDB_transaction *,
        RDB_table **);
</pre>

<h3>Description</h3>

<p>These function parse the <a href="expressions.html">expression</a>
specified by <var>exprtxt</var>. If <var>ltfnp</var> is not NULL,
it must point to a function which is used to look up local tables.
The function is invoked with the table name and <var>argp</var> as
arguments. It must return a pointer to the table or NULL if the table was
not found.

<p>RDB_parse_expr converts an expression into a RDB_expression.

<p>RDB_parse_table converts an expression into a virtual table.

<hr>

<h2 id="attr">RDB_attr</h2>

<pre>
typedef struct {
    char *name;
    RDB_type *typ;
    RDB_object *defaultp;
    int options;
} RDB_attr;
</pre>

<hr>

<h2 id="virtual_attr">RDB_virtual_attr</h2>

<pre>
typedef struct {
    char *name;
    RDB_expression *exp;
} RDB_virtual_attr;
</pre>

<hr>

<h2 id="renaming">RDB_renaming</h2>

<pre>
typedef struct {
    char *from;
    char *to;
} RDB_renaming;
</pre>

<hr>

<h2 id="wrapping">RDB_wrapping</h2>

<pre>
typedef struct {
    int attrc;
    char **attrv;
    char *attrname;
} RDB_wrapping;
</pre>

<hr>

<h2 id="possrep">RDB_possrep</h2>

<pre>
typedef struct {
    char *name;
    int compc;
    RDB_attr *compv;
    RDB_expression *constraintp;
} RDB_possrep;
</pre>

<hr>

<h2 id="aggregate_op">RDB_aggregate_op</h2>

<pre>
typedef enum {
    RDB_COUNT, RDB_SUM, RDB_AVG, RDB_MAX, RDB_MIN, RDB_ALL, RDB_ANY,
    RDB_COUNTD, RDB_SUMD, RDB_AVGD
} RDB_aggregate_op;
</pre>

<hr>

<h2 id="syserr">System errors</h2>

<dl>
<dt>RDB_NO_SPACE
<dd>Insufficient disk space.
<dt>RDB_NO_MEMORY
<dd>Insufficient memory.
<dt>RDB_DEADLOCK
<dd>A deadlock condition was detected.
<dt>RDB_INTERNAL
<dd>Internal error.
<dt>RDB_RESOURCE_NOT_FOUND
<dd>A system resource, usually a file, could not be found.
<dt>RDB_SYSTEM_ERROR
<dd>Unspecified system error.
</dl>

<hr>

<p>$Id$

</html>
