<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
"http://www.w3.org/TR/html4/strict.dtd">
<html lang="en">
<head>
<title>Duro API specification</title>
<!-- $Id$ -->
<body>
<h1>Duro API specification</h1>

<p>- DRAFT -

<h2>Contents</h2>

<h3>Built-in types</h3>

<p><a href="#built-in-types">Table of built-in types</a>

<h3>Table functions</h3>

<ul>
<li><a href="#aggregate">RDB_aggregate</a>
<li><a href="#copy_table">RDB_copy_table</a>
<li><a href="#create_table">RDB_create_table</a>
<li><a href="#delete">RDB_delete</a>
<li><a href="#drop_table">RDB_drop_table</a>
<li><a href="#extend">RDB_extend</a>
<li><a href="#extract_tuple">RDB_extract_tuple</a>
<li><a href="#gdivide">RDB_gdivide</a>
<li><a href="#get_table">RDB_get_table</a>
<li><a href="#group">RDB_group</a>
<li><a href="#insert">RDB_insert</a>
<li><a href="#intersect">RDB_intersect</a>
<li><a href="#join">RDB_join</a>
<li><a href="#make_persistent">RDB_make_persistent</a>
<li><a href="#minus">RDB_minus</a>
<li><a href="#project">RDB_project</a>
<li><a href="#rename">RDB_rename</a>
<li><a href="#sdivide">RDB_sdivide</a>
<li><a href="#select">RDB_select</a>
<li><a href="#set_table_name">RDB_set_table_name</a>
<li><a href="#summarize">RDB_summarize</a>
<li><a href="#table_contains">RDB_table_contains</a>
<li><a href="#table_is_empty">RDB_table_is_empty</a>
<li><a href="#table_name">RDB_table_name</a>
<li><a href="#ungroup">RDB_ungroup</a>
<li><a href="#union">RDB_union</a>
<li><a href="#unwrap">RDB_unwrap</a>
<li><a href="#update">RDB_update</a>
<li><a href="#wrap">RDB_wrap</a>
</ul>

<h3>Tuple functions</h3>

<ul>
<li><a href="#destroy_tuple">RDB_destroy_tuple</a>
<li><a href="#extend_tuple">RDB_extend_tuple</a>
<li><a href="#init_tuple">RDB_init_tuple</a>
<li><a href="#join_tuples">RDB_join_tuples</a>
<li><a href="#project_tuple">RDB_project_tuple</a>
<li><a href="#rename_tuple">RDB_rename_tuple</a>
<li><a href="#tuple_get">RDB_tuple_get</a>
<li><a href="#tuple_get_bool">RDB_tuple_get_bool</a>
<li><a href="#tuple_get_int">RDB_tuple_get_int</a>
<li><a href="#tuple_get_rational">RDB_tuple_get_rational</a>
<li><a href="#tuple_get_string">RDB_tuple_get_string</a>
<li><a href="#tuple_set">RDB_tuple_set</a>
<li><a href="#tuple_set_bool">RDB_tuple_set_bool</a>
<li><a href="#tuple_set_int">RDB_tuple_set_int</a>
<li><a href="#tuple_set_rational">RDB_tuple_set_rational</a>
<li><a href="#tuple_set_string">RDB_tuple_set_string</a>
<li><a href="#unwrap_tuple">RDB_unwrap_tuple</a>
<li><a href="#wrap_tuple">RDB_wrap_tuple</a>
</ul>

<h3>RDB_object functions</h3>

<ul>
<li><a href="#binary_get">RDB_binary_get</a>
<li><a href="#binary_set">RDB_binary_set</a>
<li><a href="#binary_length">RDB_binary_length</a>
<li><a href="#copy_obj">RDB_copy_obj</a>
<li><a href="#destroy_obj">RDB_destroy_obj</a>
<li><a href="#init_obj">RDB_init_obj</a>
<li><a href="#obj_bool">RDB_obj_bool</a>
<li><a href="#obj_comp">RDB_obj_comp</a>
<li><a href="#obj_equals">RDB_obj_equals</a>
<li><a href="#obj_int">RDB_obj_int</a>
<li><a href="#obj_rational">RDB_obj_rational</a>
<li><a href="#obj_set_array">RDB_obj_set_array</a>
<li><a href="#obj_set_bool">RDB_obj_set_bool</a>
<li><a href="#obj_set_int">RDB_obj_set_int</a>
<li><a href="#obj_set_rational">RDB_obj_set_rational</a>
<li><a href="#obj_set_string">RDB_obj_set_string</a>
<li><a href="#obj_set_tuple">RDB_obj_set_tuple</a>
<li><a href="#obj_set_comp">RDB_obj_set_comp</a>
<li><a href="#obj_string">RDB_obj_string</a>
<li><a href="#obj_tuple">RDB_obj_tuple</a>
<li><a href="#select_obj">RDB_select_obj</a>
</ul>

<h3>Database functions</h3>

<ul>
<li><a href="#create_db_from_env">RDB_create_db_from_env</a>
<li><a href="#db_name">RDB_db_name</a>
<li><a href="#drop_db">RDB_drop_db</a>
<li><a href="#get_db_from_env">RDB_get_db_from_env</a>
<li><a href="#release_db">RDB_release_db</a>
</ul>

<h3>Transaction functions</h3>

<ul>
<li><a href="#begin_tx">RDB_begin_tx</a>
<li><a href="#commit">RDB_commit</a>
<li><a href="#rollback">RDB_rollback</a>
<li><a href="#tx_is_db">RDB_tx_db</a>
<li><a href="#tx_is_running">RDB_tx_is_running</a>
</ul>

<h3>Array functions</h3>

<ul>
<li><a href="#array_get_tuple">RDB_array_get_tuple</a>
<li><a href="#array_length">RDB_array_length</a>
<li><a href="#array_set_tuple">RDB_array_set_tuple</a>
<li><a href="#destroy_array">RDB_destroy_array</a>
<li><a href="#init_array">RDB_init_array</a>
<li><a href="#table_to_array">RDB_table_to_array</a>
<li><a href="#set_array_length">RDB_set_array_length</a>
</ul>

<h3>Expression functions</h3>

<ul>
<li><a href="#expr_type">RDB_expr_type</a>
<li><a href="#expr_is_const">RDB_expr_is_const</a>
<li><a href="#bool_const">RDB_bool_const</a>
<li><a href="#int_const">RDB_int_const</a>
<li><a href="#rational_const">RDB_rational_const</a>
<li><a href="#string_const">RDB_string_const</a>
<li><a href="#obj_const">RDB_obj_const</a>
<li><a href="#expr_attr">RDB_expr_attr</a>
<li><a href="#eq">RDB_eq</a>
<li><a href="#neq">RDB_neq</a>
<li><a href="#lt">RDB_lt</a>
<li><a href="#gt">RDB_gt</a>
<li><a href="#let">RDB_let</a>
<li><a href="#get">RDB_get</a>
<li><a href="#and">RDB_and</a>
<li><a href="#or">RDB_or</a>
<li><a href="#not">RDB_not</a>
<li><a href="#add">RDB_add</a>
<li><a href="#subtract">RDB_subtract</a>
<li><a href="#strlen">RDB_strlen</a>
<li><a href="#regmatch">RDB_regmatch</a>
<li><a href="#expr_table">RDB_expr_table</a>
<li><a href="#expr_is_empty">RDB_expr_is_empty</a>
<li><a href="#expr_aggregate">RDB_expr_aggregate</a>
<li><a href="#expr_comp">RDB_expr_comp</a>
<li><a href="#selector">RDB_selector</a>
<li><a href="#user_op">RDB_user_op</a>
<li><a href="#drop_expr">RDB_drop_expr</a>
</ul>

<h3>Type functions</h3>

<ul>
<li><a href="#define_type">RDB_define_type</a>
<li><a href="#implement_type">RDB_implement_type</a>
<li><a href="#create_tuple_type">RDB_create_tuple_type</a>
<li><a href="#create_relation_type">RDB_create_relation_type</a>
<li><a href="#get_type">RDB_get_type</a>
<li><a href="#drop_type">RDB_drop_type</a>
<li><a href="#type_name">RDB_type_name</a>
<li><a href="#type_is_scalar">RDB_type_is_scalar</a>
<li><a href="#type_is_numeric">RDB_type_is_numeric</a>
<li><a href="#type_equals">RDB_type_equals</a>
</ul>

<h3>Operator functions</h3>

<ul>
<li><a href="#create_ro_op">RDB_create_ro_op</a>
<li><a href="#create_update_op">RDB_create_update_op</a>
<li><a href="#call_ro_op">RDB_call_ro_op</a>
<li><a href="#call_update_op">RDB_call_update_op</a>
<li><a href="#drop_op">RDB_drop_op</a>
</ul>

<h3>Constraint functions</h3>

<ul>
<li><a href="#create_constraint">RDB_create_constraint</a>
<li><a href="#drop_constraint">RDB_drop_constraint</a>
<li><a href="#begin_uoi">RDB_begin_uio</a>
<li><a href="#end_uoi">RDB_end_uio</a>
</ul>

<h3>Database Environment functions</h3>

<ul>
<li><a href="#create_env">RDB_create_env</a>
<li><a href="#open_env">RDB_open_env</a>
<li><a href="#close_env">RDB_close_env</a>
<li><a href="#set_errfile">RDB_set_errfile</a>
</ul>

<h3>Error handling functions</h3>

<ul>
<li><a href="#strerror">RDB_strerror</a>
<li><a href="#is_syserr">RDB_is_syserr</a>
</ul>

<h3>C structures and definitions</h3>

<ul>
<li><a href="#attr">RDB_attr</a>
<li><a href="#virtual_attr">RDB_virtual_attr</a>
<li><a href="#renaming">RDB_renaming</a>
<li><a href="#wrapping">RDB_wrapping</a>
<li><a href="#possrep">RDB_possrep</a>
<li><a href="#aggregate_op">RDB_aggregate_op</a>
<li><a href="#syserr">System errors</a>
</ul>

<h2 id="built-in-types">Built-in types</h2>

<table border="1">
<tr><th>Name<th>RDB_type variable<th>C type
<tr><td>BOOLEAN<td>RDB_BOOLEAN<td>RDB_bool
<tr><td>INTEGER<td>RDB_INTEGER<td>RDB_int
<tr><td>RATIONAL<td>RDB_RATIONAL<td>RDB_rational
<tr><td>STRING<td>RDB_STRING<td>char *
<tr><td>BINARY<td>RDB_BINARY<td>&nbsp;-
</table>

<hr>

<h2 id="create_table">RDB_create_table</h2>

<pre>
#include &lt;rel/rdb.h&gt;

typedef struct {
    int strc;
    char **strv;
} RDB_string_vec;

int
RDB_create_table(const char *name, RDB_bool persistent,
                 int attrc, <a href="#attr">RDB_attr</a> attrv[],
                 int keyc, RDB_string_vec keyv[],
                 RDB_transaction *txp, RDB_table **tbpp);
</pre>

<h3>Description</h3>

<p>RDB_create_table creates a table with name <var>name</var> under the control of
the transaction pointed to by <var>txp</var>.
A pointer to the newly created RDB_table structure
will be stored at the location pointed to by <var>tbpp</var>.

<p>If <var>persistent</var> is RDB_FALSE, a transient (local) table will be created.
In this case, <var>name</var> may be NULL.

<p>If <var>persistent</var> is RDB_TRUE, a persistent (global) table in the database associated
with the transaction pointed to by <var>txp</var> will be created.

<p>The table will have <var>attrc</var> attributes. The individual
attributes are specified by the elements of <var>attrv</var>.

<p>The fields of the RDB_attr structure are interpreted as follows:

<dl>
<dt>name
<dd>Specifies the name of the attribute.
<dt>typ
<dd>Specifies the type of the attribute.
<dt>defaultp
<dd>If not NULL, this field must point to a RDB_object variable that specifies
the default value for the attribute.
<dt>options
<dd>May be either zero, or RDB_SYSTEM_GENERATED. In the latter case
the attribute must be a candidate key, and the system then will automatically
generate a value for that attribute on insertion.
</dl>

<p>The table will have <var>keyc</var> candidate keys. The <var>keyv</var>
argument specifies the names of the candidate keys.
The strc field of the RDB_string_vec structure specifies
the number of fields in a key, while the elements of the strv field specify
the names of the key attributes.

<p>At least one candidate key must be specified.
A candidate key may not be a true subset of another.
If a single candidate key is specified, that key
may be empty (not contain any attribute).

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_TYPE_MISMATCH
<dd>The type of a default value does not match the type of the attribute.
<dt>RDB_INVALID_ARGUMENT
<dd>One or more of the arguments are incorrect. For example, a key attribute
does not appear in <var>attrv</var>, etc.
<dt>RDB_NOT_SUPPORTED
<dd>The combination of arguments is not supported by the version
of Duro used. Consult the release notes of that version for details.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<h2 id="get_table">RDB_get_table</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_get_table(const char *name, RDB_transaction *txp, RDB_table **tbpp);
</pre>

<h3>Description</h3>

<p>RDB_get_table looks up a table with name <var>name</var>
in the database asociated with the transaction specified by <var>txp</var>
and stores a pointer to a RDB_table structure in <var>tbpp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_NOT_FOUND
<dd>A table with the name <var>name</var> could not be found.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="drop_table">RDB_drop_table</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_drop_table(RDB_table *tbp, RDB_transaction *);
</pre>

<h3>Description</h3>

<p>RDB_drop_table deletes the table specified by <var>tbp</var>
and frees all resources associated with that table.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="table_name">RDB_table_name</h2>

<pre>
#include &lt;rel/rdb.h&gt;

char *
RDB_table_name(RDB_table *tbp)
</pre>

<h3>Description</h3>

<p>RDB_table_name returns a pointer to the name of a table.

<h3>Return value</h3>

<p>A pointer to the name of the table, or NULL if the table has no name.

<hr>

<h2 id="set_table_name">RDB_set_table_name</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_set_table_name(RDB_table *tbp, const char *name, RDB_transaction *);
</pre>

<h3>Description</h3>

<p>RDB_set_table_name sets the name of the table to <var>name</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_INVALID_ARGUMENT
<dd><var>name</var> is not a valid table name.
<dt>RDB_NOT_SUPPORTED
<dd>The combination of arguments is not supported by the version
of Duro used. Consult the release notes of that version for details.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="make_persistent">RDB_make_persistent</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_make_persistent(RDB_table *, RDB_transaction *);
</pre>

<h3>Description</h3>

<p>RDB_make_persistent makes a table persistent.
The table must have a name.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_INVALID_ARGUMENT
<dd>The table does not have a name.
<dt>RDB_NOT_SUPPORTED
<dd>The combination of arguments is not supported by the version
of Duro used. Consult the release notes of that version for details.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="table_contains">RDB_table_contains</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_table_contains(RDB_table *tbp, const RDB_tuple *tplp, RDB_transaction *);
</pre>

<h3>Description</h3>

<p>RDB_table_contains checks if the tuple specified by <var>tplp</var>
is an element of the table specified by <var>tbp</var>.

<h3>Return value</h3>

<p>If the tuple is an element of the table, RDB_OK is returned.
If the tuple is not an element of the table, RDB_NOT_FOUND is returned.
On failure, an error code different from RDB_NOT_FOUND returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_INVALID_ARGUMENT
<dd>A table attribute is missing in the tuple.
<dt>RDB_TYPE_MISMATCH
<dd>The type of a tuple attribute does not match the type of the
corresponding table attribute.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="aggregate">RDB_aggregate</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_aggregate(RDB_table *, <a href="#aggregate_op">RDB_aggregate_op</a> op, const char *attrname,
              RDB_transaction *, RDB_object *resultp);
</pre>

<h3>Description</h3>

<p>RDB_aggregate computes an aggregation function over the attribute
<var>attrname</var> of a table and stores the result at the location
pointed to by <var>resultp</var>. Valid vakues for <var>op</var> are
RDB_COUNT, RDB_SUM, RDB_AVG, RDB_MAX, RDB_MIN, RDB_ALL, and RDB_ANY.

<p>If <var>op</var> is RDB_COUNT, the attribute <var>attrname</var> is ignored.

<p>If <var>op</var> is RDB_SUM, RDB_MIN, or RDB_MAX,
the attribute <var>attrname</var> must be numeric
and the result is of the same type as the attribute.

<p>If <var>op</var> is RDB_AVG,
the attribute <var>attrname</var> must be numeric
and the result is of type RATIONAL.

<p>If <var>op</var> is RDB_ALL or RDB_ANY, 
the attribute <var>attrname</var> must be of
type BOOLEAN anf the result is of type BOOLEAN.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_INVALID_ARGUMENT
<dd><var>op</var> contains an invalid value.
<dd><var>attrname</var> is NULL and op is not RDB_COUNT.
<dd>The table does not have an attribute <var>attrname</var>.
<dt>RDB_TYPE_MISMATCH
<dd>The type of a the attribute does not match the aggregate operation
specified by <var>op</var>.
<dt>RDB_AGGREGATE_UNDEFINED
<dd><var>op</var> is RDB_AVG and the table is empty.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="table_is_empty">RDB_table_is_empty</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_table_is_empty(RDB_table *tbp, RDB_transaction *txp, RDB_bool *resultp);
</pre>

<h3>Description</h3>

<p>RDB_table_is_empty checks if the table specified by <var>tbp</var>
is empty and stores the result of
the check at the location pointed to by <var>resultp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="insert">RDB_insert</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_insert(RDB_table *tbp, const RDB_tuple *tplp, RDB_transaction *);
</pre>

<h3>Description</h3>

<p>RDB_insert inserts the tuple specified by <var>tplp</var>
into the table specified by <var>tbp</var>.
 
<h3>Return value</h3>

<p>If the insert was successful and the tuple was not already
an element of the table, RDB_OK is returned.
If the tuple was already an element of the table,
RDB_ELEMENT_EXISTS is returned.
On failure, an error code different from RDB_ELEMENT_EXISTS is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_INVALID_ARGUMENT
<dd>A table attribute is missing in the tuple and no default value
was specified for that attribute.
<dt>RDB_KEY_VIOLATION
<dd>Inserting the tuple would result in a table which contains
a key value twice.
<dt>RDB_PREDICATE_VIOLATION
<dd>Inserting the tuple would result in a table which violates its
predicate.
<dt>RDB_TYPE_MISMATCH
<dd>The type of a tuple attribute does not match the type of the
corresponding table attribute.
<dt>RDB_NOT_SUPPORTED
<dd>The combination of arguments is not supported by the version
of Duro used. Consult the release notes of that version for details.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="update">RDB_update</h2>

<pre>
#include &lt;rel/rdb.h&gt;

typedef struct {
    char *name;
    RDB_expression *exp;
} RDB_attr_update;

int
RDB_update(RDB_table *tbp, RDB_expression *exp, int updc,
        const RDB_attr_update updv[], RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_update updates all tuples from the table specified by <var>tbp</var>
for which the expression specified by <var>exp</var> evaluates to true.
If <var>exp</var> is NULL, all tuples are updated.

<p>The attributes to be updated are specified by the <var>updv</var> array.
The attribute specified by the field name is set to the value
obtained by evaluating the expression specified by the field exp.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.

<dt>RDB_INVALID_ARGUMENT
<dd>One of the attributes in <var>updv</var> does not exist in the table.
<dd>One of the expressions specified in <var>updv</var> refers to an attribute
which does not exist in the table.

<dt>RDB_KEY_VIOLATION
<dd>The update operation would result in a table which contains
a key value twice.

<dt>RDB_PREDICATE_VIOLATION
<dd>The update operation would result in a table which violates its
predicate.

<dt>RDB_TYPE_MISMATCH
<dd>The type of one the expressions in <var>attrv</var> is not the same
as the type of the corresponding table attribute.

<dt>RDB_NOT_SUPPORTED
<dd>RDB_update is not supported for this type of table in this version of
Duro.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="delete">RDB_delete</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_delete(RDB_table *tbp, RDB_expression *exp, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_delete deletes all tuples from the table specified by <var>tbp</var>
for which the expression specified by <var>exp</var> evaluates to true.
If <var>exp</var> is NULL, all tuples are deleted.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_INVALID_ARGUMENT
<dd><var>exp</var> refers to an attribute which does not exist in the table.
<dt>RDB_NOT_SUPPORTED
<dd>RDB_delete is not supported for this type of table in this version of
Duro.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="extract_tuple">RDB_extract_tuple</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_extract_tuple(RDB_table *, RDB_tuple *tplp, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_extract_tuple extracts a single tuple from a table which contains
only one tuple and stores its value at the location pointed to by
<var>tplp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned
and the value of <var>tplp</var> is undefined.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_NOT_FOUND
<dd>The table is empty.
<dt>RDB_INVALID_ARGUMENT
<dd>The table contains more than one tuple.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="copy_table">RDB_copy_table</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_copy_table(RDB_table *dstp, RDB_table *srcp, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_copy_table copies all tuples from the table specified
by <var>srcp</var> to the table specified by <var>dstp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_TYPE_MISMATCH
<dd>The types of the two tables differ.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="rename">RDB_rename</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_rename(RDB_table *tbp, int renc, <a href="#renaming">RDB_renaming</a> renv[],
           RDB_table **resultpp);
</pre>

<h3>Description</h3>

<p>RDB_rename creates a virtual table which is the result of a relational
RENAME operation on the table specified by <var>tbp</var>.
A pointer to the result table is stored at the location pointed to by
<var>resultpp</var>.

<p>The attributes to be renamed are specified by the arguments
<var>renc</var> and <var>renv</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<p>The call may fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="select">RDB_select</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_select(RDB_table *tbp, RDB_expression *exp, RDB_table **resultpp);
</pre>

<h3>Description</h3>

<p>RDB_select creates a transient virtual table which contains those
tuples from the table specified by <var>tbp</var> for which the
condition specified by <var>exp</var> evaluates to true.
A pointer to the result table is stored at the location pointed to by
<var>resultpp</var>

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<p>A pointer to the result table is stored at the location pointed to by
<var>resultpp</var>

<hr>

<h2 id="extend">RDB_extend</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_extend(RDB_table *, int attrc, <a href="#virtual_attr">RDB_virtual_attr</a> attrv[],
        RDB_table **resultpp);
</pre>

<h3>Description</h3>

<p>RDB_rename creates a transient virtual table which is the result of a relational
EXTEND operation on the table specified by <var>tbp</var>.

<p>The new table will have <var>attrc</var> additional attributes.
The values of these attributes are obtained by evaluating the
exp fields of the elements of <var>attrv</var>.

<p>If the operation is successful, the new table takes responsibility
for the expressions in <var>attrv</var>. These expressions are
automatically dropped if the table is dropped.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_ARGUMENT
<dd>An invalid attribute name has been specified.
</dl>

<hr>

<h2 id="project">RDB_project</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_project(RDB_table *, int attrc, char *attrv[], RDB_table **resultpp);
</pre>

<h3>Description</h3>

<p>RDB_project creates a relational projection over the table specified
by <var>tbp</var>.

<p>The attributes of the new table are specified by <var>attrc</var>
and <var>attrv</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_ARGUMENT
<dd>One of the attributes specified by <var>attrv</var> is not an attribute
of the original table.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="join">RDB_join</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_join(RDB_table *tb1p, RDB_table *tb2p, RDB_table **resultpp);
</pre>

<h3>Description</h3>

<p>RDB_join creates a transient virtual table which is a natural join
of the two tables specified by <var>tb1p</var> and <var>tb2p</var>.

<p>If the two tables have no common attribute, the result becomes
a cartesian product.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_TYPE_MISMATCH
<dd>The two tables have an attribute with the same name, but with
different types.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="union">RDB_union</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_union(RDB_table *, RDB_table *, RDB_table **resultpp);
</pre>

<h3>Description</h3>

<p>RDB_union creates a transient virtual table which is the
result of a relational UNION of the two tables, that is,
it contains the tuples from both tables. A pointer to the
new RDB_table is stored in <var>resultpp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_TYPE_MISMATCH
<dd>The types of the two tables differ.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="intersect">RDB_intersect</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_intersect(RDB_table *, RDB_table *, RDB_table **resultpp);
</pre>

<h3>Description</h3>

<p>RDB_intersect creates a transient virtual table which is the
result of a relational INTERSECT of the two tables, that is,
it contains the tuples which both tables contain.

<h3>Errors</h3>

<dl>
<dt>RDB_TYPE_MISMATCH
<dd>The types of the two tables differ.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="minus">RDB_minus</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_minus(RDB_table *, RDB_table *, RDB_table **resultpp);
</pre>

<h3>Description</h3>

<p>RDB_intersect creates a transient virtual table which is the
result of a relational MINUS of the two tables, that is,
it contains the tuples which the first table contains,
but the second table does not contain.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_TYPE_MISMATCH
<dd>The types of the two tables differ.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="divide">RDB_sdivide</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_sdivide(RDB_table *, RDB_table *, RDB_table *, RDB_table **resultpp);
</pre>

<h3>Description</h3>

<p>RDB_creates a transient virtual table which is the
result of a small divide of the three tables.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<hr>

<h2 id="gdivide">RDB_gdivide</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_gdivide(RDB_table *, RDB_table *, RDB_table *, RDB_table *,
           RDB_table **resultpp);
</pre>

<h3>Description</h3>

<p>RDB_creates a transient virtual table which is the
result of a great divide of the three tables

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<hr>

<h2 id="summarize">RDB_summarize</h2>

<pre>
#include &lt;rel/rdb.h&gt;

typedef struct {
    <a href="#aggregate_op">RDB_aggregate_op</a> op;
    RDB_expression *exp;
    char *name;
} RDB_summarize_add;

int
RDB_summarize(RDB_table *tb1p, RDB_table *tb2p, int addc, RDB_summarize_add addv[],
              RDB_table **resultpp);
</pre>

<h3>Description</h3>

<p>RDB_summarize creates a transient virtual table which is the result
of a SUMMARIZE T1 PER T2 (ADD1, ...), where T1 is the table specified by
<var>tb1p</var>, T2 is the table specified by <var>tb2p</var>, and ADD1 ...
is specified by <var>addc</var> and <var>addv</var>.
A pointer to the result table is stored in resultpp.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_NOT_SUPPORTED
<dd>The combination of arguments is not supported by the version
of Duro used. Consult the release notes of that version for details.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="wrap">RDB_wrap</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_wrap(RDB_table *tbp, int wrapc, <a href="#wrapping">RDB_wrapping</a> wrapv[],
         RDB_table **resultpp);
</pre>

<h3>Description</h3>

<p>RDB_wrap creates a transient virtual tabel which is the result of a
relational WRAP operation.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<hr>

<h2 id="unwrap">RDB_unwrap</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_unwrap(RDB_table *, int attrc, const char *attrv[], RDB_table **);
</pre>

<h3>Description</h3>

<p>RDB_wrap creates a transient virtual table which is the result of a
relational UNWRAP operation.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<hr>

<h2 id="group">RDB_group</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_group(RDB_table *, int attrc, char *attrv[], const char *,
         RDB_table **resultpp);
</pre>

<h3>Description</h3>

<p>RDB_group creates a transient virtual table which is the result of a
relational GROUP operation.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<hr>

<h2 id="ungroup">RDB_ungroup</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_ungroup(RDB_table *, const char *, RDB_table **resultpp);
</pre>

<h3>Description</h3>

<p>RDB_wrap creates a transient virtual tabel which is the result of a
relational UNGROUP operation.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<hr>

<h2 id="destroy_tuple">RDB_destroy_tuple</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_destroy_tuple(RDB_tuple *);
</pre>

<h3>Description</h3>

<p>RDB_destroy_tuple frees all resources associated with a RDB_tuple
variable.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h2 id="init_tuple">RDB_init_tuple</h2>

<pre>
#include &lt;rel/rdb.h&gt;

void
RDB_init_tuple(RDB_tuple *);
</pre>

<h3>Description</h3>

<p>RDB_init_tuple initializes the tuple variable pointed to by
<var>tplp</var>. RDB_init_tuple must be called before any other
operation can be performed on a RDB_tuple variable.

<h3>Return value</h3>

<p>None.

<hr>

<h2 id="join_tuples">RDB_join_tuples</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_join_tuples(const RDB_tuple *tpl1p, const RDB_tuple *tpl2p, RDB_tuple **resultpp);
</pre>

<h3>Description</h3>

<p>RDB_join creates a tuple which contains the attributes
of the two tuples specified by <var>tpl1p</var> and <var>tpl2p</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_TYPE_MISMATCH
<dd>The two tuples have an attribute with the same name, but with
different types.
<dt>RDB_INVALID_ARGUMENT
<dd>The two tuples have an attribute with the same name, but with
different values.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="project_tuple">RDB_project_tuple</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_project_tuple(const RDB_tuple *, int attrc, char *attrv[], RDB_tuple **resultpp);
</pre>

<h3>Description</h3>

<p>RDB_project_tuple creates a tuple which contains only the attributes
specified by <var>attrc</var> and <var>attrv</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_ARGUMENT
<dd>One of the attributes specified by <var>attrv</var> is not an attribute
of the original tuple.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="tuple_set">RDB_tuple_set</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_tuple_set(RDB_tuple *tplp, const char *name, const RDB_object *valp);
</pre>

<h3>Description</h3>

<p>RDB_tuple_set sets the attribute <var>name</var> of the tuple
variable specified by <var>tplp</var> to the value specified by
<var>valp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<p>The call may fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="tuple_set_bool">RDB_tuple_set_bool</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_tuple_set_bool(RDB_tuple *tplp, const char *name, RDB_bool val);
</pre>

<h3>Description</h3>

<p>RDB_tuple_set_bool sets the attribute <var>name</var> of the tuple
variable specified by <var>tplp</var> to the boolean value specified by
<var>val</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<p>The call may fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="tuple_set_int">RDB_tuple_set_int</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_tuple_set_int(RDB_tuple *tplp, const char *name, RDB_int val);
</pre>

<h3>Description</h3>

<p>RDB_tuple_set_int sets the attribute <var>name</var> of the tuple
variable specified by <var>tplp</var> to the integer value specified by
<var>val</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<p>The call may fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="tuple_set_rational">RDB_tuple_set_rational</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_tuple_set_rational(RDB_tuple *tplp, const char *name, RDB_rational val);
</pre>

<h3>Description</h3>

<p>RDB_tuple_set_int sets the attribute <var>name</var> of the tuple
variable specified by <var>tplp</var> to the rational value specified by
<var>val</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<p>The call may fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="tuple_set_string">RDB_tuple_set_string</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_tuple_set_string(RDB_tuple *tplp, const char *name, const char *str);
</pre>

<h3>Description</h3>

<p>RDB_tuple_set_int sets the attribute <var>name</var> of the tuple
variable specified by <var>tplp</var> to the string value specified by
<var>str</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<p>The call may fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="tuple_get">RDB_tuple_get</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_object *
RDB_tuple_get(const RDB_tuple *, const char *name);
</pre>

<h3>Description</h3>

<p>RDB_tuple_get returns a pointer to a RDB_object structure
which contains the value for attribute <var>name</var>.
The value is not copied.

<h3>Return value</h3>

<p>A pointer to the value of the attribute, or NULL if no
attribute with that name exists.

<hr>

<h2 id="tuple_get_bool">RDB_tuple_get_bool</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_bool
RDB_tuple_get_bool(const RDB_tuple *, const char *name);
</pre>

<h3>Description</h3>

<p>RDB_tuple_get_bool returns the value of attribute <var>name</var>
as a RDB_bool. The attribute must exist and it must be of
type BOOLEAN.

<h3>Return value</h3>

<p>The attribute value.

<hr>

<h2 id="tuple_get_int">RDB_tuple_get_int</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_int
RDB_tuple_get_int(const RDB_tuple *, const char *name);
</pre>

<h3>Description</h3>

<p>RDB_tuple_get_int returns the value of attribute <var>name</var>
as a RDB_int. The attribute must exist and it must be of
type INTEGER.

<h3>Return value</h3>

<p>The attribute value.

<hr>

<h2 id="tuple_get_rational">RDB_tuple_get_rational</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_rational
RDB_tuple_get_rational(const RDB_tuple *, const char *name);
</pre>

<h3>Description</h3>

<p>RDB_tuple_get_rational returns the value of attribute <var>name</var>
as a RDB_rational. The attribute must exist and it must be of
type RATIONAL.

<h3>Return value</h3>

<p>The attribute value.

<hr>

<h2 id="tuple_get_string">RDB_tuple_get_string</h2>

<pre>
#include &lt;rel/rdb.h&gt;

char *
RDB_tuple_get_string(const RDB_tuple *, const char *name);
</pre>

<h3>Description</h3>

<p>RDB_tuple_get_string returns a pointer to the value of attribute
<var>name</var>. The attribute must exist and it must be of
type STRING.

<h3>Return value</h3>

<p>A pointer to the attribute value.

<hr>

<h2 id="extend_tuple">RDB_extend_tuple</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_extend_tuple(RDB_tuple *, int attrc, <a href="#virtual_attr">RDB_virtual_attr</a> attrv[],
                 RDB_transaction *);
</pre>

<h3>Description</h3>

<p>RDB_extend_tuple extends the tuple by the attributes specified by
<var>attrc</var> and <var>attrv</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_ARGUMENT
<dd>One of the expressions specified in <var>updv</var> refers to an attribute
which does not exist in the table.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="rename_tuple">RDB_rename_tuple</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_rename_tuple(const RDB_tuple *, int renc, <a href="#renaming">RDB_renaming</a> renv[],
                 RDB_tuple *restplp);
</pre>

<h3>Description</h3>

<p>RDB_rename_tuple creates copies the tuple specified by <var>tplp</var>
to the tuple specified by <var>restplp</var>, renaming the attributes
specified by <var>renc</var> and <var>renv</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<p>The call may fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="wrap_tuple">RDB_wrap_tuple</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_wrap_tuple(const RDB_tuple *tplp, int wrapc, <a href="#wrapping">RDB_wrapping</a> wrapv[],
               RDB_tuple *restplp);
</pre>

<h3>Description</h3>

<p>RDB_wrap_tuple performs a tuple WRAP operation on the tuple pointed to by
<var>tplp</var> and stores the result in the variable pointed to by
<var>restplp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<hr>

<h2 id="unwrap_tuple">RDB_unwrap_tuple</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_unwrap_tuple(const RDB_tuple *tplp, int attrc, const char *attrv[],
        RDB_tuple *restplp);
</pre>

<h3>Description</h3>

<p>RDB_unwrap_tuple performs a tuple UNWRAP operation on the tuple pointed to by
<var>tplp</var> and stores the result in the variable pointed to by
<var>restplp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<hr>

<h2 id="init_obj">RDB_init_obj</h2>

<pre>
#include &lt;rel/rdb.h&gt;

void
RDB_init_obj(RDB_object *valp);
</pre>

<h3>Description</h3>

<p>RDB_init_obj initializes the variable pointed to by
<var>valp</var>. RDB_init_obj must be called before any other
operation can be performed on a RDB_object variable.

<hr>

<h2 id="destroy_obj">RDB_destroy_obj</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_destroy_obj(RDB_object *valp);
</pre>

<h3>Description</h3>

<p>RDB_destroy_obj frees all resources associated with a RDB_obj
variable.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<hr>

<h2 id="obj_equals">RDB_obj_equals</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_bool
RDB_obj_equals(const RDB_object *, const RDB_object *);
</pre>

<h3>Description</h3>

<p>RDB_obj_equals checks two RDB_object variables for equality.

<h3>Return value</h3>

<p>If the value of the two variables are equal, RDB_obje_equals returns RDB_TRUE,
othwerwise RDB_FALSE.

<hr>

<h2 id="copy_obj">RDB_copy_obj</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_copy_obj(RDB_object *dstvalp, const RDB_object *srcvalp);
</pre>

<h3>Description</h3>

<p>RDB_copy_obj copies the value of the RDB_object pointed to
by <var>srcp</var> to the RDB_object pointed to by <var>dstp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<p>The call may fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="select_obj">RDB_select_obj</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_select_obj(RDB_object *valp, RDB_type *typ, const char *repname,
              RDB_object *compv[]);
</pre>

<h3>Description</h3>

<p>RDB_select_obj invokes the selector operator for the
possible representation <var>repname</var> of the type
specified to by <var>typ</var>. The components of the possible
representation are passed via <var>compv</var>.
The result value is stored in the RDB_object pointed to by
<var>valp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_ARGUMENT
<dd><var>typ</var> is not a scalar, user-defined type.
<dd><var>repname</var> is not the name of a possible representation of
the type specified by <var>typ</var>.
<dt>RDB_TYPE_CONSTRAINT_VIOLATION
<dd>The value specified violates the type constraint for
the type specified by <var>typ</var>.
</dl>

<hr>

<h2 id="obj_set_bool">RDB_obj_set_bool</h2>

<pre>
#include &lt;rel/rdb.h&gt;

void
RDB_obj_set_bool(RDB_object *valp, RDB_bool v);
</pre>

<h3>Description</h3>

<p>RDB_obj_set_bool sets the RDB_object pointed to by <var>valp</var>
to the boolean value specified by <var>v</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<hr>

<h2 id="obj_set_int">RDB_obj_set_int</h2>

<pre>
#include &lt;rel/rdb.h&gt;

void
RDB_obj_set_int(RDB_object *valp, RDB_int v);
</pre>

<h3>Description</h3>

<p>RDB_obj_set_bool sets the RDB_object pointed to by <var>valp</var>
to the integer value specified by <var>v</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<hr>

<h2 id="obj_set_rational">RDB_obj_set_rational</h2>

<pre>
#include &lt;rel/rdb.h&gt;

void
RDB_obj_set_rational(RDB_object *valp, RDB_rational v);
</pre>

<h3>Description</h3>

<p>RDB_obj_set_bool sets the RDB_object pointed to by <var>valp</var>
to the rational value specified by <var>v</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<hr>

<h2 id="obj_set_string">RDB_obj_set_string</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_obj_set_string(RDB_object *valp, const char *str);
</pre>

<h3>Description</h3>

<p>RDB_obj_set_string sets the RDB_object pointed to by <var>valp</var>
to the string value specified by <var>str</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<hr>

<h2 id="obj_set_tuple">RDB_obj_set_tuple</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_obj_set_tuple(RDB_object *valp, const RDB_tuple *tplp);
</pre>

<h3>Description</h3>

<p>RDB_obj_set_tuple sets the RDB_object pointed to by <var>valp</var>
to the tuple value specified by <var>tplp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<hr>

<h2 id="obj_bool">RDB_obj_bool</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_bool
RDB_obj_bool(const RDB_object *valp);
</pre>

<h3>Description</h3>

<p>RDB_obj_bool returns the value of the RDB_object pointed to by
<var>valp</var> as a RDB_bool. The RDB_object must be of type
BOOLEAN.

<h3>Return value</h3>

<p>The value of the RDB_object.

<hr>

<h2 id="obj_int">RDB_obj_int</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_int
RDB_obj_int(const RDB_object *valp);
</pre>

<h3>Description</h3>

<p>RDB_obj_int returns the value of the RDB_object pointed to by
<var>valp</var> as a RDB_int. The RDB_object must be of type
INTEGER.

<h3>Return value</h3>

<p>The value of the RDB_object.

<hr>

<h2 id="obj_rational">RDB_obj_rational</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_rational
RDB_obj_rational(const RDB_object *valp);
</pre>

<h3>Description</h3>

<p>RDB_obj_rational returns the value of the RDB_object pointed to by
<var>valp</var> as a RDB_rational. The RDB_object must be of type
RATIONAL.

<h3>Return value</h3>

<p>The value of the RDB_object.

<hr>

<h2 id="obj_string">RDB_obj_string</h2>

<pre>
#include &lt;rel/rdb.h&gt;

char *
RDB_obj_string(RDB_object *valp);
</pre>

<h3>Description</h3>

<p>RDB_obj_string returns a pointer to the value of the RDB_object pointed to by
<var>valp</var> as a char *. The RDB_object must be of type STRING.

<h3>Return value</h3>

<p>The string value of the RDB_object.

<hr>

<h2 id="obj_tuple">RDB_obj_tuple</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_tuple *
RDB_obj_tuple(RDB_object *valp);
</pre>

<h3>Description</h3>

<p>RDB_obj_tuple returns a pointer to RDB_tuple variable
represented by the RDB_object pointed to by <var>valp</var>.
The RDB_object must be of a tuple type.

<h3>Return value</h3>

<p>A pointer to the RDB_tuple.

<hr>

<h2 id="obj_comp">RDB_obj_comp</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_obj_comp(const RDB_object *valp, const char *compname,
             RDB_object *comp);
</pre>

<h3>Description</h3>

<p>RDB_obj_comp copies the value of component <var>compname</var>
of a possible representation of the variable pointed to by <var>valp</var>
to the variable pointed to by <var>comp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_ARGUMENT
<dd>The type of the variable pointed to by <var>valp</var> ist not
a scalar user-defined type.
</dl>

<p>RDB_obj_comp may also return an error code returned by a
user-provided getter function.

<p>The call may also fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="obj_set_comp">RDB_obj_set_comp</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_obj_set_comp(RDB_object *valp, const char *compname,
                 const RDB_object *comp);
</pre>

<h3>Description</h3>

<p>RDB_obj_set_comp sets the the value of component <var>compname</var>
of a possible representation of the variable pointed to by <var>valp</var>
to the value of the riable pointed to by <var>comp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<hr>

<h2 id="binary_set">RDB_binary_set</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_binary_set(RDB_object *, size_t pos, const void *srcp, size_t len);
</pre>

<h3>Description</h3>

<p>RDB_binary_set copies <var>len</var> bytes from srcp to
the position <var>pos</var> in the RDB_object pointed to by <var>valp</var>.
<var>valp</var> must point to a RDB_object of type BINARY.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<p>The call may fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="binary_get">RDB_binary_get</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_binary_get(const RDB_object *valp, size_t pos, void *dstp, size_t len);
</pre>

<h3>Description</h3>

<p>RDB_binary_get copies <var>len</var> bytes starting at position
<var>pos</var> from the RDB_object pointed to by <var>valp</var>
to <var>dstp</var>. <var>valp</var> must point to a RDB_object of
type BINARY.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<p>The call may fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="binary_length">RDB_binary_length</h2>

<pre>
#include &lt;rel/rdb.h&gt;

size_t
RDB_binary_length(const RDB_object *valp);
</pre>

<h3>Description</h3>

<p>RDB_binary_length determines the number of bytes stored in the
RDB_object pointed to by <var>valp</var>. The RDB_object
must be of type BINARY.

<h3>Return value</h3>

<p>The length of the RDB_object.

<hr>

<h2 id="create_db_from_env">RDB_create_db_from_env</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_create_db_from_env(const char *name, RDB_environment *envp, RDB_database **dbpp);
</pre>

<h3>Description</h3>

<p>RDB_create_db_from_env creates a database from a database environment.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<hr>

<h2 id="get_db_from_env">RDB_get_db_from_env</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_get_db_from_env(const char *name, RDB_environment *envp, RDB_database **dbpp);
</pre>

<h3>Description</h3>

<p>RDB_get_db_from_env obtains a pointer to the database with name
<var>name</var> in the environment specified by <var>envp</var>
and stores this pointer at the location pointed to by <var>dbpp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<hr>

<h2 id="release_db">RDB_release_db</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_release_db(RDB_database *dbp);
</pre>

<h3>Description</h3>

<p>RDB_release_db informs the system that the pointer <var>dbp</var>
is no longer used. If the use count for the database drops to zero,
the RDB_database structure is freed.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<hr>

<h2 id="drop_db">RDB_drop_db</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_drop_db(RDB_database *dbp);
</pre>

<h3>Description</h3>

<p>RDB_drop_db deletes the database specified by <var>dbp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<hr>

<h2 id="db_name">RDB_db_name</h2>

<pre>
#include &lt;rel/rdb.h&gt;

char *
RDB_db_name(RDB_database *dbp)
</pre>

<h3>Description</h3>

<p>RDB_db_name returns a pointer to the name of the database
specified by <var>dbp</var>.

<h3>Return value</h3>

<p>The name of the database.

<hr>

<h2 id="begin_tx">RDB_begin_tx</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_begin_tx(RDB_transaction *txp, RDB_database *dbp,
        RDB_transaction *parentp);
</pre>

<h3>Description</h3>

<p>RDB_begin_tx starts a transaction which interacts with the
database specified by <var>dbp</var>.

<p>If <var>parentp</var> is not NULL, the new transaction is
a subtransaction of the transaction specified by <var>parentp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<hr>

<h2 id="commit">RDB_commit</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_commit(RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_commit commits the transaction pointed to by <var>txp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="rollback">RDB_rollback</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_rollback(RDB_transaction *);
</pre>

<h3>Description</h3>

<p>RDB_rollback terminates the transaction pointed to by <var>txp</var>
and rolls back all changes made by this transaction and its subtrabsactions.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>.

<hr>

<h2 id="tx_db">RDB_tx_db</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_database *
RDB_tx_db(RDB_transaction *txp)
</pre>

<h3>Description</h3>

<p>RDB_tx_db determines the database with which the transaction pointed
to by <var>txp</var> interacts.

<h3>Return value</h3>

<p>A pointer the RDB_database structure that represents the database.

<hr>

<h2 id="tx_is_running">RDB_tx_is_running</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_bool
RDB_tx_is_running(RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_tx_is_running determines if <var>txp</var> points to a running
transaction.

<h3>Return value</h3>

<p>RDB_TRUE if the transaction is running, RDB_FALSE otherwise.

<hr>

<h2 id="init_array">RDB_init_array</h2>

<pre>
#include &lt;rel/rdb.h&gt;

void
RDB_init_array(RDB_array *);
</pre>

<h3>Description</h3>

<p>RDB_init_array initializes en array variable.
RDB_init_array must be called before any other
operation can be performed on a RDB_array variable.

<hr>

<h2 id="destroy_array">RDB_destroy_array</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_destroy_array(RDB_array *);
</pre>

<h3>Description</h3>

<p>RDB_destroy_array frees all resources associated with a RDB_array
variable.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<hr>

<h2 id="table_to_array">RDB_table_to_array</h2>

<pre>
#include &lt;rel/rdb.h&gt;

typedef struct {
    char *attrname;
    RDB_bool asc;
} RDB_seq_item;

int
RDB_table_to_array(RDB_array *arrp, RDB_table *tbp,
                   int seqitc, RDB_seq_item seqitv[],
                   RDB_transaction *);
</pre>

<h3>Description</h3>

<p>RDB_table_to_array creates an array which contains
all tuples from the table specified by <var>tbp</var>.
If <var>seqitc</var> is zero, the tuples appear in random order.
If <var>seqitc</var> is greater than zero, the order of the tuples
is specified by <var>seqitv</var>.

<h3>Return value</h3>

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="array_get_tuple">RDB_array_get_tuple</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_array_get_tuple(RDB_array *, RDB_int idx, RDB_tuple **tplpp);
</pre>

<h3>Description</h3>

<p>RDB_array_get_tuple stores a pointer to the tuple at index <var>idx</var>
at the location pointed to by <var>tplpp</var>. This pointer may become
invalid after the next invocation of RDB_array_get_tuple.
The pointer will become invalid when the array is destroyed.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<hr>

<h2 id="array_set_tuple">RDB_array_set_tuple</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_array_set_tuple(RDB_array *, RDB_int idx, const RDB_tuple *tplp);
</pre>

<h3>Description</h3>

<p>RDB_array_set_tuple copies the tuple pointed to by tplp
into the RDB_array at index <var>idx</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<hr>

<h2 id="array_length">RDB_array_length</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_int
RDB_array_length(RDB_array *);
</pre>

<h3>Description</h3>

<p>RDB_array_length determines the length of the array.

<h3>Return value</h3>

<p>The length of the array. A return code lower than zero
inicates an error.

<hr>

<h2 id="set_array_length">RDB_set_array_length</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_set_array_length(RDB_array *arrp, int len);
</pre>

<h3>Description</h3>

<p>RDB_set_array_length sets the length of the array specified by
<var>arrp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<hr>

<h2 id="expr_type">RDB_expr_type</h2>

<pre>
RDB_type *
RDB_expr_type(const RDB_expression *);
</pre>

<h3>Description</h3>

<p>RDB_expr_type determines the type of an expression.

<h3>Return value</h3>

<p>The type of the expression.

<hr>

<h2 id="expr_is_const">RDB_expr_is_const</h2>

<pre>
RDB_bool
RDB_expr_is_const(const RDB_expression *);
</pre>

<h3>Description</h3>

<p>RDB_expr_is_const determines if the expression is a constant expression.

<h3>Return value</h3>

<p>RDB_TRUE if the expression is a constant expression, RDB_FALSE otherwise.

<h3>Errors</h3>

<hr>

<h2 id="bool_const">RDB_bool_const</h2>

<pre>
RDB_expression *
RDB_bool_const(RDB_bool);
</pre>

<h3>Description</h3>

<p>RDB_bool_const creates a constant expression of type BOOLEAN.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="int_const">RDB_int_const</h2>

<pre>
RDB_expression *
RDB_int_const(RDB_int);
</pre>

<h3>Description</h3>

<p>RDB_int_const creates a constant expression of type INTEGER.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="rational_const">RDB_rational_const</h2>

<pre>
RDB_expression *
RDB_rational_const(RDB_rational);
</pre>

<h3>Description</h3>

<p>RDB_rational_const creates a constant expression of type RATIONAL.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="string_const">RDB_string_const</h2>

<pre>
RDB_expression *
RDB_string_const(const char *);
</pre>

<h3>Description</h3>

<p>RDB_string_const creates a constant expression of type STRING.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="obj_const">RDB_obj_const</h2>

<pre>
RDB_expression *
RDB_obj_const(const RDB_object *valp);
</pre>

<h3>Description</h3>

<p>RDB_obj_const creates a constant expression from a RDB_object.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="expr_attr">RDB_expr_attr</h2>

<pre>
RDB_expression *
RDB_expr_attr(const char *attrname, RDB_type *);
</pre>

<h3>Description</h3>

<p>RDB_expr_attr creates an expression that represents an attribute.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="eq">RDB_eq</h2>

<pre>
RDB_expression *
RDB_eq(RDB_expression *, RDB_expression *);
</pre>

<h3>Description</h3>

<p>RDB_eq creates an expression that represents an "is equal" operator.
If one of the arguments is NULL, NULL is returned.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="neq">RDB_neq</h2>

<pre>
RDB_expression *
RDB_neq(RDB_expression *, RDB_expression *);
</pre>

<h3>Description</h3>

<p>RDB_neq creates an expression that represents an "is not equal" operator.
If one of the arguments is NULL, NULL is returned.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="lt">RDB_lt</h2>

<pre>
RDB_expression *
RDB_lt(RDB_expression *, RDB_expression *);
</pre>

<h3>Description</h3>

<p>RDB_lt creates an expression that represents a "lower than" operator.
If one of the arguments is NULL, NULL is returned.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="gt">RDB_gt</h2>

<pre>
RDB_expression *
RDB_gt(RDB_expression *, RDB_expression *);
</pre>

<h3>Description</h3>

<p>RDB_gt creates an expression that represents a "greater than" operator.
If one of the arguments is NULL, NULL is returned.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="let">RDB_let</h2>

<pre>
RDB_expression *
RDB_let(RDB_expression *, RDB_expression *);
</pre>

<h3>Description</h3>

<p>RDB_let creates an expression that represents a "lower or equal than" operator.
If one of the arguments is NULL, NULL is returned.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="get">RDB_get</h2>

<pre>
RDB_expression *
RDB_get(RDB_expression *, RDB_expression *);
</pre>

<h3>Description</h3>

<p>RDB_get creates an expression that represents a "greater or equal than" operator.
If one of the arguments is NULL, NULL is returned.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="and">RDB_and</h2>

<pre>
RDB_expression *
RDB_and(RDB_expression *, RDB_expression *);
</pre>

<h3>Description</h3>

<p>RDB_and creates an expression that represents a logical AND.
If one of the arguments is NULL, NULL is returned.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="or">RDB_or</h2>

<pre>
RDB_expression *
RDB_or(RDB_expression *, RDB_expression *);
</pre>

<h3>Description</h3>

<p>RDB_or creates an expression that represents a logical OR.
If one of the arguments is NULL, NULL is returned.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="not">RDB_not</h2>

<pre>
RDB_expression *
RDB_not(RDB_expression *);
</pre>

<h3>Description</h3>

<p>RDB_or creates an expression that represents a logical NOT.
If the argument is NULL, NULL is returned.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="add">RDB_add</h2>

<pre>
RDB_expression *
RDB_add(RDB_expression *, RDB_expression *);
</pre>

<h3>Description</h3>

<p>RDB_add creates an expression that represents an arithmetical addition.
Both arguments must be numeric and of the same type.
If one of the arguments is NULL, NULL is returned.


<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="subtract">RDB_subtract</h2>

<pre>
RDB_expression *
RDB_subtract(RDB_expression *, RDB_expression *);
</pre>

<h3>Description</h3>

<p>RDB_subtract creates an expression that represents an arithmetical
subtraction. Both arguments must be numeric and of the same type.
If one of the arguments is NULL, NULL is returned.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="strlen">RDB_strlen</h2>

<pre>
RDB_expression *
RDB_strlen(RDB_expression *arg);
</pre>

<h3>Description</h3>

<p>RDB_subtract creates an expression that represents a string length
operation. If the argument is NULL, NULL is returned.


<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="regmatch">RDB_regmatch</h2>

<pre>
RDB_expression *
RDB_regmatch(RDB_expression *arg1p, RDB_expression *arg2p);
</pre>

<h3>Description</h3>

<p>RDB_regmatch creates an expression that represents a regular
expression match. Both subexpressions must be of type STRING.
The expression evaluates to RDB_TRUE if the expression represented by arg1p
evaluates to a string that matches the regular expression
to which the expression represented by arg2p evaluates.
If one of the arguments is NULL, NULL is returned.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="expr_table">RDB_expr_table</h2>

<pre>
RDB_expression *
RDB_expr_table(RDB_table *);
</pre>

<h3>Description</h3>

<p>RDB_expr_table creates an expression that represents a table.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="expr_is_empty">RDB_expr_is_empty</h2>

<pre>
RDB_expression *
RDB_expr_is_empty(RDB_expression *);
</pre>

<h3>Description</h3>

<p>RDB_expr_is_empty creates an expression which evaluates to RDB_TRUE
if the subexpression evaluates to an empty table.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="expr_aggregate">RDB_expr_aggregate</h2>

<pre>
RDB_expression *
RDB_expr_aggregate(RDB_expression *, RDB_aggregate_op op, const char *attrname);
</pre>

<h3>Description</h3>

<p>RDB_expr_aggregate creates an expression which represents an aggregation
operation (See <a href="#aggregate">RDB_aggregate</a>).

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="expr_comp">RDB_expr_comp</h2>

<pre>
RDB_expression *
RDB_expr_comp(RDB_expression *arg, const char *compname);
</pre>

<h3>Description</h3>

<p>RDB_expr_comp creates an expression which evaluates to a
possible representation component.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="selector">RDB_selector</h2>

<pre>
RDB_expression *
RDB_selector(RDB_type *, const char *repname, RDB_expression *argv[]);
</pre>

<h3>Description</h3>

<p>RDB_selector creates an expression which represents a selector
invocation.

<h3>Return value</h3>

<p>A pointer to the newly created expression, of NULL if the creation
failed.

<hr>

<h2 id="user_op">RDB_user_op</h2>

<pre>
int
RDB_user_op(const char *opname, int argc, RDB_expression *argv[],
       RDB_transaction *txp, RDB_expression **expp);
</pre>

<h3>Description</h3>

<p>RDB_user_op creates an expression which represents a the invocation
of user-defined operator and stores a pointer to the expression
at the location pointed to by <var>expp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_NOT_FOUND
<dd>The user-defined operation was not found.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="drop_expr">RDB_drop_expr</h2>

<pre>
void
RDB_drop_expr(RDB_expression *exp);
</pre>

<h3>Description</h3>

<p>RDB_drop_expr frees the memory pointed to by <var>exprp</var> and calls
RDB_drop_expr on all subexpressions.

<h3>Return value</h3>

<h3>Errors</h3>

<hr>

<h2 id="define_type">RDB_define_type</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_define_type(const char *name, int repc, <a href="#possrep">RDB_possrep</a> repv[],
                RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_define_type defines a type with the name <var>name</var> and
<var>repc</var> possible representations.
The individual possible representations are
described by the elements of <var>repv</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_ELEMENT_EXISTS
<dd>There is altready a type with name <var>name</var>.
<dt>RDB_TYPE_MISMATCH
<dd>The expression pointed to by the field constraintp of one
of the elements of <var>repv</var> is not of type BOOLEAN.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="implement_type">RDB_implement_type</h2>

<pre>
#include &lt;rel/typeimpl.h&gt;

RDB_implement_type(const char *name, const char *libname, RDB_type *arep,
                   int options, size_t areplen, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_implement_type implements the user-defined type with name
<var>name</var>. After RDB_implement_type was inkoved successfully,
this type may be used for local variables and table attributes.
The actual representation is specified by the <var>arep</var> argument.

<p>If <var>libname</var> is not NULL, then:

<p>If <var>arep</var> is not NULL, it must point to a type which is used
as the actual representation.

<p>If <var>arep</var> is NULL, <var>options</var> must be RDB_FIXED_BINARY
and <var>areplen</var> specifies the length, in bytes, of the actual representation,
which is a fixed-length array of bytes.

<p>In either case, <var>libname</var> it is taken as a name of a library
which contains the getter functions, setter functions, and selector
functions for the type. See the release notes for details on how
to create such a library.

<p>If <var>libname</var> is NULL, the getter functions, setter functions, and selector
functions for the type are provided by Duro. In this case,
<var>arep</var> must be NULL, the type may only have one possible representation,
and this representation becomes the actual representation.

<h4>Conventions for user-supplied selector, setter, and getter
functions</h4>

<p>The functions provided in a user-supplied library must obey the following
conventions:

<pre>
int
RDBU_select_&lt;possrep&gt;(RDB_object *valp, RDB_object *compv[],
        RDB_type *, const char *possrepname);
</pre>

<p>where &lt;possrep&gt; is the name of the possible representation in question.

<pre>
int
RDBU_set_&lt;component&gt;(RDB_object *valp, const RDB_object *comp,
        RDB_type *, const char *compname);
</pre>

<pre>
int
RDBU_get_&lt;component&gt;(const RDB_object *src, RDB_object *comp,
        RDB_type *, const char *compname);
</pre>

<p>where &lt;component&gt; is the name of the component in question.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. Any other return value indicates an error.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_INVALID_ARGUMENT
<dd>An invalid combination of <var>libname</var> and <var>arep</var> was
used.
<dt>RDB_NOT_SUPPORTED
<dd>The requested internal representation is not supported by this version
of the library.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="create_tuple_type">RDB_create_tuple_type</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_type *
RDB_create_tuple_type(int attrc, <a href="#attr">RDB_attr</a> attrv[]);
</pre>

<h3>Description</h3>

<p>RDB_create_tuple_type creates a transient tuple type. The attributes
are specified by <var>attrc</var> and <var>attrv</var>.
The fields defaultp and options of RDB_attr are ignored.

<h3>Return value</h3>

<p>A pointer to the newly created type, or NULL if the creation failed.

<hr>

<h2 id="create_relation_type">RDB_create_relation_type</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_type *
RDB_create_relation_type(int attrc, RDB_attr attrv[]);
</pre>

<h3>Description</h3>

<p>RDB_create_relation_type creates a transient relation type. The attributes
are specified by <var>attrc</var> and <var>attrv</var>.

<h3>Return value</h3>

<p>A pointer to the newly created type, or NULL if the creation failed.

<hr>

<h2 id="get_type">RDB_get_type</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_get_type(const char *name, RDB_transaction *, RDB_type **typp);
</pre>

<h3>Description</h3>

<p>RDB_get_type obtains a pointer to RDB_type structure which
represents the type with the name <var>name</var>
and stores that pointer at the location pointed to by <var>typp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. Any other return value indicates an error.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_NOT_FOUND
<dd>A type with the name <var>name</var> could not be found.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="drop_type">RDB_drop_type</h2>

<pre>
#include &lt;rel/rdb.h&gt;

void
RDB_drop_type(RDB_type *typ, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_drop_type destroys the type specified by <var>typ</var>.

<p>If the type is transient, the argument <var>txp</var> is ignored.

<p>It is not possible to destroy built-in types.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. Any other return value indicates an error.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_INVALID_ARGUMENT
<dd>The type is a builtin type.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="type_name">RDB_type_name</h2>

<pre>
#include &lt;rel/rdb.h&gt;

char *
RDB_type_name(const RDB_type *);
</pre>

<h3>Description</h3>

<p>RDB_type_name returns the name of a type.

<h3>Return value</h3>

<p>A pointer to the name of the type or NULL if the type has no name.

<hr>

<h2 id="type_is_scalar">RDB_type_is_scalar</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_bool
RDB_type_is_scalar(const RDB_type *);
</pre>

<h3>Description</h3>

<p>RDB_type_is_scalar checks if a type is scalar.

<h3>Return value</h3>

<p>RDB_TRUE if the type is scalar, RDB_FALSE otherwise.

<hr>

<h2 id="type_is_numeric">RDB_type_is_numeric</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_bool
RDB_type_is_numeric(const RDB_type *);
</pre>

<h3>Description</h3>

<p>RDB_type_is_numeric checks if a type is numeric.

<h3>Return value</h3>

<p>RDB_TRUE if the type is INTEGER or RATIONAL, RDB_FALSE otherwise.

<h3>Return value</h3>

<hr>

<h2 id="type_equals">RDB_type_equals</h2>

<pre>
#include &lt;rel/rdb.h&gt;

RDB_bool
RDB_type_equals(const RDB_type *, const RDB_type *);
</pre>

<h3>Description</h3>

<p>RDB_type_equals checks if two types are equal.

<p>Nonscalar types are equal if there definition is the same.

<h3>Return value</h3>

<p>RDB_TRUE if the types are equal, RDB_FALSE otherwise.

<hr>

<h2 id="create_ro_op">RDB_create_ro_op</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_create_ro_op(const char *name, int argc, RDB_type *argtv[], RDB_type *rtyp,
                 const char *libname, const char *symname,
                 const void *iargp, size_t iarglen, 
                 RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_create_ro_op creates a read-only operator with name <var>name</var>.
The argument types are specified by <var>argc</var> and <var>argtv</var>.

<p>To execute the operator, Duro will execute the function specified by
<var>symname</var> from the library specified by <var>libname</var>.

<p>This function must have the following signature:

<pre>
int
&lt;symname&gt;(const char *name, int argc, RDB_object *argv[],
          const void *iargp, size_t iarglen, RDB_transaction *txp,
          RDB_object *retvalp)
</pre>

<p>When the function is executed, the name of the operator is passed through <var>name</var>
and the arguments are passed through <var>argc</var> and <var>argv</var>.

<p>The function specified by <var>symname</var> must store the result at the
location specified by <var>retvalp</var> and return RDB_OK.
It can indicate an error condition by passing an error code.

<p>If <var>iargp</var> is not NULL, <var>iargp</var> and <var>iarglen</var>
must point to a byte block which is passed to the function specified by
<var>symname</var>. This can be used to pass code to an interpreter function.

<p>Overloading functions is possible.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_ELEMENT_EXISTS
<dd>A read-only operator with this name and signature does already exist.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="create_update_op">RDB_create_update_op</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_create_update_op(const char *name, int argc, RDB_type *argtv[],
                  RDB_bool upd[], const char *libname, const char *symname,
                  const void *iargp, size_t iarglen,
                  RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_create_update_op creates an update operator with name <var>name</var>.
The argument types are specified by <var>argc</var> and <var>argtv</var>.

<p>The argument <var>upd</var> specifies which of the arguments are updated.
If upd[<em>i</em>] is RDB_TRUE, the <em>i</em>th argument is updated.

<p>To execute the operator, Duro will execute the function specified by
<var>symname</var> from the library specified by <var>libname</var>.

<p>This function must have the following signature:

<pre>
int
&lt;symname&gt;(const char *name, int argc, RDB_object *argv[],
        RDB_bool updv[], const void *iargp, size_t iarglen, RDB_transaction *txp)

</pre>

<p>When the function is executed, the name of the operator is passed through <var>name</var>
and the arguments are passed through <var>argc</var> and <var>argv</var>.

<p>On success, the function specified by <var>symname</var> must return RDB_OK.
It can indicate an error condition by passing an error code.

<p>If <var>iargp</var> is not NULL, <var>iargp</var> and <var>iarglen</var>
must point to a byte block which is passed to the function specified by
<var>symname</var>. This can be used to pass code to an interpreter function.

<p>Overloading functions is possible.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_ELEMENT_EXISTS
<dd>An update operator with this name and signature does already exist.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="call_ro_op">RDB_call_ro_op</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_call_ro_op(const char *name, int argc, RDB_object *argv[],
               RDB_object *retvalp, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_call_ro_op invokes the read-only operator with the name <var>name</var>,
passing the arguments in <var>argc</var> and <var>argv</var>.

<p>The result will be stored at the location pointed to by
<var>retvalp</var>. 

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_NOT_FOUND
<dd>A read-only operator that matches the name and arguments could not be
found.
</dl>

<p>If the user-supplied function which implements the function returns an
error code, this code is returned.

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="call_update_op">RDB_call_update_op</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_call_update_op(const char *name, int argc, RDB_object *argv[],
                RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_call_update_op invokes the update operator with the name <var>name</var>,
passing the arguments in <var>argc</var> and <var>argv</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_NOT_FOUND
<dd>An update operator that matches the name and arguments could not be
found.
</dl>

<p>If the user-supplied function which implements the operator returns an
error code, this code is returned.

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="drop_op">RDB_drop_op</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_drop_op(const char *name, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_drop_op deletes the operator with the name <var>name</var>
from the database. This affects all overloaded versions.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_NOT_FOUND
<dd>An operator with the specified name could not be found.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="create_constraint">RDB_create_constraint</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_create_constraint(const char *name, RDB_expression *constrp,
                      RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_create_constraint creates a constraint with the name <var>name</var>
on the database associated with the transaction specified by <var>txp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_TYPE_MISMATCH
<dd>The expression specified by <var>constrp</var> is not of type BOOLEAN.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="drop_constraint">RDB_drop_constraint</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_drop_constraint(const char *name, RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_drop_constraint deletes the constraint with the name <var>name</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_NOT_FOUND
<dd>A constraint with the name <var>name</var> could not be found.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>,
in which case the transaction is implicitly rolled back.

<hr>

<h2 id="begin_uoi">RDB_begin_uoi</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_begin_uio(RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_begin_uio starts a unit of integrity (UOI), which means that
integrity checking is delayed until the of the UOI.
UOIs cannot be nested.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_INVALID_ARGUMENT
<dd>A unit of integrity has already been started.
</dl>

<hr>

<h2 id="end_uoi">RDB_end_uoi</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_end_uio(RDB_transaction *txp);
</pre>

<h3>Description</h3>

<p>RDB_end_uio ends a unit of integrity.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_INVALID_TRANSACTION
<dd><var>txp</var> does not point to a running transaction.
<dt>RDB_INVALID_ARGUMENT
<dd>A unit of integrity has not been started.
<dt>RDB_PREDICATE_VIOLATION
<dd>A violation of a integrity constraint has been detected.
</dl>

<hr>

<h2 id="create_env">RDB_create_env</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_create_env(const char *path, RDB_environment **);
</pre>

<h3>Description</h3>

<p>RDB_create_env creates a database environment from the
system resource <var>path</var>. See the release notes for details.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_RESOURCE_NOT_FOUND
<dd>The resource specified by <var>path</var> could not be found.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>
different from RDB_RESOURCE_NOT_FOUND.

<hr>

<h2 id="open_env">RDB_open_env</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_open_env(const char *path, RDB_environment **envp);
</pre>

<h3>Description</h3>

<p>RDB_open_env opens a database environment identified by the
system resource <var>path</var>.  See the release notes for details.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<dl>
<dt>RDB_RESOURCE_NOT_FOUND
<dd>The resource specified by <var>path</var> could not be found.
</dl>

<p>The call may also fail for a <a href="#syserr">system error</a>
different from RDB_RESOURCE_NOT_FOUND.

<h3>Return value</h3>

<h3>Errors</h3>

<hr>

<h2 id="close_env">RDB_close_env</h2>

<pre>
#include &lt;rel/rdb.h&gt;

int
RDB_close_env(RDB_environment *envp);
</pre>

<h3>Description</h3>

<p>RDB_close_env closes the database environment specified by
<var>envp</var>.

<h3>Return value</h3>

<p>On success, RDB_OK is returned. On failure, an error code is returned.

<h3>Errors</h3>

<p>The call may fail for a <a href="#syserr">system error</a>

<hr>

<h2 id="set_errfile">RDB_set_errfile</h2>

<pre>
#include &lt;rel/rdb.h&gt;

void
RDB_set_errfile(RDB_environment *, FILE *errfile);
</pre>

<h3>Description</h3>

<p>RDB_set_errfile sets a C library FILE * to be used for error messages.

<hr>

<h2 id="attr">RDB_attr</h2>

<pre>
typedef struct {
    char *name;
    RDB_type *typ;
    RDB_object *defaultp;
    int options;
} RDB_attr;
</pre>

<hr>

<h2 id="virtual_attr">RDB_virtual_attr</h2>

<pre>
typedef struct {
    char *name;
    RDB_expression *exp;
} RDB_virtual_attr;
</pre>

<hr>

<h2 id="renaming">RDB_renaming</h2>

<pre>
typedef struct {
    char *from;
    char *to;
} RDB_renaming;
</pre>

<hr>

<h2 id="wrapping">RDB_wrapping</h2>

<pre>
typedef struct {
    int attrc;
    char **attrv;
    char *attrname;
} RDB_wrapping;
</pre>

<hr>

<h2 id="possrep">RDB_possrep</h2>

<pre>
typedef struct {
    char *name;
    int compc;
    RDB_attr *compv;
    RDB_expression *constraintp;
} RDB_possrep;
</pre>

<hr>

<h2 id="aggregate_op">RDB_aggregate_op</h2>

<pre>
typedef enum {
    RDB_COUNT, RDB_SUM, RDB_AVG, RDB_MAX, RDB_MIN, RDB_ALL, RDB_ANY,
    RDB_COUNTD, RDB_SUMD, RDB_AVGD
} RDB_aggregate_op;
</pre>

<hr>

<h2 id="syserr">System errors</h2>

<dl>
<dt>RDB_NO_SPACE
<dd>Insufficient disk space.
<dt>RDB_NO_MEMORY
<dd>Insufficient memory.
<dt>RDB_DEADLOCK
<dd>A deadlock condition occured.
<dt>RDB_INTERNAL
<dd>Internal error.
<dt>RDB_RESOURCE_NOT_FOUND
<dd>A system resource, usually a file, could not be found.
<dt>RDB_SYSTEM_ERROR
<dd>Unspecified system error.
</dl>

</html>