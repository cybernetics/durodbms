#
# SCons build file for DuroDBMS
# See the file COPYING for redistribution information.
#

import os

#
# Basic settings
#

bdbhome = ARGUMENTS.get('bdbhome', '/usr/local/BerkeleyDB.6.1')
with_durotcl = int(ARGUMENTS.get('with_durotcl', 1))

release = '1.0'

env = Environment(ENV = os.environ, tools = ['default', 'textfile'])

java_home = os.getenv('JAVA_HOME', '/usr/lib/jvm/java-7-openjdk-i386')

oshlibsuffix = env['SHLIBSUFFIX']

if env['PLATFORM'] == 'win32':
    default_prefix = 'C:'
    env.Replace(LIBS = ['libdb61', 'ltdl', 'shlwapi'])
    durolibs = ['libdb61', 'ltdl', 'regex', 'shlwapi']
else:
    default_prefix = '/usr/local'
    env.Replace(SHLIBSUFFIX = env['SHLIBSUFFIX'] + '.' + release)
    env.Replace(LIBS = ['db', 'ltdl', 'm'])
    durolibs = ['db', 'ltdl', 'm']

prefix = ARGUMENTS.get('prefix', default_prefix)

installdir = prefix + '/durodbms.' + release

env.Replace(CPPPATH = ['.', bdbhome + '/include', '/usr/include/tcl'])
env.Replace(LIBPATH = ['.', bdbhome + '/lib'])
env.Replace(RPATH = [installdir + '/lib', bdbhome + '/lib'])

if (os.environ.has_key('CFLAGS')):
    env.Replace(CCFLAGS = os.environ['CFLAGS'])

if (os.environ.has_key('LDFLAGS')):
    env.Append(LINKFLAGS = os.environ['LDFLAGS'])

#
# DuroDBMS core library
#

if env.has_key('YACC'):
    CFile('dli/exparse.c', 'dli/exparse.y', YACCFLAGS = '-d')
    CFile('dli/exlex.c', 'dli/exlex.l', LEXFLAGS = '-i')

env.Textfile(target = 'gen/releaseno.c', source = ['char *RDB_release_number = "' + release + '";', ''])

gensrc = ['gen/hashmap.c', 'gen/hashmapit.c',
        'gen/strfns.c', 'gen/strdump.c', 'gen/hashtable.c', 'gen/hashtabit.c',
        'gen/releaseno.c']

objsrc = ['obj/object.c', 'obj/excontext.c', 'obj/type.c',
          'obj/builtintypes.c', 'obj/io.c','obj/expression.c', 'obj/key.c',
          'obj/tuple.c', 'obj/array.c', 'obj/operator.c',
          'obj/builtinscops.c', 'obj/datetimeops.c']

recsrc = ['rec/cursor.c', 'rec/env.c', 'rec/index.c', 'rec/recmap.c', 'rec/sequence.c']

relsrc = ['rel/arrayx.c', 'rel/database.c', 'rel/uoperator.c',
        'rel/expressionx.c', 'rel/evaluate.c', 'rel/exprtype.c', 'rel/tuplex.c',
        'rel/stable.c', 'rel/qresult.c', 'rel/qr_stored.c', 'rel/qr_join.c',
        'rel/qr_tclose.c', 'rel/serialize.c', 'rel/table.c', 'rel/vtable.c',
        'rel/ptable.c', 'rel/aggrf.c', 'rel/update.c', 'rel/insert.c',
        'rel/contains.c', 'rel/transaction.c', 'rel/delete.c',
        'rel/utype.c', 'rel/typeimpl.c', 'rel/builtinops.c',
        'rel/objectx.c', 'rel/catalog.c', 'rel/cat_type.c', 'rel/cat_op.c',
        'rel/optimize.c', 'rel/transform.c',
        'rel/constraint.c', 'rel/assign.c', 'obj/opmap.c',
        'rel/match.c', 'rel/tostr.c',
        'rel/pexpr.c', 'util/www.c']

interpsrc = ['dli/exparse.c', 'dli/exlex.c', 'dli/parse.c', 'dli/parsenode.c',
        'dli/iinterp.c', 'dli/interp_core.c', 'dli/interp_assign.c',
        'dli/interp_eval.c', 'dli/interp_vardef.c', 'dli/ioop.c']

durosrc = gensrc + objsrc + recsrc + relsrc + interpsrc

if env['PLATFORM'] == 'win32':
    libduro = env.SharedLibrary('duro', durosrc + ['duro.def'],
            LIBS = durolibs, CCFLAGS = '/DNO_DLL_IMPORT')
    libjduro = env.SharedLibrary('jduro', ['jduro/jduro.c', 'jduro/probj.c'],
            CPPPATH = env['CPPPATH'] + [java_home + '/include']
                + [java_home + '/include/win32'],
            LIBS = env['LIBS'] + ['duro.lib'],
            )
else:
    libduro = env.SharedLibrary('duro', durosrc,
            LIBS = durolibs)
    # Name of JNI lib gets no version number because System.loadLibrary()
    # does not support it
    libjduro = env.SharedLibrary('jduro', ['jduro/jduro.c', 'jduro/probj.c'],
            CPPPATH = env['CPPPATH'] + [java_home + '/include'],
            LIBS = env['LIBS'] + libduro,
            SHLIBSUFFIX = DefaultEnvironment()["SHLIBSUFFIX"])

jdurolibs = [libjduro, 'jduro.jar']

env.Alias('jni', jdurolibs)

#
# Tcl interface
#

durotclsrc = ['tcl/duro.c', 'tcl/envcmd.c',
        'tcl/txcmd.c', 'tcl/tablecmd.c', 'tcl/dbcmd.c', 'tcl/arraycmd.c',
        'tcl/opcmd.c', 'tcl/exprcmd.c', 'tcl/typecmd.c', 'tcl/indexcmd.c',
        'tcl/insertcmd.c', 'tcl/updatecmd.c', 'tcl/constrcmd.c',
        'tcl/massigncmd.c']

libdurotcllibs = ['duro']

if env['PLATFORM'] == 'win32':
    libdurotcllibs += ['tcl85', 'libdb61']
    libdurotcl = env.SharedLibrary('durotcl', durotclsrc + ['durotcl.def'],
            LIBS = libdurotcllibs)
else:
    libdurotcl = env.SharedLibrary('durotcl', [durotclsrc, libduro])

#
# Interpreter
#

ioop_fcgi_o = env.Object('dli/fcgi_ioop', 'dli/ioop.c',
        CFLAGS=env['CFLAGS'] + ' -DDURO_FCGI')

durodt_o = env.Object('dli/durodt.c')

if env['PLATFORM'] == 'win32':
    durodt = env.Program([durodt_o],
            LIBS = env['LIBS'] + ['duro'])
    fcgi_durodt = env.Program('dli/fcgi_durodt', [durodt_o, ioop_fcgi_o, 'dli/fcgi.c'],
            LIBS = env['LIBS'] + ['duro', 'fcgi'])
else:
    durodt = env.Program([durodt_o],
            LIBS = env['LIBS'] + ['readline', libduro])
    fcgi_durodt = env.Program('dli/fcgi_durodt', [durodt_o, ioop_fcgi_o, 'dli/fcgi.c'],
            LIBS = env['LIBS'] + ['readline', libduro, 'fcgi'])

#
# Java interface
#

env.Java('../jduro/bin', '../jduro/src')

env.Jar('jduro.jar', '../jduro/bin', JARCHDIR='$SOURCE') 

#
# Docs
#

env.Alias('apidocs', 'docs/api/html/index.html')

env.Command('docs/api/html/index.html',
        ['Doxyfile'] + recsrc + objsrc + relsrc + interpsrc + ['obj/type.h']
            + ['rel/rdb.h'] + ['obj/operator.h']
            + ['dli/parse.c', 'dli/ioop.c', 'dli/iinterp.c', 'dli/parse.h'],
        'doxygen')

env.Alias('javadocs', 'docs/javadoc/index.html')

env.Command('docs/javadoc/index.html', Glob('../jduro/src/net/sf/duro/*.java'),
        'javadoc -d docs/javadoc -classpath ../jduro/src net.sf.duro')

#
# Defaults
#

Default(libduro)
Default(durodt)

if with_durotcl:
     Default(libdurotcl)

#
# Tests
#

testenv = env.Clone(RPATH = [bdbhome + '/lib'], SHLIBSUFFIX = oshlibsuffix)

testsrc = Split('tests/tupletest.c tests/maptest.c '
        'tests/prepare.c tests/test_aggregate.c '
        'tests/test_binary.c tests/test_create_view.c '
        'tests/test_defpointtype.c tests/test_deftype.c '
        'tests/test_delete.c tests/test_extend.c '
        'tests/test_union.c tests/test_minus.c '
        'tests/test_intersect.c tests/test_join.c '
        'tests/test_keys.c tests/test_null.c tests/test_relation_op.c '
        'tests/test_pointtable.c tests/test_print_view.c '
        'tests/test_project.c tests/test_ra.c '
        'tests/test_regexp.c tests/test_rename.c tests/test_select.c '
        'tests/test_summarize.c tests/test_update.c tests/test_utypetable.c '
        'tests/test_srupdate.c tests/test_insert.c tests/test_2db.c '
        'tests/test_defop.c tests/test_callop.c '
        'tests/test_print_opview.c tests/test_dropop.c tests/test_lupdate.c '
        'tests/test_assign_where.c tests/test_interp.c')

testlibsrc = ['tests/point.c', 'tests/point.def', 'tests/plus.c',
        'tests/plus.def']

testbins = []
for s in testsrc:
    if env['PLATFORM'] == 'win32':
        testbins.append(testenv.Program(s, LIBS = env['LIBS'] + ['duro']))
    else:
        testbins.append(testenv.Program(s, LIBS = env['LIBS'] + libduro))

if env['PLATFORM'] == 'win32':
    testbins.append(testenv.Program('tests/lstables.c',
            LIBS = env['LIBS'] + ['duro']))
else:
    testbins.append(testenv.Program('tests/lstables.c',
            LIBS = env['LIBS'] + libduro))

if env['PLATFORM'] == 'win32':
    testbins.append(testenv.SharedLibrary(['tests/point.c', 'tests/point.def'],
            LIBS = env['LIBS'] + ['duro']))
else:
    testbins.append(testenv.SharedLibrary(['tests/point.c'], SHLIBPREFIX = ''))

if env['PLATFORM'] == 'win32':
    testbins.append(testenv.SharedLibrary(['tests/plus.c', 'tests/plus.def'],
            LIBS = env['LIBS'] + ['duro']))
else:
    testbins.append(testenv.SharedLibrary(['tests/plus.c'], SHLIBPREFIX = ''))

test_scripts = Split('tests/aggr.test tests/constraints.test tests/convert.test '
        'tests/ctests.test tests/db2.test tests/deedum.test tests/index.test '
        'tests/invtable.test tests/ltables.test tests/massign.test '
        'tests/oindex.test tests/operator.test tests/opt.test '
        'tests/parse.test tests/project.test tests/qqueries.test '
        'tests/rel.test tests/rollback.test tests/rtables.test '
        'tests/sdivide.test tests/string.test tests/subset.test '
        'tests/transform.test tests/tuple.test tests/update.test '
        'tests/utype.test tests/vtables.test '
        'tests/all.tcl tests/testutil.tcl tests/setup.tcl')
durodt_test_scripts = Glob('tests/durodt/*.test') + ['tests/durodt/scalar.td', 'tests/durodt/all.tcl']

test = env.Command('tests/passed', [libduro, libdurotcl, testbins, durodt],
        'tclsh tests/all.tcl -verbose "{pass error}"')

env.Alias('test', test)

env.Alias('testbins', testbins)

#
# Installation
#

gen_hdrs = Split('gen/hashmap.h gen/hashmapit.h gen/hashtable.h '
        'gen/hashtabit.h gen/strfns.h gen/strdump.h gen/types.h '
        'gen/releaseno.h')
rec_hdrs = Split('rec/cursor.h rec/env.h rec/dbdefs.h rec/index.h rec/recmap.h '
                 'rec/sequence.h')
obj_hdrs = Split('obj/object.h obj/excontext.h obj/type.h obj/builtintypes.h '
                'obj/expression.h obj/operator.h obj/opmap.h obj/tuple.h '
                'obj/array.h')
obj_ihdrs = ['obj/io.h', 'obj/key.h', 'obj/objinternal.h', 'obj/builtinscops.h',
             'obj/datetimeops.h']
rel_hdrs = Split('rel/rdb.h rel/typeimpl.h '
                 'rel/optimize.h rel/qresult.h rel/tostr.h ')
rel_ihdrs = Split('rel/catalog.h rel/cat_type.h rel/cat_op.h '
		'rel/delete.h rel/serialize.h '
        'rel/insert.h rel/transform.h rel/internal.h rel/stable.h '
        'rel/update.h rel/qr_stored.h rel/qr_join.h rel/qr_tclose.h '
        'rel/pexpr.h')
dli_hdrs = ['dli/parse.h', 'dli/parsenode.h', 'dli/iinterp.h']
dli_ihdrs = ['dli/exparse.h', 'dli/iinterp.h', 'dli/interp_core.h',
        'dli/interp_assign.h', 'dli/interp_vardef.h',
        'dli/ioop.h', 'dli/fcgi.h']
durotcl_hdrs = ['tcl/duro.h']
testlib_hdrs = ['tests/point.h']

tcltools = ['tcl/duroadmin.tcl', 'tcl/durodump.tcl']

durodocs = ['docs/index.html', 'docs/expressions.html', 'docs/utils.html',
        'docs/migration.html', 'docs/fastcgi.html', 'docs/style.css']

durotcldocs = Split('docs/tcl/index.html docs/tcl/array.html '
        'docs/tcl/begin.html docs/tcl/call.html '
        'docs/tcl/commit.html docs/tcl/db.html docs/tcl/delete.html '
        'docs/tcl/env.html docs/tcl/expr.html docs/tcl/insert.html '
        'docs/tcl/operator.html docs/tcl/ptable.html docs/tcl/rollback.html '
        'docs/tcl/txdb.html docs/tcl/table.html docs/tcl/update.html '
        'docs/tcl/type.html docs/tcl/indexcmd.html docs/tcl/constraint.html '
        'docs/tcl/massign.html docs/tcl/errorCode.html')

env.Alias('install', installdir)

env.Install(installdir + '/include/gen', gen_hdrs)
env.Install(installdir + '/include/rec', rec_hdrs)
env.Install(installdir + '/include/obj', obj_hdrs)
env.Install(installdir + '/include/rel', rel_hdrs)
env.Install(installdir + '/include/dli', dli_hdrs)
env.Install(installdir + '/docs', durodocs)
env.Install(installdir + '/docs/durodt', 'docs/durodt/tut.html')
# 'scons install' does not rebuild api docs
env.Command(installdir + '/docs/api/html', [], Copy("$TARGET", 'docs/api/html'))
env.Command(installdir + '/docs/javadoc', [], Copy("$TARGET", 'docs/javadoc'))
env.Install(installdir + '/bin', durodt)

# Install fcgi_durodt only if it has been built
if os.path.exists(str(fcgi_durodt[0])):
    env.Install(installdir + '/bin', fcgi_durodt)

# Install java libs if they have been built
if os.path.exists(str(libjduro[0])):
    env.Install(installdir + '/lib', jdurolibs)

def mkIndex(env, target, source):
    import os
    open('tmp.tcl', 'w').write('pkg_mkIndex ' + installdir + '/lib ' + libdurotcl[0].path + ' util.tcl')
    os.system('tclsh tmp.tcl')
    os.remove('tmp.tcl')

# Install durotcl only if libdurotcl has been built
if os.path.exists(str(libdurotcl[0])):
    env.Install(installdir + '/bin', tcltools)
    dst_libdurotcl = env.Install(installdir + '/lib', libdurotcl)
    dst_utiltcl = env.Install(installdir + '/lib', 'tcl/util.tcl')

    env.Command(installdir + '/lib/pkgIndex.tcl',
            [dst_libdurotcl, dst_utiltcl],
			[mkIndex])

env.Install(installdir + '/docs/tcl', durotcldocs)

if env['PLATFORM'] == 'win32':
    env.Install(installdir + '/bin', libduro)
else:
    env.Install(installdir + '/lib', libduro)

if env['PLATFORM'] != 'win32':
    def SymLink(target, source, env):
        os.symlink(os.path.basename(str(source[0])),
                os.path.abspath(str(target[0])))
    env.Command(installdir + '/lib/libduro.so',
            libduro, SymLink)

#
# Distribution tarfile
#

# create .tar.gz, prepend paths with durodbms-<version>
env.Replace(TARFLAGS = '-c --exclude .sconsign --transform \'s,^,durodbms-'
        + release + '/duro/,S\'')

if env.has_key('TAR'):
    disttar = 'durodbms-' + release + '-src.tar'
    disttargz = disttar + '.gz'

    env.Tar('src.tar', Split('SConstruct README README.windows INSTALL '
            'COPYING AUTHORS CHANGES Doxyfile'))
    env.Tar('src.tar', gensrc)
    env.Tar('src.tar', recsrc)
    env.Tar('src.tar', objsrc)
    env.Tar('src.tar', relsrc)
    env.Tar('src.tar', interpsrc)
    env.Tar('src.tar', 'dli/durodt.c')
    env.Tar('src.tar', 'dli/ioop.c')
    env.Tar('src.tar', 'dli/fcgi.c')
    env.Tar('src.tar', durotclsrc)
    env.Tar('src.tar', durodocs)
    env.Tar('src.tar', 'docs/durodt/tut.html')
    env.Tar('src.tar', durotcldocs)
    env.Tar('src.tar', 'docs/api/html')
    env.Tar('src.tar', 'docs/javadoc')
    env.Tar('src.tar', ['duro.def', 'durotcl.def'])
    env.Tar('src.tar', durotcl_hdrs)
    env.Tar('src.tar', testsrc)
    env.Tar('src.tar', testlibsrc)
    env.Tar('src.tar', 'tests/lstables.c')
    env.Tar('src.tar', gen_hdrs)
    env.Tar('src.tar', rec_hdrs)
    env.Tar('src.tar', obj_hdrs)
    env.Tar('src.tar', obj_ihdrs)
    env.Tar('src.tar', rel_hdrs)
    env.Tar('src.tar', rel_ihdrs)
    env.Tar('src.tar', dli_hdrs)
    env.Tar('src.tar', dli_ihdrs)
    env.Tar('src.tar', testlib_hdrs)
    env.Tar('src.tar', test_scripts)
    env.Tar('src.tar', durodt_test_scripts)
    env.Tar('src.tar', tcltools)
    env.Tar('src.tar', ['dli/exparse.y', 'dli/exlex.l'])
    env.Tar('src.tar', 'tcl/util.tcl')
    env.Tar('src.tar', 'jduro/jduro.h')
    env.Tar('src.tar', 'jduro/jduro.c')
    env.Tar('src.tar', 'jduro/probj.c')

    # Copy tarfile and add java source files
    # Don't use env.Tar because relative paths starting with '..'
    # would become absolute paths
    env.Command(disttar,
        ['src.tar'] + Glob('../jduro/src/net/sf/duro/*.java'),
        'cd ..; mv duro/src.tar duro/' + disttar
                + ' && tar -f duro/' + disttar
                + ' --append jduro/src/net/sf/duro/*.java'
                + ' jduro/tests/net/sf/duro/tests/*.java' + ' jduro/examples/*.java'
                + ' --transform \'s,^,durodbms-' + release + '/,S\''
                + ' && gzip -f duro/' + disttar)

    env.Alias('dist', disttar)
