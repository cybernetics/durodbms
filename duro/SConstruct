#
# SCons build file for DuroDBMS
# See the file COPYING for redistribution information.
#
# $Id$
#

import os

#
# Basic settings
#

bdbhome = ARGUMENTS.get('bdbhome', '/usr/local/BerkeleyDB.5.3')
with_durotcl = int(ARGUMENTS.get('with_durotcl', 1))

release = '0.20'

env = Environment(ENV = os.environ, tools = ['default', 'textfile'])

oshlibsuffix = env['SHLIBSUFFIX']

if env['PLATFORM'] == 'win32':
    default_prefix = 'C:'
    env.Replace(LIBS = ['libdb53', 'ltdl', 'shlwapi'])
    durolibs = ['libdb53', 'ltdl', 'regex', 'shlwapi']
else:
    default_prefix = '/usr/local'
    env.Replace(SHLIBSUFFIX = env['SHLIBSUFFIX'] + '.' + release)
    env.Replace(LIBS = ['db', 'ltdl', 'm'])
    durolibs = ['db', 'ltdl', 'm']
prefix = ARGUMENTS.get('prefix', default_prefix)

installdir = prefix + '/durodbms.' + release

env.Replace(CPPPATH = ['.', bdbhome + '/include', '/usr/include/tcl'])
env.Replace(LIBPATH = ['.', bdbhome + '/lib'])
env.Replace(RPATH = [installdir + '/lib', bdbhome + '/lib'])

if (os.environ.has_key('CFLAGS')):
    env.Replace(CCFLAGS = os.environ['CFLAGS'])

if (os.environ.has_key('LDFLAGS')):
    env.Append(LINKFLAGS = os.environ['LDFLAGS'])

#
# DuroDBMS core library
#

if env.has_key('YACC'):
    CFile('dli/exparse.c', 'dli/exparse.y', YACCFLAGS = '-d')
    CFile('dli/exlex.c', 'dli/exlex.l', LEXFLAGS = '-i')

env.Textfile(target = 'gen/releaseno.c', source = ['char *RDB_release_number = "' + release + '";', ''])

gensrc = ['gen/hashmap.c', 'gen/hashmapit.c',
        'gen/strfns.c', 'gen/strdump.c', 'gen/hashtable.c', 'gen/hashtabit.c',
        'gen/releaseno.c']

trsrc = ['obj/object.c', 'obj/excontext.c', 'obj/type.c', 'obj/builtintypes.c', 'obj/io.c',
        'obj/expression.c', 'obj/key.c', 'obj/tuple.c', 'obj/operator.c']

recsrc = ['rec/cursor.c', 'rec/env.c', 'rec/index.c', 'rec/recmap.c']

relsrc = ['rel/array.c', 'rel/database.c', 'rel/uoperator.c',
        'rel/expressionx.c', 'rel/evaluate.c', 'rel/exprtype.c', 'rel/tuplex.c',
        'rel/stable.c', 'rel/qresult.c', 'rel/qr_tclose.c', 'rel/serialize.c',
        'rel/table.c', 'rel/vtable.c', 'rel/ptable.c',
        'rel/aggrf.c', 'rel/update.c', 'rel/insert.c', 'rel/contains.c',
        'rel/transaction.c', 'rel/delete.c',
        'rel/utype.c', 'rel/builtinops.c',
        'rel/objectx.c', 'rel/catalog.c', 'rel/cat_type.c', 'rel/cat_op.c',
        'rel/optimize.c', 'rel/transform.c',
        'rel/constraint.c', 'rel/assign.c', 'obj/opmap.c',
        'rel/match.c', 'rel/tostr.c',
        'rel/pexpr.c', 'util/www.c']

interpsrc = ['dli/exparse.c', 'dli/exlex.c', 'dli/parse.c', 'dli/parsenode.c',
        'dli/iinterp.c', 'dli/interp_core.c', 'dli/interp_assign.c', 'dli/ioop.c']

durosrc = gensrc + trsrc + recsrc + relsrc + interpsrc

if env['PLATFORM'] == 'win32':
    duroccflags = '/DNO_DLL_IMPORT'
    libduro = env.SharedLibrary('duro', durosrc + ['duro.def'],
            LIBS = durolibs, CCFLAGS = duroccflags)
else:
    duroccflags = env['CCFLAGS']
    libduro = env.SharedLibrary('duro', durosrc,
            LIBS = durolibs, CCFLAGS = duroccflags)

#
# Tcl interface
#

durotclsrc = ['tcl/duro.c', 'tcl/envcmd.c',
        'tcl/txcmd.c', 'tcl/tablecmd.c', 'tcl/dbcmd.c', 'tcl/arraycmd.c',
        'tcl/opcmd.c', 'tcl/exprcmd.c', 'tcl/typecmd.c', 'tcl/indexcmd.c',
        'tcl/insertcmd.c', 'tcl/updatecmd.c', 'tcl/constrcmd.c',
        'tcl/massigncmd.c']

libdurotcllibs = ['duro']

if env['PLATFORM'] == 'win32':
    libdurotcllibs += ['tcl85', 'libdb53']
    libdurotcl = env.SharedLibrary('durotcl', durotclsrc + ['durotcl.def'],
            LIBS = libdurotcllibs)
else:
    libdurotcl = env.SharedLibrary('durotcl', [durotclsrc, libduro])

#
# Interpreter
#

ioop_fcgi_o = env.Object('dli/fcgi_ioop', 'dli/ioop.c',
        CFLAGS=env['CFLAGS'] + ' -DDURO_FCGI')

durodt_o = env.Object('dli/durodt.c')

if env['PLATFORM'] == 'win32':
    durodt = env.Program([durodt_o],
            LIBS = env['LIBS'] + ['duro'])
    fcgi_durodt = env.Program('dli/fcgi_durodt', [durodt_o, ioop_fcgi_o, 'dli/fcgi.c'],
            LIBS = env['LIBS'] + ['duro', 'fcgi'])
else:
    durodt = env.Program([durodt_o],
            LIBS = env['LIBS'] + ['readline', libduro])
    fcgi_durodt = env.Program('dli/fcgi_durodt', [durodt_o, ioop_fcgi_o, 'dli/fcgi.c'],
            LIBS = env['LIBS'] + ['readline', libduro, 'fcgi'])

#
# Docs
#

env.Alias('apidocs', 'docs/api/html/index.html')

env.Command('docs/api/html/index.html',
        ['Doxyfile'] + recsrc + relsrc + interpsrc + ['rel/rdb.h']
            + ['dli/parse.c', 'dli/ioop.c', 'dli/iinterp.c', 'dli/parse.h'],
        'doxygen')

#
# Defaults
#

Default(libduro)
Default(durodt)

if with_durotcl:
     Default(libdurotcl)

#
# Tests
#

testenv = env.Clone(RPATH = [bdbhome + '/lib'], SHLIBSUFFIX = oshlibsuffix)

testsrc = Split('tests/tupletest.c tests/maptest.c '
        'tests/prepare.c tests/test_aggregate.c '
        'tests/test_binary.c tests/test_create_view.c '
        'tests/test_defpointtype.c tests/test_deftype.c '
        'tests/test_delete.c tests/test_extend.c '
        'tests/test_union.c tests/test_minus.c '
        'tests/test_intersect.c tests/test_join.c '
        'tests/test_keys.c tests/test_null.c tests/test_relation_op.c '
        'tests/test_pointtable.c tests/test_print_view.c '
        'tests/test_project.c tests/test_ra.c '
        'tests/test_regexp.c tests/test_rename.c tests/test_select.c '
        'tests/test_summarize.c tests/test_update.c tests/test_utypetable.c '
        'tests/test_srupdate.c tests/test_insert.c tests/test_2db.c '
        'tests/test_defop.c tests/test_callop.c '
        'tests/test_print_opview.c tests/test_dropop.c tests/test_lupdate.c '
        'tests/test_assign_where.c tests/test_interp.c')

testlibsrc = ['tests/point.c', 'tests/point.def', 'tests/plus.c',
        'tests/plus.def']

testbins = []
for s in testsrc:
    if env['PLATFORM'] == 'win32':
        testbins.append(testenv.Program(s, LIBS = env['LIBS'] + ['duro']))
    else:
        testbins.append(testenv.Program(s, LIBS = env['LIBS'] + libduro))

if env['PLATFORM'] == 'win32':
    testbins.append(testenv.Program('tests/lstables.c',
            LIBS = env['LIBS'] + ['duro']))
else:
    testbins.append(testenv.Program('tests/lstables.c',
            LIBS = env['LIBS'] + libduro))

if env['PLATFORM'] == 'win32':
    testbins.append(testenv.SharedLibrary(['tests/point.c', 'tests/point.def'],
            LIBS = env['LIBS'] + ['duro']))
else:
    testbins.append(testenv.SharedLibrary(['tests/point.c']))

if env['PLATFORM'] == 'win32':
    testbins.append(testenv.SharedLibrary(['tests/plus.c', 'tests/plus.def'],
            LIBS = env['LIBS'] + ['duro']))
else:
    testbins.append(testenv.SharedLibrary(['tests/plus.c']))

test_scripts = Split('tests/aggr.test tests/constraints.test tests/convert.test '
        'tests/ctests.test tests/db2.test tests/deedum.test tests/index.test '
        'tests/invtable.test tests/ltables.test tests/massign.test '
        'tests/oindex.test tests/operator.test tests/opt.test '
        'tests/parse.test tests/project.test tests/qqueries.test '
        'tests/rel.test tests/rollback.test tests/rtables.test '
        'tests/sdivide.test tests/string.test tests/subset.test '
        'tests/transform.test tests/tuple.test tests/update.test '
        'tests/utype.test tests/vtables.test '
        'tests/all.tcl tests/testutil.tcl tests/setup.tcl')
durodt_test_scripts = Split('tests/durodt/array.test tests/durodt/relation.test '
        'tests/durodt/scalar.test tests/durodt/scalar.td '
        'tests/durodt/tuple.test '
        'tests/durodt/all.tcl')

test = env.Command('tests/passed', [libduro, libdurotcl, testbins, durodt],
        'tclsh tests/all.tcl -verbose "{pass error}"')

env.Alias('test', test)

env.Alias('testbins', testbins)

#
# Installation
#

gen_hdrs = Split('gen/hashmap.h gen/hashmapit.h gen/hashtable.h '
        'gen/hashtabit.h gen/strfns.h gen/strdump.h gen/types.h '
        'gen/releaseno.h')
rec_hdrs = Split('rec/cursor.h rec/env.h rec/dbdefs.h rec/index.h rec/recmap.h')
obj_hdrs = Split('obj/object.h obj/excontext.h obj/type.h obj/builtintypes.h '
                'obj/expression.h obj/operator.h obj/opmap.h obj/tuple.h')
obj_ihdrs = Split('obj/io.h obj/key.h obj/objinternal.h')
rel_hdrs = Split('rel/rdb.h rel/typeimpl.h util/www.h '
                 'rel/optimize.h rel/qresult.h rel/tostr.h ')
rel_ihdrs = Split('rel/catalog.h rel/cat_type.h rel/cat_op.h '
		'rel/delete.h rel/serialize.h '
        'rel/insert.h rel/transform.h rel/internal.h rel/stable.h '
        'rel/update.h rel/qr_tclose.h '
        'rel/pexpr.h')
dli_hdrs = ['dli/parse.h', 'dli/parsenode.h']
dli_ihdrs = ['dli/exparse.h', 'dli/iinterp.h', 'dli/interp_core.h',
        'dli/interp_assign.h', 'dli/ioop.h', 'dli/fcgi.h']
durotcl_hdrs = ['tcl/duro.h']
testlib_hdrs = ['tests/point.h']

tcltools = ['tcl/duroadmin.tcl', 'tcl/durodump.tcl']

durodocs = ['docs/index.html', 'docs/expressions.html', 'docs/utils.html',
        'docs/migration.html', 'docs/fastcgi.html', 'docs/style.css']

durotcldocs = Split('docs/tcl/index.html docs/tcl/array.html '
        'docs/tcl/begin.html docs/tcl/call.html '
        'docs/tcl/commit.html docs/tcl/db.html docs/tcl/delete.html '
        'docs/tcl/env.html docs/tcl/expr.html docs/tcl/insert.html '
        'docs/tcl/operator.html docs/tcl/ptable.html docs/tcl/rollback.html '
        'docs/tcl/txdb.html docs/tcl/table.html docs/tcl/update.html '
        'docs/tcl/type.html docs/tcl/indexcmd.html docs/tcl/constraint.html '
        'docs/tcl/massign.html docs/tcl/errorCode.html')

env.Alias('install', installdir)

env.Install(installdir + '/include/gen', gen_hdrs)
env.Install(installdir + '/include/rec', rec_hdrs)
env.Install(installdir + '/include/obj', obj_hdrs)
env.Install(installdir + '/include/rel', rel_hdrs)
env.Install(installdir + '/include/dli', dli_hdrs)
env.Install(installdir + '/docs', durodocs)
env.Install(installdir + '/docs/durodt', 'docs/durodt/tut.html')
# 'scons install' does not rebuild api docs
env.Command(installdir + '/docs/api/html', [], Copy("$TARGET", 'docs/api/html'))
env.Install(installdir + '/bin', durodt)

# Install fcgi_durodt only if it has been built
if os.path.exists(str(fcgi_durodt[0])):
    env.Install(installdir + '/bin', fcgi_durodt)

def mkIndex(env, target, source):
    import os
    open('tmp.tcl', 'w').write('pkg_mkIndex ' + installdir + '/lib ' + libdurotcl[0].path + ' util.tcl')
    os.system('tclsh tmp.tcl')
    os.remove('tmp.tcl')

# Install durotcl only if libdurotcl has been built
if os.path.exists(str(libdurotcl[0])):
    env.Install(installdir + '/bin', tcltools)
    dst_libdurotcl = env.Install(installdir + '/lib', libdurotcl)
    dst_utiltcl = env.Install(installdir + '/lib', 'tcl/util.tcl')

    env.Command(installdir + '/lib/pkgIndex.tcl',
            [dst_libdurotcl, dst_utiltcl],
			[mkIndex])

env.Install(installdir + '/docs/tcl', durotcldocs)

if env['PLATFORM'] == 'win32':
    env.Install(installdir + '/bin', libduro)
else:
    env.Install(installdir + '/lib', libduro)

if env['PLATFORM'] != 'win32':
    def SymLink(target, source, env):
        os.symlink(os.path.basename(str(source[0])),
                os.path.abspath(str(target[0])))
    env.Command(installdir + '/lib/libduro.so',
            libduro, SymLink)

#
# Distribution tarfile
#

# create .tar.gz, prepend paths with durodbms-<version>
env.Replace(TARFLAGS = '-c -z --exclude .sconsign --transform \'s,^,durodbms-'
        + release + '/,S\'')

if env.has_key('TAR'):
    disttar = 'durodbms-' + release + '-src.tar.gz'

    env.Tar(disttar, Split('SConstruct README README.windows INSTALL '
            'COPYING AUTHORS CHANGES Doxyfile'))
    env.Tar(disttar, gensrc)
    env.Tar(disttar, recsrc)
    env.Tar(disttar, trsrc)
    env.Tar(disttar, relsrc)
    env.Tar(disttar, interpsrc)
    env.Tar(disttar, 'dli/durodt.c')
    env.Tar(disttar, 'dli/ioop.c')
    env.Tar(disttar, 'dli/fcgi.c')
    env.Tar(disttar, durotclsrc)
    env.Tar(disttar, durodocs)
    env.Tar(disttar, 'docs/durodt/tut.html')
    env.Tar(disttar, durotcldocs)
    env.Tar(disttar, 'docs/api/html')
    env.Tar(disttar, ['duro.def', 'durotcl.def'])
    env.Tar(disttar, durotcl_hdrs)
    env.Tar(disttar, testsrc)
    env.Tar(disttar, testlibsrc)
    env.Tar(disttar, 'tests/lstables.c')
    env.Tar(disttar, gen_hdrs)
    env.Tar(disttar, rec_hdrs)
    env.Tar(disttar, obj_hdrs)
    env.Tar(disttar, obj_ihdrs)
    env.Tar(disttar, rel_hdrs)
    env.Tar(disttar, rel_ihdrs)
    env.Tar(disttar, dli_hdrs)
    env.Tar(disttar, dli_ihdrs)
    env.Tar(disttar, testlib_hdrs)
    env.Tar(disttar, test_scripts)
    env.Tar(disttar, durodt_test_scripts)
    env.Tar(disttar, tcltools)
    env.Tar(disttar, ['dli/exparse.y', 'dli/exlex.l'])
    env.Tar(disttar, 'tcl/util.tcl')

    env.Alias('dist', disttar)
